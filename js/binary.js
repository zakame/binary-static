webpackJsonp([2],[
/* 0 */,
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var extend = __webpack_require__(547);
__webpack_require__(248);

/**
 * Write loading image to a container for ajax request
 *
 * @param container: a DOM element
 * @param theme: dark or white
 */
var showLoadingImage = function showLoadingImage(container) {
    var theme = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'dark';

    var loading_div = createElement('div', { class: 'barspinner ' + theme, html: Array.from(new Array(5)).map(function (x, i) {
            return '<div class="rect' + (i + 1) + '"></div>';
        }).join('') });
    container.html(loading_div);
};

/**
 * Returns the highest z-index in the page.
 * Accepts a selector to only check those elements,
 * uses all container tags by default
 * If no element found, returns null.
 *
 * @param selector: a selector for target elements
 * @return int|null
 */
var getHighestZIndex = function getHighestZIndex() {
    var selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'div,p,area,nav,section,header,canvas,aside,span';

    var elements = selector.split(',');
    var all = [];

    for (var i = 0; i < elements.length; i++) {
        var els = document.getElementsByTagName(elements);
        for (var j = 0; j < els.length; j++) {
            if (els[i].offsetParent) {
                var z = els[i].style['z-index'];
                if (!isNaN(z)) {
                    all.push(z);
                }
            }
        }
    }

    return all.length ? Math.max.apply(Math, all) : null;
};

var downloadCSV = function downloadCSV(csv_contents) {
    var filename = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'data.csv';

    if (navigator.msSaveBlob) {
        // IE 10+
        navigator.msSaveBlob(new Blob([csv_contents], { type: 'text/csv;charset=utf-8;' }), filename);
    } else {
        // Other browsers
        var csv = 'data:text/csv;charset=utf-8,' + csv_contents;
        var download_link = createElement('a', { href: encodeURI(csv), download: filename });

        if (document.body) {
            document.body.appendChild(download_link);
            download_link.click();
            document.body.removeChild(download_link);
        }
    }
};

var template = function template(string, content) {
    return string.replace(/\[_(\d+)]/g, function (s, index) {
        return content[+index - 1];
    });
};

var isEmptyObject = function isEmptyObject(obj) {
    var is_empty = true;
    if (obj && obj instanceof Object) {
        Object.keys(obj).forEach(function (key) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) is_empty = false;
        });
    }
    return is_empty;
};

var cloneObject = function cloneObject(obj) {
    return !isEmptyObject(obj) ? extend(true, Array.isArray(obj) ? [] : {}, obj) : obj;
};

var getPropertyValue = function getPropertyValue(obj, k) {
    var keys = k;
    if (!Array.isArray(keys)) keys = [keys];
    if (!isEmptyObject(obj) && keys[0] in obj && keys && keys.length > 1) {
        return getPropertyValue(obj[keys[0]], keys.slice(1));
    }
    // else return clone of object to avoid overwriting data
    return obj ? cloneObject(obj[keys[0]]) : undefined;
};

var handleHash = function handleHash() {
    var hash = window.location.hash;
    if (hash) {
        document.querySelector('a[href="' + hash + '"]').click();
    }
};

var clearable = function clearable(element) {
    element.addClass('clear');
    document.addEventListener('mousemove', function (e) {
        if (/clear/.test(e.target.classList)) {
            e.stopPropagation();
            e.target.toggleClass('onClear', e.target.offsetWidth - 18 < e.clientX - e.target.getBoundingClientRect().left);
        }
    });
    document.addEventListener('mousedown', function (e) {
        if (/onClear/.test(e.target.classList)) {
            e.stopPropagation();
            e.target.setAttribute('data-value', '');
            e.target.classList.remove('clear', 'onClear');
            e.target.value = '';
            e.target.dispatchEvent(new Event('change'));
        }
    });
};

/**
 * Creates a DOM element and adds any attributes to it.
 *
 * @param {String} tag_name: the tag to create, e.g. 'div', 'a', etc
 * @param {Object} attributes: all the attributes to assign, e.g. { id: '...', class: '...', html: '...', ... }
 * @return the created DOM element
 */
var createElement = function createElement(tag_name) {
    var attributes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var el = document.createElement(tag_name);
    Object.keys(attributes).forEach(function (attr) {
        var value = attributes[attr];
        if (attr === 'text') {
            el.textContent = value;
        } else if (attr === 'html') {
            el.html(value);
        } else {
            el.setAttribute(attr, value);
        }
    });
    return el;
};

/**
 * Apply function to all elements based on selector passed
 *
 * @param {String|Element} selector: selector of the elements to apply the function to, e.g. '.class', '#id', 'tag', etc
 * can also be a DOM element
 * @param {Function} funcToRun: function to apply
 * @param {String} func_selector: method of finding the selector, optional
 * @param {Element} el_parent: parent of the selector, document by default
 */
var applyToAllElements = function applyToAllElements(selector, funcToRun, func_selector, el_parent) {
    if (!selector || !funcToRun) {
        return;
    }

    var function_selector = func_selector;
    var element_to_select = selector;
    if (!func_selector && !element_to_select.nodeName) {
        if (/[\s#]/.test(element_to_select) || element_to_select.lastIndexOf('.') !== 0) {
            function_selector = 'querySelectorAll';
        } else if (element_to_select.lastIndexOf('.') === 0) {
            function_selector = 'getElementsByClassName';
            element_to_select = element_to_select.substring(1);
        } else if (/^[a-zA-Z]+$/.test(element_to_select)) {
            function_selector = 'getElementsByTagName';
        }
    }
    var parent_element = el_parent || document;
    var el = element_to_select.nodeName || (typeof element_to_select === 'undefined' ? 'undefined' : _typeof(element_to_select)) === 'object' ? element_to_select : parent_element[function_selector](element_to_select);
    for (var i = 0; i < el.length; i++) {
        funcToRun(el[i]);
    }
};

/**
 * Returns the first parent element that matches the selector (including el itself)
 *
 * @param {Element} el      : element to start looking for parent
 * @param {String}  selector: selector to find the element that matches to, e.g. '.class', '#id', 'tag', or a combination of them
 */
var findParent = function findParent(el, selector) {
    if (el && el.nodeName !== 'BODY' && typeof el.matches === 'function') {
        return el.matches(selector) ? el : findParent(el.parentNode, selector);
    }
    return null;
};

var static_hash = void 0;
var getStaticHash = function getStaticHash() {
    static_hash = static_hash || (document.querySelector('script[src*="binary.min.js"],script[src*="binary.js"]').getAttribute('src') || '').split('?')[1];
    return static_hash;
};

module.exports = {
    showLoadingImage: showLoadingImage,
    getHighestZIndex: getHighestZIndex,
    downloadCSV: downloadCSV,
    template: template,
    isEmptyObject: isEmptyObject,
    cloneObject: cloneObject,
    getPropertyValue: getPropertyValue,
    handleHash: handleHash,
    clearable: clearable,
    createElement: createElement,
    applyToAllElements: applyToAllElements,
    findParent: findParent,
    getStaticHash: getStaticHash
};

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var moment = __webpack_require__(9);
var template = __webpack_require__(1).template;

var Localize = function () {
    var localized_texts = void 0;

    var localizeForLang = function localizeForLang(lang) {
        localized_texts = texts_json[lang.toUpperCase()];
        moment.locale(lang.toLowerCase());
    };

    var doLocalize = function doLocalize(txt, params) {
        var text = txt;

        var index = text.replace(/[\s|.]/g, '_');

        text = localized_texts && localized_texts[index] || text;

        // only use template when explicitly required
        return params ? template(text, params) : text;
    };

    var localize = function localize(text, params) {
        return Array.isArray(text) ? text.map(function (t) {
            return doLocalize(t, params);
        }) : doLocalize(text, params);
    };

    return {
        localize: localize,
        forLang: localizeForLang
    };
}();

module.exports = Localize;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BinarySocket = __webpack_require__(5);
var RealityCheckData = __webpack_require__(130);
var ClientBase = __webpack_require__(85);
var SocketCache = __webpack_require__(74);
var getElementById = __webpack_require__(4).getElementById;
var urlLang = __webpack_require__(16).urlLang;
var removeCookies = __webpack_require__(6).removeCookies;
var State = __webpack_require__(6).State;
var urlFor = __webpack_require__(8).urlFor;
var applyToAllElements = __webpack_require__(1).applyToAllElements;
var getPropertyValue = __webpack_require__(1).getPropertyValue;

var Client = function () {
    var processNewAccount = function processNewAccount(options) {
        if (ClientBase.setNewAccount(options)) {
            window.location.href = options.redirect_url || defaultRedirectUrl(); // need to redirect not using pjax
        }
    };

    var shouldShowJP = function shouldShowJP(el) {
        return isJPClient() ? !/ja-hide/.test(el.classList) || /ja-show/.test(el.classList) : !/ja-show/.test(el.classList);
    };

    var activateByClientType = function activateByClientType(section_id) {
        var topbar_class = getElementById('topbar').classList;
        var el_section = section_id ? getElementById(section_id) : document.body;

        var primary_bg_color_dark = 'primary-bg-color-dark';
        var secondary_bg_color = 'secondary-bg-color';

        if (ClientBase.isLoggedIn()) {
            BinarySocket.wait('authorize', 'website_status', 'get_account_status').then(function () {
                var client_logged_in = getElementById('client-logged-in');
                client_logged_in.classList.add('gr-centered');

                applyToAllElements('.client_logged_in', function (el) {
                    if (shouldShowJP(el)) {
                        el.setVisibility(1);
                    }
                });

                if (ClientBase.get('is_virtual')) {
                    applyToAllElements('.client_virtual', function (el) {
                        el.setVisibility(1);
                    }, '', el_section);
                    topbar_class.add(secondary_bg_color);
                    topbar_class.remove(primary_bg_color_dark);
                } else {
                    applyToAllElements('.client_real', function (el) {
                        if (shouldShowJP(el)) {
                            el.setVisibility(1);
                        }
                    }, '', el_section);
                    topbar_class.add(primary_bg_color_dark);
                    topbar_class.remove(secondary_bg_color);
                }
            });
        } else {
            applyToAllElements('.client_logged_out', function (el) {
                if (shouldShowJP(el)) {
                    el.setVisibility(1);
                }
            }, '', el_section);
            topbar_class.add(primary_bg_color_dark);
            topbar_class.remove(secondary_bg_color);
        }
    };

    var sendLogoutRequest = function sendLogoutRequest(show_login_page) {
        if (show_login_page) {
            sessionStorage.setItem('showLoginPage', 1);
        }
        BinarySocket.send({ logout: '1' });
    };

    var doLogout = function doLogout(response) {
        if (response.logout !== 1) return;
        removeCookies('login', 'loginid', 'loginid_list', 'email', 'residence', 'settings'); // backward compatibility
        removeCookies('reality_check', 'affiliate_token', 'affiliate_tracking');
        ClientBase.clearAllAccounts();
        ClientBase.set('loginid', '');
        SocketCache.clear();
        RealityCheckData.clear();
        var redirect_to = getPropertyValue(response, ['echo_req', 'passthrough', 'redirect_to']);
        if (redirect_to) {
            window.location.href = redirect_to;
        } else {
            window.location.reload();
        }
    };

    var getUpgradeInfo = function getUpgradeInfo() {
        var upgrade_info = ClientBase.getBasicUpgradeInfo();

        var upgrade_link = void 0;
        if (upgrade_info.can_upgrade_to) {
            var upgrade_link_map = {
                realws: ['costarica', 'iom', 'malta'],
                maltainvestws: ['maltainvest'],
                japanws: ['japan']
            };
            upgrade_link = Object.keys(upgrade_link_map).find(function (link) {
                return upgrade_link_map[link].indexOf(upgrade_info.can_upgrade_to) !== -1;
            });
        }

        return Object.assign(upgrade_info, {
            upgrade_link: upgrade_link ? 'new_account/' + upgrade_link : undefined,
            is_current_path: upgrade_link ? new RegExp(upgrade_link, 'i').test(window.location.pathname) : undefined
        });
    };

    var defaultRedirectUrl = function defaultRedirectUrl() {
        return urlFor(isJPClient() ? 'multi_barriers_trading' : 'trading');
    };

    var setJPFlag = function setJPFlag() {
        var is_jp_client = urlLang() === 'ja' || ClientBase.get('residence') === 'jp';
        State.set('is_jp_client', is_jp_client); // accessible by files that cannot call Client
    };

    var isJPClient = function isJPClient() {
        return State.get('is_jp_client');
    };

    return Object.assign({
        processNewAccount: processNewAccount,
        activateByClientType: activateByClientType,
        sendLogoutRequest: sendLogoutRequest,
        doLogout: doLogout,
        getUpgradeInfo: getUpgradeInfo,
        defaultRedirectUrl: defaultRedirectUrl,
        setJPFlag: setJPFlag,
        isJPClient: isJPClient
    }, ClientBase);
}();

module.exports = Client;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var createElement = __webpack_require__(1).createElement;

// show hedging value if trading purpose is set to hedging else hide it
var detectHedging = function detectHedging($purpose, $hedging) {
    $purpose.change(function () {
        $hedging.setVisibility($purpose.val() === 'Hedging');
    });
};

var jqueryuiTabsToDropdown = function jqueryuiTabsToDropdown($container) {
    var $ddl = $('<select/>');
    $container.find('li a').each(function () {
        $ddl.append($('<option/>', { text: $(this).text(), value: $(this).attr('href') }));
    });
    $ddl.change(function () {
        $container.find('li a[href="' + $(this).val() + '"]').click();
    });
    return $ddl;
};

var makeOption = function makeOption(options) {
    // setting null value helps with detecting required error
    // on 'Please select' options
    // that have no value of their own
    var option_el = createElement('option', { text: options.text, value: options.value || '' });

    if (options.is_disabled && options.is_disabled.toLowerCase() === 'disabled') {
        option_el.setAttribute('disabled', 'disabled');
    }
    if (options.class) {
        option_el.className = options.class;
    }
    if (options.is_selected) {
        option_el.setAttribute('selected', 'selected');
    }
    return option_el;
};

/*
 * function to check if element is visible or not
 *
 * alternative to jquery $('#id').is(':visible')
 */
var isVisible = function isVisible(elem) {
    return !(!elem || elem.offsetWidth === 0 && elem.offsetHeight === 0);
};

/*
 * function to check if browser supports the type date/time
 * send a wrong val in case browser 'pretends' to support
 */
var checkInput = function checkInput(type, wrong_val) {
    var input = createElement('input', { type: type, value: wrong_val });
    return input.value !== wrong_val;
};

/*
 * function to check if new date is selected using native picker
 * if yes, update the data-value. if no, return false.
 */
var dateValueChanged = function dateValueChanged(element, type) {
    var value = void 0;
    if (element.selectedOptions) {
        value = element.selectedOptions[0].getAttribute('data-value');
    } else {
        value = element.value;
    }
    if (element.getAttribute('data-value') === value) {
        return false;
    }
    if (element.getAttribute('type') === type) {
        element.setAttribute('data-value', value);
    }
    return true;
};

var selectorExists = function selectorExists(element) {
    return typeof element !== 'undefined' && element !== null;
};

var getSetElementValue = function getSetElementValue(element, text, type) {
    // eslint-disable-line consistent-return
    if (selectorExists(element)) {
        if (typeof text === 'undefined') return element[type];
        // else
        element[type] = text;
    }
};

/*
 * @param  {String}  id_selector   the selector for the element
 * @param  {Element} parent        optional selector to use for parent, defaults to document
 * @return {Element}               return element if it exists, if it doesn't return a dummy element
 */
var getElementById = function getElementById(id_selector) {
    var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;
    return parent.getElementById(id_selector) || createElement('div');
};

/*
 * @param  {String}  class_name    the selector class for the element
 * @param  {Element} parent        optional selector to use for parent, defaults to document
 * @return {Element}               return element if it is visible
 */
var getVisibleElement = function getVisibleElement(class_name) {
    var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;
    return Array.from(parent.getElementsByClassName(class_name)).find(function (el) {
        return isVisible(el);
    });
};

module.exports = {
    detectHedging: detectHedging,
    jqueryuiTabsToDropdown: jqueryuiTabsToDropdown,
    makeOption: makeOption,
    isVisible: isVisible,
    checkInput: checkInput,
    dateValueChanged: dateValueChanged,
    selectorExists: selectorExists,
    getElementById: getElementById,
    getVisibleElement: getVisibleElement,
    elementTextContent: function elementTextContent(element, text) {
        return getSetElementValue(element, text, 'textContent');
    },
    elementInnerHtml: function elementInnerHtml(element, text) {
        return getSetElementValue(element, text, 'innerHTML');
    }
};

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BinarySocketBase = __webpack_require__(86);

// This is to maintain the current references and also to provide the ability to extend this section separately in the future
module.exports = BinarySocketBase;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Cookies = __webpack_require__(50);
var getPropertyValue = __webpack_require__(1).getPropertyValue;
var isEmptyObject = __webpack_require__(1).isEmptyObject;

var getObject = function getObject(key) {
    return JSON.parse(this.getItem(key) || '{}');
};

var setObject = function setObject(key, value) {
    if (value && value instanceof Object) {
        this.setItem(key, JSON.stringify(value));
    }
};

if (typeof Storage !== 'undefined') {
    Storage.prototype.getObject = getObject;
    Storage.prototype.setObject = setObject;
}

var isStorageSupported = function isStorageSupported(storage) {
    if (typeof storage === 'undefined') {
        return false;
    }

    var test_key = 'test';
    try {
        storage.setItem(test_key, '1');
        storage.removeItem(test_key);
        return true;
    } catch (e) {
        return false;
    }
};

var Store = function Store(storage) {
    this.storage = storage;
    this.storage.getObject = getObject;
    this.storage.setObject = setObject;
};

Store.prototype = {
    get: function get(key) {
        return this.storage.getItem(key) || undefined;
    },
    set: function set(key, value) {
        if (typeof value !== 'undefined') {
            this.storage.setItem(key, value);
        }
    },
    getObject: function getObject(key) {
        return typeof this.storage.getObject === 'function' ? // Prevent runtime error in IE
        this.storage.getObject(key) : JSON.parse(this.storage.getItem(key) || '{}');
    },
    setObject: function setObject(key, value) {
        if (typeof this.storage.setObject === 'function') {
            // Prevent runtime error in IE
            this.storage.setObject(key, value);
        } else {
            this.storage.setItem(key, JSON.stringify(value));
        }
    },
    remove: function remove(key) {
        this.storage.removeItem(key);
    },
    clear: function clear() {
        this.storage.clear();
    }
};

var InScriptStore = function InScriptStore(object) {
    this.store = typeof object !== 'undefined' ? object : {};
};

InScriptStore.prototype = {
    get: function get(key) {
        return getPropertyValue(this.store, key);
    },
    set: function set(k, value) {
        var obj = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.store;

        var key = k;
        if (!Array.isArray(key)) key = [key];
        if (key.length > 1) {
            if (!(key[0] in obj) || isEmptyObject(obj[key[0]])) obj[key[0]] = {};
            this.set(key.slice(1), value, obj[key[0]]);
        } else {
            obj[key[0]] = value;
        }
    },
    getObject: function getObject(key) {
        return JSON.parse(this.get(key) || '{}');
    },
    setObject: function setObject(key, value) {
        this.set(key, JSON.stringify(value));
    },
    remove: function remove() {
        var _this = this;

        for (var _len = arguments.length, keys = Array(_len), _key = 0; _key < _len; _key++) {
            keys[_key] = arguments[_key];
        }

        keys.forEach(function (key) {
            delete _this.store[key];
        });
    },
    clear: function clear() {
        this.store = {};
    },
    has: function has(key) {
        return this.get(key) !== undefined;
    },
    keys: function keys() {
        return Object.keys(this.store);
    },
    call: function call(key) {
        if (typeof this.get(key) === 'function') this.get(key)();
    }
};

var State = new InScriptStore();
State.prototype = InScriptStore.prototype;
/**
 * Shorthand function to get values from response object of State
 *
 * @param {String} pathname
 *     e.g. getResponse('authorize.currency') == get(['response', 'authorize', 'authorize', 'currency'])
 */
State.prototype.getResponse = function (pathname) {
    var path = pathname;
    if (typeof path === 'string') {
        var _keys = path.split('.');
        path = ['response', _keys[0]].concat(_keys);
    }
    return this.get(path);
};
State.set('response', {});

var CookieStorage = function CookieStorage(cookie_name, cookie_domain) {
    var hostname = window.location.hostname;

    this.initialized = false;
    this.cookie_name = cookie_name;
    this.domain = cookie_domain || (/\.binary\.com/i.test(hostname) ? '.' + hostname.split('.').slice(-2).join('.') : hostname);
    this.path = '/';
    this.expires = new Date('Thu, 1 Jan 2037 12:00:00 GMT');
    this.value = {};
};

CookieStorage.prototype = {
    read: function read() {
        var cookie_value = Cookies.get(this.cookie_name);
        try {
            this.value = cookie_value ? JSON.parse(cookie_value) : {};
        } catch (e) {
            this.value = {};
        }
        this.initialized = true;
    },
    write: function write(val, expireDate, isSecure) {
        if (!this.initialized) this.read();
        this.value = val;
        if (expireDate) this.expires = expireDate;
        Cookies.set(this.cookie_name, this.value, {
            expires: this.expires,
            path: this.path,
            domain: this.domain,
            secure: !!isSecure
        });
    },
    get: function get(key) {
        if (!this.initialized) this.read();
        return this.value[key];
    },
    set: function set(key, val) {
        if (!this.initialized) this.read();
        this.value[key] = val;
        Cookies.set(this.cookie_name, this.value, {
            expires: new Date(this.expires),
            path: this.path,
            domain: this.domain
        });
    },
    remove: function remove() {
        Cookies.remove(this.cookie_name, {
            path: this.path,
            domain: this.domain
        });
    }
};

var removeCookies = function removeCookies() {
    for (var _len2 = arguments.length, cookie_names = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        cookie_names[_key2] = arguments[_key2];
    }

    var domains = ['.' + document.domain.split('.').slice(-2).join('.'), '.' + document.domain];

    var parent_path = window.location.pathname.split('/', 2)[1];
    if (parent_path !== '') {
        parent_path = '/' + parent_path;
    }

    cookie_names.forEach(function (c) {
        Cookies.remove(c, { path: '/', domain: domains[0] });
        Cookies.remove(c, { path: '/', domain: domains[1] });
        Cookies.remove(c);
        if (new RegExp(c).test(document.cookie) && parent_path) {
            Cookies.remove(c, { path: parent_path, domain: domains[0] });
            Cookies.remove(c, { path: parent_path, domain: domains[1] });
            Cookies.remove(c, { path: parent_path });
        }
    });
};

var SessionStore = void 0,
    LocalStore = void 0;

if (isStorageSupported(window.localStorage)) {
    LocalStore = new Store(window.localStorage);
}
if (isStorageSupported(window.sessionStorage)) {
    SessionStore = new Store(window.sessionStorage);
}

if (!LocalStore) {
    LocalStore = new InScriptStore();
}
if (!SessionStore) {
    SessionStore = new InScriptStore();
}

module.exports = {
    isStorageSupported: isStorageSupported,
    CookieStorage: CookieStorage,
    removeCookies: removeCookies,
    State: State,
    SessionStore: SessionStore,
    LocalStore: LocalStore
};

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var CurrencyBase = __webpack_require__(118);
var localize = __webpack_require__(2).localize;

var getCurrencyList = function getCurrencyList(currencies) {
    var $currencies = $('<select/>');
    var $fiat_currencies = $('<optgroup/>', { label: localize('Fiat') });
    var $cryptocurrencies = $('<optgroup/>', { label: localize('Crypto') });

    currencies.forEach(function (currency) {
        (CurrencyBase.isCryptocurrency(currency) ? $cryptocurrencies : $fiat_currencies).append($('<option/>', { value: currency, text: currency }));
    });

    return $currencies.append($fiat_currencies.children().length ? $fiat_currencies : '').append($cryptocurrencies.children().length ? $cryptocurrencies : '');
};

module.exports = Object.assign({
    getCurrencyList: getCurrencyList
}, CurrencyBase);

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var urlForLanguage = __webpack_require__(16).urlFor;
var urlLang = __webpack_require__(16).urlLang;
var createElement = __webpack_require__(1).createElement;
var isEmptyObject = __webpack_require__(1).isEmptyObject;
__webpack_require__(564);

var Url = function () {
    var location_url = void 0,
        static_host = void 0;

    var init = function init(url) {
        location_url = url ? getLocation(url) : window.location;
    };

    var getLocation = function getLocation(url) {
        return createElement('a', { href: decodeURIComponent(url) });
    };

    var reset = function reset() {
        location_url = window ? window.location : location_url;
    };

    var params = function params(href) {
        var arr_params = [];
        var parsed = ((href ? new URL(href) : location_url).search || '').substr(1).split('&');
        var p_l = parsed.length;
        while (p_l--) {
            var param = parsed[p_l].split('=');
            arr_params.push(param);
        }
        return arr_params;
    };

    var paramsHash = function paramsHash(href) {
        var param_hash = {};
        var arr_params = params(href);
        var param = arr_params.length;
        while (param--) {
            if (arr_params[param][0]) {
                param_hash[arr_params[param][0]] = arr_params[param][1] || '';
            }
        }
        return param_hash;
    };

    var paramsHashToString = function paramsHashToString(pars) {
        return isEmptyObject(pars) ? '' : Object.keys(pars).map(function (key) {
            return key + '=' + (pars[key] || '');
        }).join('&');
    };

    var normalizePath = function normalizePath(path) {
        return path ? path.replace(/(^\/|\/$|[^a-zA-Z0-9-_/])/g, '') : '';
    };

    var urlFor = function urlFor(path, pars, language) {
        var lang = (language || urlLang()).toLowerCase();
        // url language might differ from passed language, so we will always replace using the url language
        var url_lang = language ? urlLang().toLowerCase() : lang;
        var url = window.location.href;
        var new_url = '' + url.substring(0, url.indexOf('/' + url_lang + '/') + url_lang.length + 2) + (normalizePath(path) || 'home' + (lang === 'ja' ? '-jp' : '')) + '.html' + (pars ? '?' + pars : '');
        // replace old lang with new lang
        return urlForLanguage(lang, new_url);
    };

    var urlForStatic = function urlForStatic() {
        var path = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

        if (!static_host || static_host.length === 0) {
            static_host = document.querySelector('script[src*="binary.min.js"],script[src*="binary.js"]');
            if (static_host) {
                static_host = static_host.getAttribute('src');
            }

            if (static_host && static_host.length > 0) {
                static_host = static_host.substr(0, static_host.indexOf('/js/') + 1);
            } else {
                static_host = Url.websiteUrl();
            }
        }

        return static_host + path.replace(/(^\/)/g, '');
    };

    /**
     * @param {Object} new_params - Object with param-value pairs. To delete param, set value to null.
     * @param {boolean} should_preserve_old - Should existing query parameters be preserved.
     */
    var updateParamsWithoutReload = function updateParamsWithoutReload(new_params, should_preserve_old) {
        var updated_params = should_preserve_old ? Object.assign(paramsHash(), new_params) : new_params;
        Object.keys(new_params).forEach(function (key) {
            if (new_params[key] === null) {
                delete updated_params[key];
            }
        });
        var url = new URL(window.location);
        url.search = paramsHashToString(updated_params);
        window.history.replaceState({ url: url.href }, '', url.href);
    };

    var getSection = function getSection() {
        var url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window.location.href;
        return (url.match(new RegExp('/' + urlLang() + '/(.*)/', 'i')) || [])[1];
    };

    var getHashValue = function getHashValue(name) {
        var hash = (location_url || window.location).hash;
        var value = hash.split('=');
        return new RegExp(name).test(hash) && value.length > 1 ? value[1] : '';
    };

    return {
        init: init,
        reset: reset,
        paramsHash: paramsHash,
        getLocation: getLocation,
        paramsHashToString: paramsHashToString,
        urlFor: urlFor,
        urlForStatic: urlForStatic,
        getSection: getSection,
        getHashValue: getHashValue,
        updateParamsWithoutReload: updateParamsWithoutReload,

        param: function param(name) {
            return paramsHash()[name];
        },
        websiteUrl: function websiteUrl() {
            return 'https://www.binary.com/';
        }
    };
}();

module.exports = Url;

/***/ }),
/* 9 */,
/* 10 */,
/* 11 */,
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var defaultRedirectUrl = __webpack_require__(3).defaultRedirectUrl;
var getElementById = __webpack_require__(4).getElementById;
var getLanguage = __webpack_require__(16).get;
var State = __webpack_require__(6).State;
var Url = __webpack_require__(8);
var applyToAllElements = __webpack_require__(1).applyToAllElements;
var createElement = __webpack_require__(1).createElement;
var findParent = __webpack_require__(1).findParent;
__webpack_require__(545);

var BinaryPjax = function () {
    var previous_url = void 0;

    var params = {};
    var cache = {};

    var init = function init(container, content_selector) {
        if (!(window.history && window.history.pushState && window.history.replaceState &&
        // pushState isn't reliable on iOS until 5.
        !navigator.userAgent.match(/((iPod|iPhone|iPad).+\bOS\s+[1-4]\D|WebApps\/.+CFNetwork)/))) {
            return;
        }

        if (!container || !content_selector) {
            return;
        }

        params.container = container;
        params.content_selector = content_selector;

        var url = window.location.href;
        var title = document.title;
        var content = container.querySelector(content_selector);

        // put current content to cache, so we won't need to load it again
        if (content) {
            window.history.replaceState({ url: url }, title, url);
            setDataPage(content, url);
            params.container.dispatchEvent(new CustomEvent('binarypjax:after', { detail: content }));
        }

        applyToAllElements('a', function (el) {
            el.addEventListener('click', handleClick);
        }, '', getElementById('all-accounts'));
        document.addEventListener('click', handleClick);
        window.addEventListener('popstate', handlePopstate);
    };

    var setDataPage = function setDataPage(content, url) {
        content.setAttribute('data-page', url.match(/.+\/(.+)\.html.*/)[1]);
    };

    var handleClick = function handleClick(event) {
        var link = findParent(event.target, 'a');
        if (!link) {
            return;
        }

        var url = link.href;
        if (!url) {
            return;
        }

        // Exclude links having 'no-ajax' class or target="_blank" or not html
        if (link.classList.contains('no-ajax') || link.target === '_blank' || !/\.html/i.test(url)) {
            return;
        }

        // Middle click, cmd click, and ctrl click should open links in a new tab as normal
        if (event.which > 1 || event.metaKey || event.ctrlKey || event.shiftKey || event.altKey) {
            return;
        }

        // Ignore cross origin links
        if (location.protocol !== link.protocol || location.hostname !== link.hostname) {
            return;
        }

        // Ignore event with default prevented
        if (event.defaultPrevented) {
            return;
        }

        // browse a page in another section // TODO: uncomment when split the release process
        // if (Url.getSection() !== Url.getSection(url)) {
        //     return;
        // }

        event.preventDefault();
        // check if url is not same as current
        if (location.href !== url) {
            processUrl(url);
        }
    };

    var processUrl = function processUrl(url, replace) {
        State.set('is_loaded_by_pjax', true);

        var complete_url = /^http/i.test(url) ? url : Url.urlFor(url);

        var cached_content = cacheGet(complete_url);
        if (cached_content) {
            replaceContent(complete_url, cached_content, replace);
        } else {
            load(complete_url, replace);
        }
    };

    /**
     * Load url from server
     */
    var load = function load(url, replace) {
        var lang = getLanguage();
        var xhttp = new XMLHttpRequest();

        xhttp.onreadystatechange = function () {
            if (this.readyState !== 4 || this.status !== 200) {
                return;
            }
            var div = createElement('div', { html: this.responseText });
            var result = { content: div.querySelector(params.content_selector) };

            var title = div.getElementsByTagName('title')[0];
            if (title) {
                result.title = title.textContent.trim();
            }

            // If failed to find title or content, load the page in traditional way
            if (!result.title || !result.content) {
                locationReplace(url);
                return;
            }

            setDataPage(result.content, url);
            cachePut(url, result);
            replaceContent(url, result, replace);
        };

        xhttp.open('GET', url.replace(new RegExp('/' + lang + '/', 'i'), '/' + lang.toLowerCase() + '/pjax/'), true);
        xhttp.send();
    };

    var handlePopstate = function handlePopstate(e) {
        var url = e.state && e.state.url ? e.state.url // eslint-disable-line no-nested-ternary
        : window.location.href;
        if (url) {
            processUrl(url, true);
        } else {
            window.history.replaceState({}, document.title, window.location.pathname);
        }
        return false;
    };

    var replaceContent = function replaceContent(url, content, replace) {
        previous_url = window.location.href;
        window.history[replace ? 'replaceState' : 'pushState']({ url: url }, content.title, url);

        params.container.dispatchEvent(new Event('binarypjax:before'));

        document.title = content.title;
        var content_selector = params.container.querySelector(params.content_selector);
        if (content_selector) {
            content_selector.remove();
        }
        $(params.container).append($(content.content).clone());

        params.container.dispatchEvent(new CustomEvent('binarypjax:after', { detail: content.content }));

        var query_params = Url.paramsHash();
        if (!query_params.anchor) {
            $.scrollTo('body', 500);
        }
    };

    var cachePut = function cachePut(url, content) {
        cache[cleanUrl(url)] = content;
    };

    var cacheGet = function cacheGet(url) {
        return cache[cleanUrl(url)];
    };

    var cleanUrl = function cleanUrl(url) {
        return url.replace(/(\?|#).*$/, '');
    };

    var locationReplace = function locationReplace(url) {
        window.history.replaceState(null, '', url);
        window.location.replace(url);
    };

    var loadPreviousUrl = function loadPreviousUrl() {
        if (window.location.href === previous_url) {
            previous_url = '';
        }
        processUrl(previous_url || defaultRedirectUrl());
    };

    return {
        init: init,
        loadPreviousUrl: loadPreviousUrl,

        load: processUrl,
        getPreviousUrl: function getPreviousUrl() {
            return previous_url;
        }
    };
}();

module.exports = BinaryPjax;

/***/ }),
/* 13 */,
/* 14 */,
/* 15 */,
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Cookies = __webpack_require__(50);
var elementTextContent = __webpack_require__(4).elementTextContent;
var getElementById = __webpack_require__(4).getElementById;
var CookieStorage = __webpack_require__(6).CookieStorage;
var LocalStore = __webpack_require__(6).LocalStore;
var applyToAllElements = __webpack_require__(1).applyToAllElements;

var Language = function () {
    var all_languages = {
        ACH: 'Translations',
        EN: 'English',
        DE: 'Deutsch',
        ES: 'Español',
        FR: 'Français',
        ID: 'Indonesia',
        IT: 'Italiano',
        JA: '日本語',
        PL: 'Polish',
        PT: 'Português',
        RU: 'Русский',
        TH: 'Thai',
        VI: 'Tiếng Việt',
        ZH_CN: '简体中文',
        ZH_TW: '繁體中文'
    };
    var default_language = 'EN';

    var setCookieLanguage = function setCookieLanguage(lang) {
        if (!Cookies.get('language') || lang) {
            var cookie = new CookieStorage('language');
            cookie.write((lang || getLanguage()).toUpperCase());
        }
    };

    var url_lang = null;

    var lang_regex = new RegExp('^(' + Object.keys(all_languages).join('|') + ')$', 'i');

    var languageFromUrl = function languageFromUrl(custom_url) {
        if (url_lang && !custom_url) return url_lang;
        var url_params = (custom_url || window.location.href).split('/').slice(3);
        var language = url_params.find(function (lang) {
            return lang_regex.test(lang);
        }) || '';
        if (!custom_url) {
            url_lang = language;
        }
        return language;
    };

    var current_lang = null;

    var getLanguage = function getLanguage() {
        if (/ach/i.test(current_lang) || /ach/i.test(languageFromUrl())) {
            var crowdin_lang = Cookies.get('jipt_language_code_binary-static'); // selected language for in-context translation
            if (crowdin_lang) {
                current_lang = crowdin_lang.toUpperCase().replace('-', '_').toUpperCase();
                if (document.body) {
                    document.body.classList.add(current_lang); // set the body class removed by crowdin code
                }
            }
        }
        current_lang = current_lang || (languageFromUrl() || Cookies.get('language') || default_language).toUpperCase();
        return current_lang;
    };

    var urlForLanguage = function urlForLanguage(lang) {
        var url = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window.location.href;
        return url.replace(new RegExp('/' + getLanguage() + '/', 'i'), '/' + (lang || default_language).trim().toLowerCase() + '/');
    };

    var onChangeLanguage = function onChangeLanguage() {
        applyToAllElements('li', function (el) {
            el.addEventListener('click', function (e) {
                if (e.target.nodeName !== 'LI') return;
                var lang = e.target.getAttribute('class');
                if (getLanguage() === lang) return;
                elementTextContent(getElementById('display_language').getElementsByClassName('language'), e.target.textContent);
                LocalStore.remove('ws_cache');
                setCookieLanguage(lang);
                document.location = urlForLanguage(lang);
            });
        }, '', getElementById('select_language'));
    };

    return {
        getAll: function getAll() {
            return all_languages;
        },
        setCookie: setCookieLanguage,
        get: getLanguage,
        onChange: onChangeLanguage,
        urlFor: urlForLanguage,
        urlLang: languageFromUrl,
        reset: function reset() {
            url_lang = null;current_lang = null;
        }
    };
}();

module.exports = Language;

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var moment = __webpack_require__(9);
var checkInput = __webpack_require__(4).checkInput;

var toTitleCase = function toTitleCase(str) {
    return (str || '').replace(/\w[^\s/\\]*/g, function (txt) {
        return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
    });
};

var toISOFormat = function toISOFormat(date) {
    return date instanceof moment ? date.format('YYYY-MM-DD') : '';
};

var toReadableFormat = function toReadableFormat(date) {
    if (date instanceof moment) {
        if (window.innerWidth < 770 && checkInput('date', 'not-a-date')) {
            return toISOFormat(date);
        }
        return date.format('DD MMM, YYYY');
    }
    return '';
};

var padLeft = function padLeft(txt, len, char) {
    var text = String(txt || '');
    return text.length >= len ? text : '' + Array(len - text.length + 1).join(char) + text;
};

var compareBigUnsignedInt = function compareBigUnsignedInt(a, b) {
    var first_num = numberToString(a);
    var second_num = numberToString(b);
    if (!first_num || !second_num) {
        return '';
    }
    var max_length = Math.max(first_num.length, second_num.length);
    first_num = padLeft(first_num, max_length, '0');
    second_num = padLeft(second_num, max_length, '0');

    // lexicographical comparison
    var order = 0;
    if (first_num !== second_num) {
        order = first_num > second_num ? 1 : -1;
    }

    return order;
};

var numberToString = function numberToString(n) {
    return typeof n === 'number' ? String(n) : n;
};

module.exports = {
    toISOFormat: toISOFormat,
    toReadableFormat: toReadableFormat,
    toTitleCase: toTitleCase,
    padLeft: padLeft,
    numberToString: numberToString,

    compareBigUnsignedInt: compareBigUnsignedInt
};

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Validation = __webpack_require__(56);
var BinarySocket = __webpack_require__(5);
var getHashValue = __webpack_require__(8).getHashValue;
var isEmptyObject = __webpack_require__(1).isEmptyObject;
var showLoadingImage = __webpack_require__(1).showLoadingImage;

var FormManager = function () {
    var forms = {};

    var initForm = function initForm(form_selector, fields, needs_token) {
        var $form = $(form_selector + ':visible');
        var $btn = $form.find('button[type="submit"]');
        if ($form.length) {
            forms[form_selector] = {
                $btn_submit: $btn,
                can_submit: true
            };
            if (Array.isArray(fields) && fields.length) {
                if (needs_token) {
                    // eslint-disable-next-line no-param-reassign
                    fields = fields.concat({ request_field: 'verification_code', value: getHashValue('token') });
                }
                forms[form_selector].fields = fields;

                fields.forEach(function (field) {
                    if (field.selector) {
                        field.$ = $form.find(field.selector);
                        if (!field.$.length) return;
                    }

                    field.form = form_selector;
                });
            }
        }
        // handle firefox
        $btn.removeAttr('disabled');
        Validation.init(form_selector, fields, needs_token);
    };

    var getFormData = function getFormData(form_selector) {
        var data = {};
        var fields = forms[form_selector].fields;
        if (!fields) return data;
        var key = void 0,
            val = void 0,
            value = void 0;

        fields.forEach(function (field) {
            if (!field.exclude_request) {
                if (field.$.is(':visible') || field.value) {
                    val = field.$.val();
                    key = field.request_field || field.selector;

                    value = val || '';
                    if (field.value) {
                        value = typeof field.value === 'function' ? field.value() : field.value;
                    } else if (field.$.attr('data-value')) {
                        value = field.$.attr('data-value');
                    } else if (/lbl_/.test(key)) {
                        value = field.value || field.$.text();
                    } else if (field.$.is(':checkbox')) {
                        value = field.$.is(':checked') ? 1 : 0;
                    } else if (Array.isArray(val)) {
                        value = val.join(',');
                    }

                    if (field.$.attr('type') !== 'password' && typeof value === 'string') {
                        value = value.trim();
                    }

                    if (!(field.exclude_if_empty && val.length === 0)) {
                        key = key.replace(/lbl_|#|\./g, '');
                        if (field.parent_node) {
                            if (!data[field.parent_node]) {
                                data[field.parent_node] = {};
                            }
                            data[field.parent_node][key] = value;
                        } else {
                            data[key] = value;
                        }
                    }
                }
            }
        });
        return data;
    };

    var disableButton = function disableButton($btn) {
        if ($btn.length && !$btn.find('.barspinner').length) {
            $btn.attr('disabled', 'disabled');
            var $btn_text = $('<span/>', { text: $btn.text(), class: 'invisible' });
            showLoadingImage($btn[0], 'white');
            $btn.append($btn_text);
        }
    };

    var enableButton = function enableButton($btn) {
        if ($btn.length && $btn.find('.barspinner').length) {
            $btn.removeAttr('disabled').html($btn.find('span').text());
        }
    };

    var handleSubmit = function handleSubmit(options) {
        var form = void 0,
            $btn_submit = void 0,
            can_submit = void 0;

        var submit = function submit(req) {
            disableButton($btn_submit);
            form.can_submit = false;
            if (isEmptyObject(req)) {
                onSuccess();
            } else {
                BinarySocket.send(req).then(function (response) {
                    onSuccess(response);
                });
            }
        };

        var onSuccess = function onSuccess() {
            var response = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            if (typeof options.fnc_response_handler === 'function') {
                if (options.enable_button || 'error' in response) {
                    enableButton($btn_submit);
                    form.can_submit = true;
                }
                options.fnc_response_handler(response);
            }
        };

        $(options.form_selector).off('submit').on('submit', function (evt) {
            evt.preventDefault();
            form = forms[options.form_selector];
            $btn_submit = form.$btn_submit;
            can_submit = form.can_submit;
            if (!can_submit) return;
            if (Validation.validate(options.form_selector)) {
                var req = $.extend({}, options.obj_request, getFormData(options.form_selector));
                if (typeof options.fnc_additional_check === 'function') {
                    Promise.resolve(options.fnc_additional_check(req)).then(function (result) {
                        if (result) submit(req);
                    });
                } else {
                    submit(req);
                }
            }
        });
    };

    return {
        handleSubmit: handleSubmit,
        init: initForm
    };
}();

module.exports = FormManager;

/***/ }),
/* 19 */,
/* 20 */,
/* 21 */,
/* 22 */,
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var getElementById = __webpack_require__(4).getElementById;
var isVisible = __webpack_require__(4).isVisible;
var State = __webpack_require__(6).State;
var Url = __webpack_require__(8);
var isEmptyObject = __webpack_require__(1).isEmptyObject;

/*
 * Handles trading page default values
 *
 * Priorities:
 * 1. Client's input: on each change to form, it will reflect to both query string & session storage
 * 2. Query string parameters: will change session storage values
 * 3. Session storage values: if none of the above, it will be the source
 *
 */

var Defaults = function () {
    var params = {};
    var getDefault = function getDefault(key) {
        var p_value = params[key] || Url.param(key);
        var s_value = sessionStorage.getItem(key);
        if (p_value && (!s_value || p_value !== s_value)) {
            sessionStorage.setItem(key, p_value);
        }
        if (!p_value && s_value) {
            setDefault(key, s_value);
        }
        return p_value || s_value;
    };

    var setDefault = function setDefault(key) {
        var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

        if (!key) return;
        if (isEmptyObject(params)) params = Url.paramsHash();
        if (params[key] !== value) {
            params[key] = value;
            // to increase speed, do not set values when form is still loading
            if (!isVisible(getElementById('trading_init_progress'))) {
                sessionStorage.setItem(key, value);
                updateURL();
            }
        }
    };

    var removeDefault = function removeDefault() {
        for (var _len = arguments.length, keys = Array(_len), _key = 0; _key < _len; _key++) {
            keys[_key] = arguments[_key];
        }

        if (isEmptyObject(params)) params = Url.paramsHash();
        var is_updated = false;
        keys.forEach(function (key) {
            if (key in params) {
                sessionStorage.removeItem(key);
                delete params[key];
                is_updated = true;
            }
        });
        if (is_updated) {
            updateURL();
        }
    };

    var updateAll = function updateAll() {
        Object.keys(params).forEach(function (key) {
            sessionStorage.setItem(key, params[key]);
        });
        updateURL();
    };

    var updateURL = function updateURL() {
        if (!State.get('is_trading')) return;
        Url.updateParamsWithoutReload(params, false);
    };

    return {
        get: getDefault,
        set: setDefault,
        update: updateAll,
        remove: removeDefault,
        clear: function clear() {
            params = {};
        }
    };
}();

module.exports = Defaults;

/***/ }),
/* 24 */,
/* 25 */,
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var moment = __webpack_require__(9);
var isJPClient = __webpack_require__(3).isJPClient;
var ServerTime = __webpack_require__(242);
var elementInnerHtml = __webpack_require__(4).elementInnerHtml;
var getElementById = __webpack_require__(4).getElementById;

var Clock = function () {
    var el_clock = void 0,
        fncExternalTimer = void 0;

    var startClock = function startClock() {
        if (!el_clock) {
            el_clock = getElementById('gmt-clock');
        }

        ServerTime.init(onTimeUpdated);
    };

    var onTimeUpdated = function onTimeUpdated() {
        var server_time = ServerTime.get();
        window.time = server_time;

        var time_str = server_time.format('YYYY-MM-DD HH:mm:ss') + ' GMT';
        if (isJPClient()) {
            elementInnerHtml(el_clock, toJapanTimeIfNeeded(time_str, 1, 1));
        } else {
            elementInnerHtml(el_clock, time_str);
            showLocalTimeOnHover('#gmt-clock');
        }

        if (typeof fncExternalTimer === 'function') {
            fncExternalTimer();
        }
    };

    var showLocalTimeOnHover = function showLocalTimeOnHover(selector) {
        if (isJPClient()) return;
        document.querySelectorAll(selector || '.date').forEach(function (el) {
            var gmt_time_str = el.textContent.replace('\n', ' ');
            var local_time = moment.utc(gmt_time_str, 'YYYY-MM-DD HH:mm:ss').local();
            if (local_time.isValid()) {
                el.setAttribute('data-balloon', local_time.format('YYYY-MM-DD HH:mm:ss Z'));
            }
        });
    };

    var toJapanTimeIfNeeded = function toJapanTimeIfNeeded(gmt_time_str, show_time_zone, hide_seconds) {
        var time = void 0;

        if (typeof gmt_time_str === 'number') {
            time = moment.utc(gmt_time_str * 1000);
        } else if (gmt_time_str) {
            time = moment.utc(gmt_time_str, 'YYYY-MM-DD HH:mm:ss');
        }

        if (!time || !time.isValid()) {
            return null;
        }

        var offset = '+00:00';
        var time_zone = 'Z';
        if (isJPClient()) {
            offset = '+09:00';
            time_zone = 'zZ';
        }

        return time.utcOffset(offset).format('YYYY-MM-DD HH:mm' + (hide_seconds ? '' : ':ss') + (show_time_zone ? ' ' + time_zone : ''));
    };

    return {
        startClock: startClock,
        showLocalTimeOnHover: showLocalTimeOnHover,
        toJapanTimeIfNeeded: toJapanTimeIfNeeded,

        setExternalTimer: function setExternalTimer(func) {
            fncExternalTimer = func;
        }
    };
}();

module.exports = Clock;

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var BinaryPjax = __webpack_require__(12);
var Client = __webpack_require__(3);
var BinarySocket = __webpack_require__(5);
var showHidePulser = __webpack_require__(96).showHidePulser;
var checkClientsCountry = __webpack_require__(168).checkClientsCountry;
var MetaTrader = __webpack_require__(129);
var GTM = __webpack_require__(54);
var Login = __webpack_require__(55);
var SocketCache = __webpack_require__(74);
var elementInnerHtml = __webpack_require__(4).elementInnerHtml;
var elementTextContent = __webpack_require__(4).elementTextContent;
var getElementById = __webpack_require__(4).getElementById;
var localize = __webpack_require__(2).localize;
var State = __webpack_require__(6).State;
var toTitleCase = __webpack_require__(17).toTitleCase;
var Url = __webpack_require__(8);
var applyToAllElements = __webpack_require__(1).applyToAllElements;
var createElement = __webpack_require__(1).createElement;
var findParent = __webpack_require__(1).findParent;

var Header = function () {
    var onLoad = function onLoad() {
        populateAccountsList();
        bindClick();
        if (!Login.isLoginPages()) {
            checkClientsCountry();
        }
        if (Client.isLoggedIn()) {
            displayAccountStatus();
            if (!Client.get('is_virtual')) {
                BinarySocket.wait('website_status', 'authorize', 'balance').then(function () {
                    if (Client.canTransferFunds()) {
                        getElementById('user_menu_account_transfer').setVisibility(1);
                    }
                });
            }
        }
    };

    var bindClick = function bindClick() {
        var logo = getElementById('logo');
        logo.removeEventListener('click', logoOnClick);
        logo.addEventListener('click', logoOnClick);

        var btn_login = getElementById('btn_login');
        btn_login.removeEventListener('click', loginOnClick);
        btn_login.addEventListener('click', loginOnClick);

        applyToAllElements('a.logout', function (el) {
            el.removeEventListener('click', logoutOnClick);
            el.addEventListener('click', logoutOnClick);
        });
    };

    var logoOnClick = function logoOnClick() {
        var url = Client.isLoggedIn() ? Client.defaultRedirectUrl() : Url.urlFor('');
        BinaryPjax.load(url);
    };

    var loginOnClick = function loginOnClick(e) {
        e.preventDefault();
        Login.redirectToLogin();
    };

    var logoutOnClick = function logoutOnClick() {
        Client.sendLogoutRequest();
    };

    var populateAccountsList = function populateAccountsList() {
        if (!Client.isLoggedIn()) return;
        BinarySocket.wait('authorize').then(function () {
            var loginid_select = document.createElement('div');
            Client.getAllLoginids().forEach(function (loginid) {
                if (!Client.get('is_disabled', loginid) && Client.get('token', loginid)) {
                    var account_title = Client.getAccountTitle(loginid);
                    var is_real = /real/i.test(account_title);
                    var currency = Client.get('currency', loginid);
                    var localized_type = localize('[_1] Account', [is_real && currency ? currency : account_title]);
                    if (loginid === Client.get('loginid')) {
                        // default account
                        applyToAllElements('.account-type', function (el) {
                            elementInnerHtml(el, localized_type);
                        });
                        applyToAllElements('.account-id', function (el) {
                            elementInnerHtml(el, loginid);
                        });
                    } else {
                        var link = createElement('a', { href: 'javascript:;', 'data-value': loginid });
                        var li_type = createElement('li', { text: localized_type });

                        li_type.appendChild(createElement('div', { text: loginid }));
                        link.appendChild(li_type);
                        loginid_select.appendChild(link).appendChild(createElement('div', { class: 'separator-line-thin-gray' }));
                    }
                }
                applyToAllElements('.login-id-list', function (el) {
                    el.html(loginid_select.innerHTML);
                    applyToAllElements('a', function (ele) {
                        ele.removeEventListener('click', loginIDOnClick);
                        ele.addEventListener('click', loginIDOnClick);
                    }, '', el);
                });
            });
        });
    };

    var loginIDOnClick = function loginIDOnClick(e) {
        e.preventDefault();
        var el_loginid = findParent(e.target, 'a');
        if (el_loginid) {
            el_loginid.setAttribute('disabled', 'disabled');
            switchLoginid(el_loginid.getAttribute('data-value'));
        }
    };

    var metatraderMenuItemVisibility = function metatraderMenuItemVisibility() {
        BinarySocket.wait('landing_company', 'get_account_status').then(function () {
            if (MetaTrader.isEligible() && !Client.isJPClient()) {
                var mt_visibility = document.getElementsByClassName('mt_visibility');
                applyToAllElements(mt_visibility, function (el) {
                    el.setVisibility(1);
                });
            }
        });
    };

    var switchLoginid = function switchLoginid(loginid) {
        if (!loginid || loginid.length === 0) return;
        var token = Client.get('token', loginid);
        if (!token || token.length === 0) {
            Client.sendLogoutRequest(true);
            return;
        }

        sessionStorage.setItem('active_tab', '1');
        // set local storage
        GTM.setLoginFlag();
        Client.set('cashier_confirmed', 0);
        Client.set('accepted_bch', 0);
        Client.set('loginid', loginid);
        SocketCache.clear();
        window.location.reload();
    };

    var upgradeMessageVisibility = function upgradeMessageVisibility() {
        BinarySocket.wait('authorize', 'landing_company', 'get_settings', 'get_account_status').then(function () {
            var upgrade_msg = document.getElementsByClassName('upgrademessage');

            if (!upgrade_msg) {
                return;
            }

            var showUpgrade = function showUpgrade(url, msg) {
                applyToAllElements(upgrade_msg, function (el) {
                    el.setVisibility(1);
                    applyToAllElements('a', function (ele) {
                        ele.html(createElement('span', { text: localize(msg) })).setVisibility(1).setAttribute('href', Url.urlFor(url));
                    }, '', el);
                });
            };

            var showUpgradeBtn = function showUpgradeBtn(url, msg) {
                applyToAllElements(upgrade_msg, function (el) {
                    el.setVisibility(1);
                    applyToAllElements('a.button', function (ele) {
                        ele.html(createElement('span', { text: localize(msg) })).setVisibility(1).setAttribute('href', Url.urlFor(url));
                    }, '', el);
                });
            };

            var jp_account_status = State.getResponse('get_settings.jp_account_status.status');
            var upgrade_info = Client.getUpgradeInfo();
            var show_upgrade_msg = upgrade_info.can_upgrade;
            var virtual_text = getElementById('virtual-text');

            if (Client.get('is_virtual')) {
                applyToAllElements(upgrade_msg, function (el) {
                    el.setVisibility(1);
                    var span = el.getElementsByTagName('span')[0];
                    if (span) {
                        span.setVisibility(1);
                    }
                    applyToAllElements('a', function (ele) {
                        ele.setVisibility(0);
                    }, '', el);
                });

                if (jp_account_status) {
                    var has_disabled_jp = Client.isJPClient() && Client.getAccountOfType('real').is_disabled;
                    if (/jp_knowledge_test_(pending|fail)/.test(jp_account_status)) {
                        // do not returns the correct timeshow upgrade for user that filled up form
                        showUpgrade('/new_account/knowledge_testws', '{JAPAN ONLY}Take knowledge test');
                    } else if (show_upgrade_msg || has_disabled_jp && jp_account_status !== 'disabled') {
                        applyToAllElements(upgrade_msg, function (el) {
                            el.setVisibility(1);
                        });
                        if (jp_account_status === 'jp_activation_pending' && !document.getElementsByClassName('activation-message')) {
                            virtual_text.appendChild(createElement('div', { class: 'activation-message', text: ' ' + localize('{JAPAN ONLY}Your Application is Being Processed.') }));
                        } else if (jp_account_status === 'activated' && !document.getElementsByClassName('activated-message')) {
                            virtual_text.appendChild(createElement('div', { class: 'activated-message', text: ' ' + localize('{JAPAN ONLY}Your Application has Been Processed. Please Re-Login to Access Your Real-Money Account.') }));
                        }
                    }
                } else if (show_upgrade_msg) {
                    showUpgrade(upgrade_info.upgrade_link, 'Click here to open a ' + toTitleCase(upgrade_info.type) + ' Account');
                    showUpgradeBtn(upgrade_info.upgrade_link, 'Open a ' + toTitleCase(upgrade_info.type) + ' Account');
                } else {
                    applyToAllElements(upgrade_msg, function (el) {
                        applyToAllElements('a', function (ele) {
                            ele.setVisibility(0).innerHTML = '';
                        }, '', el);
                    });
                }
            } else if (show_upgrade_msg) {
                getElementById('virtual-wrapper').setVisibility(0);
                showUpgrade(upgrade_info.upgrade_link, 'Click here to open a ' + toTitleCase(upgrade_info.type) + ' Account');
                showUpgradeBtn(upgrade_info.upgrade_link, 'Open a ' + toTitleCase(upgrade_info.type) + ' Account');

                if (/new_account/.test(window.location.href)) {
                    showHidePulser(0);
                }
            } else {
                applyToAllElements(upgrade_msg, function (el) {
                    el.setVisibility(0);
                });
            }
            showHideNewAccount(upgrade_info);
        });
    };

    var showHideNewAccount = function showHideNewAccount(upgrade_info) {
        if (upgrade_info.can_upgrade || upgrade_info.can_open_multi) {
            changeAccountsText(1, 'Create Account');
        } else {
            changeAccountsText(0, 'Accounts List');
        }
    };

    var changeAccountsText = function changeAccountsText(add_new_style, text) {
        var user_accounts = getElementById('user_accounts');
        user_accounts.classList[add_new_style ? 'add' : 'remove']('create_new_account');
        var localized_text = localize(text);
        applyToAllElements('li', function (el) {
            elementTextContent(el, localized_text);
        }, '', user_accounts);
    };

    var displayNotification = function displayNotification(message) {
        var is_error = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var msg_code = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';

        var msg_notification = getElementById('msg_notification');
        if (msg_notification.getAttribute('data-code') === 'STORAGE_NOT_SUPPORTED') return;

        msg_notification.html(message);
        msg_notification.setAttribute('data-message', message);
        msg_notification.setAttribute('data-code', msg_code);

        if (msg_notification.offsetParent) {
            msg_notification.toggleClass('error', is_error);
        } else {
            $(msg_notification).slideDown(500, function () {
                if (is_error) msg_notification.classList.add('error');
            });
        }
    };

    var hideNotification = function hideNotification(msg_code) {
        var msg_notification = getElementById('msg_notification');
        if (msg_notification.getAttribute('data-code') === 'STORAGE_NOT_SUPPORTED' || msg_code && msg_notification.getAttribute('data-code') !== msg_code) {
            return;
        }

        if (msg_notification.offsetParent) {
            msg_notification.classList.remove('error');
            $(msg_notification).slideUp(500, function () {
                elementInnerHtml(msg_notification, '');
                msg_notification.removeAttribute('data-message data-code');
            });
        }
    };

    var displayAccountStatus = function displayAccountStatus() {
        BinarySocket.wait('authorize').then(function () {
            var get_account_status = void 0,
                status = void 0;

            var riskAssessment = function riskAssessment() {
                return Client.getRiskAssessment() && !Client.isJPClient();
            };

            var hasMissingRequiredField = function hasMissingRequiredField() {
                var required_fields = ['account_opening_reason', 'address_line_1', 'address_city', 'phone', 'tax_identification_number', 'tax_residence'].concat(_toConsumableArray(Client.get('residence') === 'gb' ? ['address_postcode'] : []));
                var get_settings = State.getResponse('get_settings');
                return required_fields.some(function (field) {
                    return !get_settings[field];
                });
            };

            var buildMessage = function buildMessage(string, path) {
                var hash = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
                return localize(string, ['<a href="' + Url.urlFor(path) + hash + '">', '</a>']);
            };

            var messages = {
                authenticate: function authenticate() {
                    return buildMessage('[_1]Authenticate your account[_2] now to take full advantage of all payment methods available.', 'user/authenticate');
                },
                cashier_locked: function cashier_locked() {
                    return localize('Deposits and withdrawals have been disabled on your account. Please check your email for more details.');
                },
                currency: function currency() {
                    return buildMessage('Please set the [_1]currency[_2] of your account.', 'user/set-currency');
                },
                document_needs_action: function document_needs_action() {
                    return buildMessage('[_1]Your Proof of Identity or Proof of Address[_2] did not meet our requirements. Please check your email for further instructions.', 'user/authenticate');
                },
                document_review: function document_review() {
                    return buildMessage('We are reviewing your documents. For more details [_1]contact us[_2].', 'contact');
                },
                excluded_until: function excluded_until() {
                    return buildMessage('Your account is restricted. Kindly [_1]contact customer support[_2] for assistance.', 'contact');
                },
                financial_limit: function financial_limit() {
                    return buildMessage('Please set your [_1]30-day turnover limit[_2] to remove deposit limits.', 'user/security/self_exclusionws');
                },
                required_fields: function required_fields() {
                    return buildMessage('Please complete your [_1]personal details[_2] before you proceed.', 'user/settings/detailsws');
                },
                residence: function residence() {
                    return buildMessage('Please set [_1]country of residence[_2] before upgrading to a real-money account.', 'user/settings/detailsws');
                },
                risk: function risk() {
                    return buildMessage('Please complete the [_1]financial assessment form[_2] to lift your withdrawal and trading limits.', 'user/settings/assessmentws');
                },
                tax: function tax() {
                    return buildMessage('Please [_1]complete your account profile[_2] to lift your withdrawal and trading limits.', 'user/settings/detailsws');
                },
                tnc: function tnc() {
                    return buildMessage('Please [_1]accept the updated Terms and Conditions[_2] to lift your withdrawal and trading limits.', 'user/tnc_approvalws');
                },
                unwelcome: function unwelcome() {
                    return buildMessage('Trading and deposits have been disabled on your account. Kindly [_1]contact customer support[_2] for assistance.', 'contact');
                },
                withdrawal_locked: function withdrawal_locked() {
                    return localize('Withdrawals have been disabled on your account. Please check your email for more details.');
                }
            };

            var validations = {
                authenticate: function authenticate() {
                    return +get_account_status.prompt_client_to_authenticate;
                },
                cashier_locked: function cashier_locked() {
                    return (/cashier_locked/.test(status)
                    );
                },
                currency: function currency() {
                    return !Client.get('currency');
                },
                document_needs_action: function document_needs_action() {
                    return (/document_needs_action/.test(status)
                    );
                },
                document_review: function document_review() {
                    return (/document_under_review/.test(status)
                    );
                },
                excluded_until: function excluded_until() {
                    return Client.get('excluded_until');
                },
                financial_limit: function financial_limit() {
                    return (/ukrts_max_turnover_limit_not_set/.test(status)
                    );
                },
                required_fields: function required_fields() {
                    return Client.isAccountOfType('financial') && hasMissingRequiredField();
                },
                residence: function residence() {
                    return !Client.get('residence');
                },
                risk: function risk() {
                    return riskAssessment();
                },
                tax: function tax() {
                    return Client.shouldCompleteTax();
                },
                tnc: function tnc() {
                    return Client.shouldAcceptTnc();
                },
                unwelcome: function unwelcome() {
                    return (/unwelcome/.test(status)
                    );
                },
                withdrawal_locked: function withdrawal_locked() {
                    return (/withdrawal_locked/.test(status)
                    );
                }
            };

            // real account checks in order
            var check_statuses_real = ['excluded_until', 'tnc', 'required_fields', 'financial_limit', 'risk', 'tax', 'currency', 'document_review', 'document_needs_action', 'authenticate', 'cashier_locked', 'withdrawal_locked', 'unwelcome'];

            // virtual checks
            var check_statuses_virtual = ['residence'];

            var checkStatus = function checkStatus(check_statuses) {
                var notified = check_statuses.some(function (check_type) {
                    if (validations[check_type]()) {
                        displayNotification(messages[check_type]());
                        return true;
                    }
                    return false;
                });
                if (!notified) hideNotification();
            };

            if (Client.get('is_virtual')) {
                checkStatus(check_statuses_virtual);
            } else {
                BinarySocket.wait('website_status', 'get_account_status', 'get_settings', 'balance').then(function () {
                    get_account_status = State.getResponse('get_account_status') || {};
                    status = get_account_status.status;
                    checkStatus(check_statuses_real);
                });
            }
        });
    };

    return {
        onLoad: onLoad,
        populateAccountsList: populateAccountsList,
        upgradeMessageVisibility: upgradeMessageVisibility,
        metatraderMenuItemVisibility: metatraderMenuItemVisibility,
        displayNotification: displayNotification,
        hideNotification: hideNotification,
        displayAccountStatus: displayAccountStatus
    };
}();

module.exports = Header;

/***/ }),
/* 28 */,
/* 29 */,
/* 30 */,
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var Defaults = __webpack_require__(23);
var Symbols = __webpack_require__(79);
var Tick = __webpack_require__(60);
var contractsElement = __webpack_require__(285);
var marketsElement = __webpack_require__(288);
var formatMoney = __webpack_require__(7).formatMoney;
var ActiveSymbols = __webpack_require__(119);
var elementInnerHtml = __webpack_require__(4).elementInnerHtml;
var getElementById = __webpack_require__(4).getElementById;
var localize = __webpack_require__(2).localize;
var urlFor = __webpack_require__(8).urlFor;
var cloneObject = __webpack_require__(1).cloneObject;

/*
 * This contains common functions we need for processing the response
 */

var commonTrading = function () {
    /*
     * display contract form as element of ul
     */
    var contracts_element = null;
    var displayContractForms = function displayContractForms(id, elements, selected) {
        if (!id || !elements || !selected) return;

        var all_contracts = cloneObject(elements);
        delete all_contracts.callputequal; // don't include callputequal in contract drop-down

        var contracts_tree = getContractCategoryTree(all_contracts);
        var contract_to_show = /^(callputequal)$/.test(selected) ? 'risefall' : selected;

        if (!contracts_element) {
            contracts_element = contractsElement.init(all_contracts, contracts_tree, contract_to_show);
        } else {
            // Update the component.
            contracts_element.updater.enqueueSetState(contracts_element, {
                contracts_tree: contracts_tree,
                contracts: all_contracts,
                formname: contract_to_show || Defaults.get('formname')
            });
        }
    };

    var displayMarkets = function displayMarkets() {
        marketsElement.init();
    };

    /*
     * This maps the form name and barrierCategory we display on
     * trading form to the actual we send it to backend
     * for e.g risefall is mapped to callput with barrierCategory euro_atm
     */
    var getFormNameBarrierCategory = function getFormNameBarrierCategory() {
        var form_name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

        var name = form_name;
        var barrier = '';
        if (/higherlower/.test(form_name)) {
            name = 'callput';
            barrier = 'euro_non_atm';
        } else if (/callputspread/.test(form_name)) {
            name = 'callputspread';
        } else if (/callputequal/.test(form_name)) {
            barrier = 'euro_atm';
        } else if (/risefall|callput/.test(form_name)) {
            name = 'callput';
            barrier = 'euro_atm';
        } else if (/overunder|evenodd|matchdiff/.test(form_name)) {
            name = 'digits';
        } else if (/lookback/.test(form_name)) {
            name = 'lookback';
        } else if (/reset/.test(form_name)) {
            name = 'reset';
        }
        return {
            form_name: name,
            barrier_category: barrier
        };
    };

    /*
     * This maps the contract type to where we display on trading form
     * and as there is no mapping on server side so need to create it
     * on front end
     *
     * for example we display CALL on top and PUT to bottom
     */
    var obj = {
        CALL: 'top',
        PUT: 'bottom',
        CALLE: 'top',
        PUTE: 'bottom',
        ASIANU: 'top',
        ASIAND: 'bottom',
        DIGITMATCH: 'top',
        DIGITDIFF: 'bottom',
        DIGITEVEN: 'top',
        DIGITODD: 'bottom',
        DIGITOVER: 'top',
        DIGITUNDER: 'bottom',
        EXPIRYRANGEE: 'top',
        EXPIRYMISSE: 'bottom',
        EXPIRYRANGE: 'top',
        EXPIRYMISS: 'bottom',
        RANGE: 'top',
        UPORDOWN: 'bottom',
        ONETOUCH: 'top',
        NOTOUCH: 'bottom',
        LBFLOATCALL: 'middle',
        LBFLOATPUT: 'middle',
        LBHIGHLOW: 'middle',
        RESETCALL: 'top',
        RESETPUT: 'bottom',
        CALLSPREAD: 'top',
        PUTSPREAD: 'bottom',
        TICKHIGH: 'top',
        TICKLOW: 'bottom'
    };

    var contractTypeDisplayMapping = function contractTypeDisplayMapping(type) {
        return type ? obj[type] : 'top';
    };

    var showHideOverlay = function showHideOverlay(el, display) {
        getElementById(el).style.display = display;
    };

    /*
     * hide contract confirmation overlay container
     */
    var hideOverlayContainer = function hideOverlayContainer() {
        showHideOverlay('contract_confirmation_container', 'none');
        showHideOverlay('contracts_list', 'flex');
        $('.purchase_button').text(localize('Purchase'));
    };

    var getContractCategoryTree = function getContractCategoryTree(elements) {
        var tree = [['updown', ['risefall', 'higherlower']], 'touchnotouch', ['inout', ['endsinout', 'staysinout']], 'asian', ['digits', ['matchdiff', 'evenodd', 'overunder']], ['lookback', ['lookbackhigh', 'lookbacklow', 'lookbackhighlow']], 'reset', 'callputspread', 'highlowticks'];

        if (elements) {
            tree = tree.map(function (e) {
                var value = e;
                if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {
                    value[1] = value[1].filter(function (value1) {
                        return elements[value1];
                    });
                    if (!value[1].length) {
                        value = '';
                    }
                } else if (!elements[value]) {
                    value = '';
                }
                return value;
            });
            tree = tree.filter(function (v) {
                return v.length;
            });
        }
        return tree;
    };

    /*
     * resets price movement color changing, to prevent coloring on some changes
     * coloring will continue on the next proposal responses
     */
    var resetPriceMovement = function resetPriceMovement() {
        var btns = document.getElementsByClassName('purchase_button');
        for (var i = 0; i < btns.length; i++) {
            btns[i].setAttribute('data-display_value', '');
            btns[i].setAttribute('data-payout', '');
        }
    };

    var toggleActiveCatMenuElement = function toggleActiveCatMenuElement(nav, event_element_id) {
        var event_element = getElementById(event_element_id);
        var li_elements = nav.querySelectorAll('.active, .a-active');
        var classes = event_element.classList;
        var i = void 0,
            len = void 0;

        if (!classes.contains('active')) {
            for (i = 0, len = li_elements.length; i < len; i++) {
                li_elements[i].classList.remove('active');
                li_elements[i].classList.remove('a-active');
            }
            classes.add('a-active');

            i = 0;
            var parent = event_element.parentElement;
            while (parent && parent.id !== nav.id && i < 10) {
                if (parent.tagName === 'LI') {
                    parent.classList.add('active');
                }
                parent = parent.parentElement;
                i++;
            }
        }
    };

    /*
     * display the profit and return of bet under each trade container
     */
    var displayCommentPrice = function displayCommentPrice(node, currency, type, payout) {
        if (node && type && payout) {
            var profit = payout - type;
            var return_percent = profit / type * 100;
            var comment = localize('Net profit') + ': ' + formatMoney(currency, profit) + ' | ' + localize('Return') + ' ' + return_percent.toFixed(1) + '%';

            if (isNaN(profit) || isNaN(return_percent)) {
                node.hide();
            } else {
                node.show();
                elementInnerHtml(node, comment);
            }
        }
    };

    /*
     * This is used in case where we have input and we don't want to fire
     * event on every change while user is typing for example in case of amount if
     * we want to change 10 to 1000 i.e. two zeros so two input events will be fired
     * normally, this will delay the event based on delay specified in milliseconds
     *
     * Reference
     * http://davidwalsh.name/javascript-debounce-function
     */
    var debounce = function debounce(func, wait, immediate) {
        var timeout = void 0;
        var delay = wait || 500;
        return function () {
            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
            }

            var context = this;
            var later = function later() {
                timeout = null;
                if (!immediate) func.apply(context, args);
            };
            var call_now = immediate && !timeout;
            clearTimeout(timeout);
            timeout = setTimeout(later, delay);
            if (call_now) func.apply(context, args);
        };
    };

    /*
     * check if selected market is allowed for current user
     */
    var getDefaultMarket = function getDefaultMarket() {
        var mkt = Defaults.get('market');
        var markets = Symbols.markets(1);
        if (!mkt || !markets[mkt]) {
            var sorted_markets = Object.keys(Symbols.markets()).filter(function (v) {
                return markets[v].is_active;
            }).sort(function (a, b) {
                return getMarketsOrder(a) - getMarketsOrder(b);
            });
            mkt = sorted_markets[0] || Object.keys(Symbols.markets())[0];
        }
        return mkt;
    };

    // Order
    var market_order = {
        forex: 1,
        volidx: 2,
        indices: 3,
        stocks: 4,
        commodities: 5
    };

    var getMarketsOrder = function getMarketsOrder(market) {
        return market_order[market] || 100;
    };

    /*
     * this is invoked when submit button is clicked and prevents reloading of page
     */
    var addEventListenerForm = function addEventListenerForm() {
        getElementById('websocket_form').addEventListener('submit', function (evt) {
            evt.currentTarget.classList.add('submitted');
            evt.preventDefault();
            return false;
        }, false);
    };

    /*
     * this creates a button, clicks it, and destroys it to invoke the listener
     */
    var submitForm = function submitForm(form) {
        var button = form.ownerDocument.createElement('input');
        button.style.display = 'none';
        button.type = 'submit';
        form.appendChild(button).click();
        form.removeChild(button);
    };

    /*
     * sort the duration in ascending order
     */
    var duration_config = {
        t: { order: 1, type: 'tick' },
        s: { order: 2, type: 'intraday' },
        m: { order: 3, type: 'intraday' },
        h: { order: 4, type: 'intraday' },
        d: { order: 5, type: 'daily' }
    };

    var displayTooltip = function displayTooltip() {
        var tip = getElementById('symbol_tip');
        if (tip) {
            var market = ActiveSymbols.getSymbols()[Defaults.get('underlying')].market;
            var map_to_section_id = {
                forex: 'forex',
                indices: 'otc-stocks-and-indices',
                stocks: 'otc-stocks-and-indices',
                commodities: 'commodities',
                volidx: 'volatility-indices'
            };
            tip.setAttribute('href', urlFor('/get-started/binary-options', 'anchor=' + map_to_section_id[market] + '#range-of-markets'));
        }
    };

    var selectOption = function selectOption(option, select) {
        if (!select) return false;

        var options = select.getElementsByTagName('option');
        var contains = 0;
        for (var i = 0; i < options.length; i++) {
            if (options[i].value === option && !options[i].hasAttribute('disabled')) {
                contains = 1;
                break;
            }
        }
        if (contains) {
            select.value = option;
            return true;
        }

        return false;
    };

    var chart_config = {
        type: 'line',
        lineColor: '#606060',
        fillColor: false,
        spotColor: '#00f000',
        minSpotColor: '#f00000',
        maxSpotColor: '#0000f0',
        highlightSpotColor: '#ffff00',
        highlightLineColor: '#000000',
        spotRadius: 1.25
    };

    var $chart = void 0;

    var updateWarmChart = function updateWarmChart() {
        $chart = $chart && $chart.length ? $chart : $('#trading_worm_chart');
        var spots = Object.keys(Tick.spots()).sort(function (a, b) {
            return a - b;
        }).map(function (v) {
            return Tick.spots()[v];
        });
        if ($chart && typeof $chart.sparkline === 'function') {
            $chart.sparkline(spots, chart_config);
            if (spots.length) {
                $chart.show();
            } else {
                $chart.hide();
            }
        }
    };

    var reloadPage = function reloadPage() {
        Defaults.remove('market', 'underlying', 'formname', 'date_start', 'time_start', 'expiry_type', 'expiry_date', 'expirt_time', 'duration_units', 'diration_value', 'amount', 'amount_type', 'currency', 'prediction');
        location.reload();
    };

    var timeIsValid = function timeIsValid($element) {
        var end_time_value = getElementById('expiry_time').value;
        var $invalid_time = $('#invalid-time');

        if ($element.attr('id') === 'expiry_time' && end_time_value && !/^(0[0-9]|1[0-9]|2[0-3]):[0-5][0-9]$/.test(end_time_value)) {
            $element.addClass('error-field');
            if ($invalid_time.length === 0) {
                $('#expiry_type_endtime').parent().append($('<p>', { class: 'error-msg', id: 'invalid-time', text: localize('Time is in the wrong format.') }));
            }
            return false;
        }

        $element.removeClass('error-field');
        $invalid_time.remove();

        $element.removeClass('error-field');
        $('#end_time_validation').remove();
        return true;
    };

    var requireHighstock = function requireHighstock(callback) {
        return __webpack_require__.e/* require.ensure */(0).then((function (require) {
            var Highstock = __webpack_require__(240);
            return callback(Highstock);
        }).bind(null, __webpack_require__)).catch(__webpack_require__.oe);
    };

    return {
        getFormNameBarrierCategory: getFormNameBarrierCategory,
        contractTypeDisplayMapping: contractTypeDisplayMapping,
        hideOverlayContainer: hideOverlayContainer,
        getContractCategoryTree: getContractCategoryTree,
        resetPriceMovement: resetPriceMovement,
        toggleActiveCatMenuElement: toggleActiveCatMenuElement,
        displayCommentPrice: displayCommentPrice,
        debounce: debounce,
        getDefaultMarket: getDefaultMarket,
        addEventListenerForm: addEventListenerForm,
        submitForm: submitForm,
        displayTooltip: displayTooltip,
        selectOption: selectOption,
        updateWarmChart: updateWarmChart,
        reloadPage: reloadPage,
        displayContractForms: displayContractForms,
        displayMarkets: displayMarkets,
        timeIsValid: timeIsValid,
        requireHighstock: requireHighstock,
        showPriceOverlay: function showPriceOverlay() {
            showHideOverlay('loading_container2', 'block');
        },
        hidePriceOverlay: function hidePriceOverlay() {
            showHideOverlay('loading_container2', 'none');
        },
        hideFormOverlay: function hideFormOverlay() {
            showHideOverlay('loading_container3', 'none');
        },
        showFormOverlay: function showFormOverlay() {
            showHideOverlay('loading_container3', 'block');
        },
        durationOrder: function durationOrder(duration) {
            return duration_config[duration].order;
        },
        durationType: function durationType(duration) {
            return duration_config[duration].type;
        },
        clean: function clean() {
            $chart = null;contracts_element = null;
        }
    };
}();

module.exports = commonTrading;

/***/ }),
/* 32 */,
/* 33 */,
/* 34 */,
/* 35 */,
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isEmptyObject = __webpack_require__(1).isEmptyObject;

/*
 * Handles trading page default values
 *
 * Priorities:
 * 1. Client's input: on each change to form, it will reflect to both query string & session storage
 * 2. Local storage values: if none of the above, it will be the source
 *
 */

var MBDefaults = function () {
    var params = {};

    var getDefault = function getDefault(key) {
        loadParams();
        return params[key];
    };

    var loadParams = function loadParams() {
        if (isEmptyObject(params)) params = JSON.parse(localStorage.getItem('mb_trading') || false) || {};
    };

    var saveParams = function saveParams() {
        localStorage.setItem('mb_trading', JSON.stringify(params));
    };

    var setDefault = function setDefault(key) {
        var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

        if (!key) return;
        loadParams();
        if (params[key] !== value) {
            params[key] = value;
            saveParams();
        }
    };

    var removeDefault = function removeDefault() {
        for (var _len = arguments.length, keys = Array(_len), _key = 0; _key < _len; _key++) {
            keys[_key] = arguments[_key];
        }

        loadParams();
        var is_updated = false;
        keys.forEach(function (key) {
            if (key in params) {
                delete params[key];
                is_updated = true;
            }
        });
        if (is_updated) {
            saveParams();
        }
    };

    return {
        get: getDefault,
        set: setDefault,
        remove: removeDefault,
        clear: function clear() {
            params = {};
        }
    };
}();

module.exports = MBDefaults;

/***/ }),
/* 37 */,
/* 38 */,
/* 39 */,
/* 40 */,
/* 41 */,
/* 42 */,
/* 43 */,
/* 44 */,
/* 45 */,
/* 46 */,
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var moment = __webpack_require__(9);
var getElementById = __webpack_require__(4).getElementById;
var getPropertyValue = __webpack_require__(1).getPropertyValue;

/*
 * Display price/spot movement variation to depict price moved up or down
 */
var displayPriceMovement = function displayPriceMovement(element, old_value, current_value) {
    element.classList.remove('price_moved_down');
    element.classList.remove('price_moved_up');
    if (parseFloat(current_value) > parseFloat(old_value)) {
        element.classList.remove('price_moved_down');
        element.classList.add('price_moved_up');
    } else if (parseFloat(current_value) < parseFloat(old_value)) {
        element.classList.remove('price_moved_up');
        element.classList.add('price_moved_down');
    }
};

/*
 * count number of decimal places in spot so that we can make barrier to same decimal places
 */
var countDecimalPlaces = function countDecimalPlaces(num) {
    if (!isNaN(num)) {
        var str = num.toString();
        if (str.indexOf('.') !== -1) {
            return str.split('.')[1].length;
        }
    }
    return 0;
};

var trading_times = {};

var processTradingTimesAnswer = function processTradingTimesAnswer(response) {
    if (!getPropertyValue(trading_times, response.echo_req.trading_times) && getPropertyValue(response, ['trading_times', 'markets'])) {
        for (var i = 0; i < response.trading_times.markets.length; i++) {
            var submarkets = response.trading_times.markets[i].submarkets;
            if (submarkets) {
                for (var j = 0; j < submarkets.length; j++) {
                    var symbols = submarkets[j].symbols;
                    if (symbols) {
                        for (var k = 0; k < symbols.length; k++) {
                            var symbol = symbols[k];
                            if (!trading_times[response.echo_req.trading_times]) {
                                trading_times[response.echo_req.trading_times] = {};
                            }
                            trading_times[response.echo_req.trading_times][symbol.symbol] = symbol.times.close;
                        }
                    }
                }
            }
        }
    }
};

var getElement = function getElement() {
    return getElementById('date_start');
};

var checkValidTime = function checkValidTime() {
    var time_start_element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getElementById('time_start');
    var $date_start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : $('#date_start');
    var time = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : time_start_element.value;

    var time_array = '';
    if (time) {
        time_array = time.split(':');
    }
    var now_time = moment.utc();
    var hour = time_array.length ? +time_array[0] : now_time.hour();
    var minute = time_array.length ? +time_array[1] : now_time.minute();
    var date_time = moment.utc(getElement().value * 1000).hour(hour).minute(minute);
    var min_max_time = getMinMaxTimeStart($date_start);
    var min_time = min_max_time.minTime.clone();
    if (!(min_max_time.minTime.format('HH:mm') === '23:55')) {
        min_time = min_time.add(5, 'minutes');
    }
    time_start_element.value = date_time.isBefore(min_time) || date_time.isAfter(min_max_time.maxTime) || !time ? min_time.format('HH:mm') : time_array.join(':');
    time_start_element.setAttribute('data-value', time_start_element.value);
};

var getMinMaxTimeStart = function getMinMaxTimeStart() {
    var $min_max_selector = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : $('#date_start');
    var moment_now = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : (window.time || moment.utc()).clone();

    var $selected_option = getSelectedOption($min_max_selector);
    var start_date = moment.unix($min_max_selector.val()).utc();
    var end_date = moment.unix($selected_option.attr('data-end')).utc();
    return {
        minTime: start_date.isAfter(moment_now) ? start_date : moment_now.clone(),
        maxTime: end_date.isSame(start_date, 'day') ? end_date : start_date.clone().hour(23).minute(55).second(0)
    };
};

var getMinMaxTimeEnd = function getMinMaxTimeEnd() {
    var $date_start = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : $('#date_start');
    var $time_start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : $('#time_start');
    var moment_now = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : (window.time || moment.utc()).clone();
    var $expiry_time = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : $('#expiry_time');
    var $expiry_date = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : $('#expiry_date');

    var min_time = void 0,
        max_time = void 0;
    var date_start_val = $date_start.val();
    if (date_start_val === 'now') {
        var min_max_time = getMinMaxTimeStart();
        min_time = min_max_time.minTime;
        max_time = min_max_time.maxTime;
    } else {
        var expiry_time_val = $expiry_time.val().split(':');
        var end_time = moment.utc($expiry_date.attr('data-value'));
        if (expiry_time_val.length > 1) {
            end_time = end_time.hour(expiry_time_val[0]).minute(expiry_time_val[1]);
        }
        var moment_date_start = moment.unix(date_start_val).utc();
        var start_time_val = $time_start.val().split(':');
        var compare = isNaN(+date_start_val) ? moment_now.clone() : moment_date_start.hour(start_time_val[0]).minute(start_time_val[1]);
        // if expiry time is one day after start time, minTime can be 0
        // but maxTime should be 24 hours after start time, so exact value of start time
        if (end_time.isAfter(compare, 'day')) {
            min_time = 0;
            max_time = start_time_val.length > 1 ? end_time.clone().hour(start_time_val[0]).minute(start_time_val[1]) : end_time.clone();
        } else {
            // if expiry time is same as today, min time should be the selected start time plus five minutes
            min_time = moment_date_start.clone();
            min_time = min_time.hour(start_time_val[0]).minute(start_time_val[1]);
            if (!(+start_time_val[0] === 23 && +start_time_val[1] === 55)) {
                min_time = min_time.add(5, 'minutes');
            }
            max_time = getMinMaxTimeStart().maxTime;
        }
    }
    return {
        minTime: min_time,
        maxTime: max_time
    };
};

var getSelectedOption = function getSelectedOption($selector) {
    var $selected_option = $selector.find('option:selected');
    // if 'now' is selected, take first option's value
    if (isNaN(+$selector.val())) {
        $selected_option = $($selector.find('option')[1]);
    }
    return $selected_option;
};

var showAssetOpenHours = function showAssetOpenHours($selector) {
    var $selected_option = $selector ? getSelectedOption($selector) : '';
    var sessions = $selected_option ? $selected_option.attr('data-sessions') : '';
    $('#asset_open_hours').text(sessions || '').parent().setVisibility(!!sessions);
};

module.exports = {
    displayPriceMovement: displayPriceMovement,
    countDecimalPlaces: countDecimalPlaces,
    processTradingTimesAnswer: processTradingTimesAnswer,
    checkValidTime: checkValidTime,
    getSelectedOption: getSelectedOption,
    getMinMaxTimeStart: getMinMaxTimeStart,
    getMinMaxTimeEnd: getMinMaxTimeEnd,
    showAssetOpenHours: showAssetOpenHours,
    getStartDateNode: getElement,
    getTradingTimes: function getTradingTimes() {
        return trading_times;
    }
};

/***/ }),
/* 48 */,
/* 49 */,
/* 50 */,
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// const Cookies = require('js-cookie');

/*
 * Configuration values needed in js codes
 *
 * NOTE:
 * Please use the following command to avoid accidentally committing personal changes
 * git update-index --assume-unchanged src/javascript/config.js
 *
 */

var getAppId = function getAppId() {
    var app_id = null;
    var user_app_id = 12038; // you can insert Application ID of your registered application here
    var config_app_id = window.localStorage.getItem('config.app_id');
    if (config_app_id) {
        app_id = config_app_id;
    } else if (/staging\.binary\.com/i.test(window.location.hostname)) {
        window.localStorage.removeItem('config.default_app_id');
        app_id = 1098;
    } else if (user_app_id.length) {
        window.localStorage.setItem('config.default_app_id', user_app_id); // it's being used in endpoint chrome extension - please do not remove
        app_id = user_app_id;
    } else {
        window.localStorage.removeItem('config.default_app_id');
        app_id = 1;
    }
    return app_id;
};

var getSocketURL = function getSocketURL() {
    var server_url = window.localStorage.getItem('config.server_url');
    if (!server_url) {
        // const to_green_percent = { real: 100, virtual: 0, logged_out: 0 }; // default percentage
        // const category_map     = ['real', 'virtual', 'logged_out'];
        // const percent_values   = Cookies.get('connection_setup'); // set by GTM
        //
        // // override defaults by cookie values
        // if (percent_values && percent_values.indexOf(',') > 0) {
        //     const cookie_percents = percent_values.split(',');
        //     category_map.map((cat, idx) => {
        //         if (cookie_percents[idx] && !isNaN(cookie_percents[idx])) {
        //             to_green_percent[cat] = +cookie_percents[idx].trim();
        //         }
        //     });
        // }

        // let server = 'blue';
        // if (/www\.binary\.com/i.test(window.location.hostname)) {
        //     const loginid = window.localStorage.getItem('active_loginid');
        //     let client_type = category_map[2];
        //     if (loginid) {
        //         client_type = /^VRT/.test(loginid) ? category_map[1] : category_map[0];
        //     }
        //
        //     const random_percent = Math.random() * 100;
        //     if (random_percent < to_green_percent[client_type]) {
        //         server = 'green';
        //     }
        // }

        // TODO: in order to use connection_setup config, uncomment the above section and remove next lines

        var is_production = /www\.binary\.com/i.test(window.location.hostname);
        var loginid = window.localStorage.getItem('active_loginid');
        var is_real = loginid && !/^VRT/.test(loginid);
        var server = is_production && is_real ? 'green' : 'blue';

        server_url = server + '.binaryws.com';
    }
    return 'wss://' + server_url + '/websockets/v3';
};

module.exports = {
    getAppId: getAppId,
    getSocketURL: getSocketURL
};

/***/ }),
/* 52 */,
/* 53 */,
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var Cookies = __webpack_require__(50);
var moment = __webpack_require__(9);
var ClientBase = __webpack_require__(85);
var Login = __webpack_require__(55);
var BinarySocket = __webpack_require__(86);
var getElementById = __webpack_require__(4).getElementById;
var isVisible = __webpack_require__(4).isVisible;
var getLanguage = __webpack_require__(16).get;
var State = __webpack_require__(6).State;
var getAppId = __webpack_require__(51).getAppId;

var GTM = function () {
    var isGtmApplicable = function isGtmApplicable() {
        return (/^(1|1098)$/.test(getAppId())
        );
    };

    var gtmDataLayerInfo = function gtmDataLayerInfo(data) {
        var data_layer_info = {
            language: getLanguage(),
            pageTitle: pageTitle(),
            pjax: State.get('is_loaded_by_pjax'),
            url: document.URL,
            event: 'page_load'
        };
        if (ClientBase.isLoggedIn()) {
            data_layer_info.visitorId = ClientBase.get('loginid');
        }

        $.extend(true, data_layer_info, data);

        var event = data_layer_info.event;
        delete data_layer_info.event;

        return {
            event: event,
            data: data_layer_info
        };
    };

    var pushDataLayer = function pushDataLayer(data) {
        if (isGtmApplicable() && !Login.isLoginPages()) {
            var info = gtmDataLayerInfo(data && (typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object' ? data : null);
            dataLayer[0] = info.data;
            dataLayer.push(info.data);
            dataLayer.push({ event: info.event });
        }
    };

    var pageTitle = function pageTitle() {
        var t = /^.+[:-]\s*(.+)$/.exec(document.title);
        return t && t[1] ? t[1] : document.title;
    };

    var eventHandler = function eventHandler(get_settings) {
        if (!isGtmApplicable()) return;
        var is_login = localStorage.getItem('GTM_login') === '1';
        var is_new_account = localStorage.getItem('GTM_new_account') === '1';
        if (!is_login && !is_new_account) return;

        localStorage.removeItem('GTM_login');
        localStorage.removeItem('GTM_new_account');

        var affiliate_token = Cookies.getJSON('affiliate_tracking');
        if (affiliate_token) {
            pushDataLayer({ bom_affiliate_token: affiliate_token.t });
        }

        var data = {
            visitorId: ClientBase.get('loginid'),
            bom_currency: ClientBase.get('currency'),
            bom_country: get_settings.country,
            bom_country_abbrev: get_settings.country_code,
            bom_email: get_settings.email,
            url: window.location.href,
            bom_today: Math.floor(Date.now() / 1000),
            event: is_new_account ? 'new_account' : 'log_in'
        };
        if (is_new_account) {
            data.bom_date_joined = data.bom_today;
        }
        if (!ClientBase.get('is_virtual')) {
            data.bom_age = parseInt((moment().unix() - get_settings.date_of_birth) / 31557600);
            data.bom_firstname = get_settings.first_name;
            data.bom_lastname = get_settings.last_name;
            data.bom_phone = get_settings.phone;
        }

        if (is_login) {
            BinarySocket.wait('mt5_login_list').then(function (response) {
                (response.mt5_login_list || []).forEach(function (obj) {
                    var acc_type = (ClientBase.getMT5AccountType(obj.group) || '').replace('real_vanuatu', 'financial').replace('vanuatu_', '').replace('costarica', 'gaming'); // i.e. financial_cent, demo_cent, demo_gaming, real_gaming
                    if (acc_type) {
                        data['mt5_' + acc_type + '_id'] = obj.login;
                    }
                });
                pushDataLayer(data);
            });
        } else {
            pushDataLayer(data);
        }
    };

    var pushPurchaseData = function pushPurchaseData(response) {
        if (!isGtmApplicable() || ClientBase.get('is_virtual')) return;
        var buy = response.buy;
        if (!buy) return;
        var req = response.echo_req.passthrough;
        var data = {
            event: 'buy_contract',
            visitorId: ClientBase.get('loginid'),
            bom_symbol: req.symbol,
            bom_market: getElementById('contract_markets').value,
            bom_currency: req.currency,
            bom_contract_type: req.contract_type,
            bom_contract_id: buy.contract_id,
            bom_transaction_id: buy.transaction_id,
            bom_buy_price: buy.buy_price,
            bom_payout: buy.payout
        };
        $.extend(data, {
            bom_amount: req.amount,
            bom_basis: req.basis,
            bom_expiry_type: getElementById('expiry_type').value
        });
        if (data.bom_expiry_type === 'duration') {
            $.extend(data, {
                bom_duration: req.duration,
                bom_duration_unit: req.duration_unit
            });
        }
        if (isVisible(getElementById('barrier'))) {
            data.bom_barrier = req.barrier;
        } else if (isVisible(getElementById('barrier_high'))) {
            data.bom_barrier_high = req.barrier;
            data.bom_barrier_low = req.barrier2;
        }
        if (isVisible(getElementById('prediction'))) {
            data.bom_prediction = req.barrier;
        }

        pushDataLayer(data);
    };

    var mt5NewAccount = function mt5NewAccount(response) {
        var acc_type = response.mt5_new_account.mt5_account_type ? response.mt5_new_account.account_type + '_' + response.mt5_new_account.mt5_account_type : // financial_cent, demo_cent, ...
        (response.mt5_new_account.account_type === 'demo' ? 'demo' : 'real') + '_gaming'; // demo_gaming, real_gaming

        var gtm_data = {
            event: 'mt5_new_account',
            bom_email: ClientBase.get('email'),
            bom_country: State.getResponse('get_settings.country'),
            mt5_last_signup: acc_type
        };

        gtm_data['mt5_' + acc_type + '_id'] = response.mt5_new_account.login;

        if (/demo/.test(acc_type) && !ClientBase.get('is_virtual')) {
            gtm_data.visitorId = ClientBase.getAccountOfType('virtual').loginid;
        }

        pushDataLayer(gtm_data);
    };

    return {
        pushDataLayer: pushDataLayer,
        eventHandler: eventHandler,
        pushPurchaseData: pushPurchaseData,
        mt5NewAccount: mt5NewAccount,
        setLoginFlag: function setLoginFlag() {
            if (isGtmApplicable()) localStorage.setItem('GTM_login', '1');
        }
    };
}();

module.exports = GTM;

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Client = __webpack_require__(85);
var getLanguage = __webpack_require__(16).get;
var isStorageSupported = __webpack_require__(6).isStorageSupported;
var getAppId = __webpack_require__(51).getAppId;

var Login = function () {
    var redirectToLogin = function redirectToLogin() {
        if (!Client.isLoggedIn() && !isLoginPages() && isStorageSupported(sessionStorage)) {
            sessionStorage.setItem('redirect_url', window.location.href);
            window.location.href = loginUrl();
        }
    };

    var loginUrl = function loginUrl() {
        var server_url = localStorage.getItem('config.server_url');
        var language = getLanguage();
        return server_url && /qa/.test(server_url) ? 'https://www.' + server_url.split('.')[1] + '.com/oauth2/authorize?app_id=' + getAppId() + '&l=' + language : 'https://oauth.binary.com/oauth2/authorize?app_id=' + getAppId() + '&l=' + language;
    };

    var isLoginPages = function isLoginPages() {
        return (/logged_inws|redirect/i.test(window.location.pathname)
        );
    };

    var socialLoginUrl = function socialLoginUrl(brand) {
        return loginUrl() + '&social_signup=' + brand;
    };

    return {
        redirectToLogin: redirectToLogin,
        isLoginPages: isLoginPages,
        socialLoginUrl: socialLoginUrl
    };
}();

module.exports = Login;

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Dropdown = __webpack_require__(25).selectDropdown;
var addComma = __webpack_require__(7).addComma;
var getDecimalPlaces = __webpack_require__(7).getDecimalPlaces;
var Client = __webpack_require__(3);
var Password = __webpack_require__(243);
var localize = __webpack_require__(2).localize;
var compareBigUnsignedInt = __webpack_require__(17).compareBigUnsignedInt;
var getHashValue = __webpack_require__(8).getHashValue;
var cloneObject = __webpack_require__(1).cloneObject;
var isEmptyObject = __webpack_require__(1).isEmptyObject;

var Validation = function () {
    var forms = {};
    var error_class = 'error-msg';
    var hidden_class = 'invisible';

    var events_map = {
        input: 'input.validation change.validation',
        select: 'change.validation',
        checkbox: 'change.validation'
    };

    var getFieldType = function getFieldType($field) {
        var type = null;
        if ($field.length) {
            type = $field.attr('type') === 'checkbox' ? 'checkbox' : $field.get(0).localName;
        }
        return type;
    };

    var isChecked = function isChecked(field) {
        return field.$.is(':checked') ? '1' : '';
    };

    var getFieldValue = function getFieldValue(field, options) {
        var value = void 0;
        if (typeof options.value === 'function') {
            value = options.value();
        } else {
            value = field.type === 'checkbox' ? isChecked(field) : field.$.val();
        }
        return value || '';
    };

    var initForm = function initForm(form_selector, fields, needs_token) {
        var $form = $(form_selector + ':visible');

        if (needs_token) {
            var token = getHashValue('token');
            if (!validEmailToken(token)) {
                $form.replaceWith($('<div/>', { class: error_class, text: localize('Verification code is wrong. Please use the link sent to your email.') }));
                return;
            }
        }

        if ($form.length) {
            forms[form_selector] = { $form: $form };
            if (Array.isArray(fields) && fields.length) {
                forms[form_selector].fields = fields;
                fields.forEach(function (field) {
                    field.$ = $form.find(field.selector);
                    if (!field.$.length || !field.validations) return;

                    field.type = getFieldType($(field.$[0])); // also handles multiple results
                    field.form = form_selector;
                    if (field.msg_element) {
                        field.$error = $form.find(field.msg_element);
                    } else {
                        var $parent = field.$.parent();
                        // Add indicator to required fields
                        if (field.validations.find(function (v) {
                            return (/^req$/.test(v) && (isEmptyObject(v[1]) || !v[1].hide_asterisk)
                            );
                        })) {
                            var $label = $parent.parent().find('label');
                            if (!$label.length) $label = $parent.find('label');
                            if ($label.length && $label.find('span.required_field_asterisk').length === 0) {
                                $($label[0]).append($('<span/>', { class: 'required_field_asterisk', text: '*' }));
                            }
                        }
                        if ($parent.find('p.' + error_class).length === 0) {
                            $parent.append($('<p/>', { class: error_class + ' ' + hidden_class + ' no-margin' }));
                        }
                        field.$error = $parent.find('.' + error_class);
                    }

                    var event = events_map[field.type];

                    if (event) {
                        field.$.unbind(event).on(event, function () {
                            checkField(field);
                            if (field.re_check_field) {
                                checkField(forms[form_selector].fields.find(function (fld) {
                                    return fld.selector === field.re_check_field;
                                }));
                            }
                        });
                    }
                });
            }
        }

        // need to init Dropdown after we have responses from ws
        var el_all_select = document.querySelectorAll('select:not([multiple]):not([single])');
        el_all_select.forEach(function (el) {
            if (el.id) {
                Dropdown('#' + el.id);
            }
        });
    };

    // ------------------------------
    // ----- Validation Methods -----
    // ------------------------------
    var validRequired = function validRequired(value, options, field) {
        if (value.length) return true;
        // else
        validators_map.req.message = field.type === 'checkbox' ? 'Please select the checkbox.' : 'This field is required.';
        return false;
    };
    var validEmail = function validEmail(value) {
        return (/^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,63}$/.test(value)
        );
    };
    var validPassword = function validPassword(value, options, field) {
        if (/(?=.*[a-z])(?=.*[A-Z])(?=.*\d)[a-zA-Z\d]+/.test(value)) {
            Password.checkPassword(field.selector);
            return true;
        }
        // else
        return false;
    };
    var validLetterSymbol = function validLetterSymbol(value) {
        return !/[`~!@#$%^&*)(_=+[}{\]\\/";:?><,|\d]+/.test(value);
    };
    var validGeneral = function validGeneral(value) {
        return !/[`~!@#$%^&*)(_=+[}{\]\\/";:?><|]+/.test(value);
    };
    var validAddress = function validAddress(value) {
        return !/[`~!$%^&*_=+[}{\]\\"?><|]+/.test(value);
    };
    var validPostCode = function validPostCode(value) {
        return (/^[a-zA-Z\d-\s]*$/.test(value)
        );
    };
    var validPhone = function validPhone(value) {
        return (/^\+?[0-9\s]*$/.test(value)
        );
    };
    var validRegular = function validRegular(value, options) {
        return options.regex.test(value);
    };
    var validEmailToken = function validEmailToken(value) {
        return value.trim().length === 8;
    };
    var validTaxID = function validTaxID(value) {
        return (/^[a-zA-Z0-9]*[\w-]*$/.test(value)
        );
    };

    var validCompare = function validCompare(value, options) {
        return value === $(options.to).val();
    };
    var validNotEqual = function validNotEqual(value, options) {
        return value !== $(options.to).val();
    };
    var validMin = function validMin(value, options) {
        return options.min ? value.length >= options.min : true;
    };
    var validLength = function validLength(value, options) {
        return (options.min ? value.length >= options.min : true) && (options.max ? value.length <= options.max : true);
    };

    var validNumber = function validNumber(value, opts) {
        var options = cloneObject(opts);
        if (options.allow_empty && value.length === 0) {
            return true;
        }

        var is_ok = true;
        var message = '';

        if ('min' in options && typeof options.min === 'function') {
            options.min = options.min();
        }
        if ('max' in options && typeof options.max === 'function') {
            options.max = options.max();
        }

        if (!(options.type === 'float' ? /^\d+(\.\d+)?$/ : /^\d+$/).test(value) || !$.isNumeric(value)) {
            is_ok = false;
            message = localize('Should be a valid number.');
        } else if (options.type === 'float' && options.decimals && !new RegExp('^\\d+(\\.\\d{0,' + options.decimals + '})?$').test(value)) {
            is_ok = false;
            message = localize('Up to [_1] decimal places are allowed.', [options.decimals]);
        } else if ('min' in options && 'max' in options && +options.min === +options.max && +value !== +options.min) {
            is_ok = false;
            message = localize('Should be [_1]', [addComma(options.min, options.format_money ? getDecimalPlaces(Client.get('currency')) : undefined)]);
        } else if ('min' in options && 'max' in options && (+value < +options.min || isMoreThanMax(value, options))) {
            is_ok = false;
            message = localize('Should be between [_1] and [_2]', [addComma(options.min, options.format_money ? getDecimalPlaces(Client.get('currency')) : undefined), addComma(options.max, options.format_money ? getDecimalPlaces(Client.get('currency')) : undefined)]);
        } else if ('min' in options && +value < +options.min) {
            is_ok = false;
            message = localize('Should be more than [_1]', [addComma(options.min, options.format_money ? getDecimalPlaces(Client.get('currency')) : undefined)]);
        } else if ('max' in options && isMoreThanMax(value, options)) {
            is_ok = false;
            message = localize('Should be less than [_1]', [addComma(options.max, options.format_money ? getDecimalPlaces(Client.get('currency')) : undefined)]);
        }

        validators_map.number.message = message;
        return is_ok;
    };

    var isMoreThanMax = function isMoreThanMax(value, options) {
        return options.type === 'float' ? +value > +options.max : compareBigUnsignedInt(value, options.max) === 1;
    };

    var validators_map = {
        req: { func: validRequired, message: '' },
        email: { func: validEmail, message: 'Invalid email address.' },
        password: { func: validPassword, message: 'Password should have lower and uppercase letters with numbers.' },
        general: { func: validGeneral, message: 'Only letters, numbers, space, hyphen, period, and apostrophe are allowed.' },
        address: { func: validAddress, message: 'Only letters, numbers, space, and these special characters are allowed: - . \' # ; : ( ) , @ /' },
        letter_symbol: { func: validLetterSymbol, message: 'Only letters, space, hyphen, period, and apostrophe are allowed.' },
        postcode: { func: validPostCode, message: 'Only letters, numbers, space, and hyphen are allowed.' },
        phone: { func: validPhone, message: 'Only numbers and spaces are allowed.' },
        compare: { func: validCompare, message: 'The two passwords that you entered do not match.' },
        not_equal: { func: validNotEqual, message: '[_1] and [_2] cannot be the same.' },
        min: { func: validMin, message: 'Minimum of [_1] characters required.' },
        length: { func: validLength, message: 'You should enter [_1] characters.' },
        number: { func: validNumber, message: '' },
        regular: { func: validRegular, message: '' },
        tax_id: { func: validTaxID, message: 'Should start with letter or number, and may contain hyphen and underscore.' }
    };

    var pass_length = function pass_length(type) {
        return { min: /^mt$/.test(type) ? 8 : 6, max: 25 };
    };

    // --------------------
    // ----- Validate -----
    // --------------------
    var checkField = function checkField(field) {
        if (!field.$.is(':visible') || !field.validations) return true;
        if (field.clear_form_error_on_input) {
            $(field.form + '_error').text('');
        }

        var all_is_ok = true;
        var message = '';
        var field_type = field.$.attr('type');

        field.validations.some(function (valid) {
            if (!valid) return false; // check next validation
            var type = void 0;
            var options = {};

            if (typeof valid === 'string') {
                type = valid;
            } else {
                type = valid[0];
                options = valid[1];
            }

            if (type === 'password' && !validLength(getFieldValue(field, options), pass_length(options))) {
                field.is_ok = false;
                type = 'length';
                options = pass_length(options);
            } else {
                var validator = type === 'custom' ? options.func : validators_map[type].func;

                var value = getFieldValue(field, options);
                if (field_type !== 'password' && typeof value === 'string') {
                    value = value.trim();
                }

                field.is_ok = validator(value, options, field);
            }

            if (!field.is_ok) {
                message = options.message || validators_map[type].message;
                if (type === 'length') {
                    message = localize(message, [options.min === options.max ? options.min : options.min + '-' + options.max]);
                } else if (type === 'min') {
                    message = localize(message, [options.min]);
                } else if (type === 'not_equal') {
                    message = localize(message, [localize(options.name1), localize(options.name2)]);
                }
                all_is_ok = false;
                return true; // break on the first error found
            }
            return false; // check next validation
        });

        if (!all_is_ok) {
            showError(field, message);
        } else {
            clearError(field);
        }

        return all_is_ok;
    };

    var clearError = function clearError(field) {
        if (field.$error && field.$error.length) {
            field.$error.setVisibility(0);
        }
    };

    var showError = function showError(field, message) {
        clearError(field);
        Password.removeCheck(field.selector);
        field.$error.html(localize(message)).setVisibility(1);
    };

    var validate = function validate(form_selector) {
        var form = forms[form_selector];
        if (!form.fields) return true;
        form.is_ok = true;
        form.fields.forEach(function (field) {
            if (!checkField(field)) {
                if (form.is_ok && !field.no_scroll) {
                    // first error
                    $.scrollTo(field.$, 500, { offset: -10 });
                }
                form.is_ok = false;
            }
        });
        return form.is_ok;
    };

    return {
        validate: validate,
        validEmailToken: validEmailToken,

        init: initForm
    };
}();

module.exports = Validation;

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var localize = __webpack_require__(2).localize;
var getAppId = __webpack_require__(51).getAppId;

var buildOauthApps = function buildOauthApps(response) {
    if (!response || !response.oauth_apps) return {};
    var obj_oauth_apps = { 2: 'Binary.com Autoexpiry' };
    response.oauth_apps.forEach(function (app) {
        obj_oauth_apps[app.app_id] = app.name;
    });
    return obj_oauth_apps;
};

var addTooltip = function addTooltip(oauth_apps) {
    Object.keys(oauth_apps).forEach(function (key) {
        var tooltip_text = addAppIdName(key, oauth_apps[key]);
        if (tooltip_text) {
            $('.' + key).attr('data-balloon', tooltip_text);
        }
    });
};

var addAppIdName = function addAppIdName(app_id, app_name) {
    return +app_id === +getAppId() ? '' : localize('Transaction performed by [_1] (App ID: [_2])', [app_name || '', app_id]);
};

var showTooltip = function showTooltip(app_id, oauth_app_id) {
    var tooltip_text = addAppIdName(app_id, oauth_app_id);
    var tooltip_attr = tooltip_text ? 'data-balloon="' + tooltip_text + '"' : '';
    return app_id ? ' class="' + app_id + '" ' + tooltip_attr : '';
};

module.exports = {
    buildOauthApps: buildOauthApps,
    addTooltip: addTooltip,
    addAppIdName: addAppIdName,
    showTooltip: showTooltip
};

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var getFormNameBarrierCategory = __webpack_require__(31).getFormNameBarrierCategory;
var getLanguage = __webpack_require__(16).get;
var localize = __webpack_require__(2).localize;
var getPropertyValue = __webpack_require__(1).getPropertyValue;
var isEmptyObject = __webpack_require__(1).isEmptyObject;

/*
 * Contract object mocks the trading form we have on our website
 * It parses the contracts json we get from socket.send({contracts_for: 'R_50'})
 * and gives back barriers, startDate, durations etc
 *
 *
 * Usage:
 *
 * use `Contract.details` to populate this object
 *
 * then use
 *
 * `Contract.durations()` to get durations like seconds, hours etc
 * `Contract.open()` `Contract.close()`
 * `Contract.barriers` if applicable for current underlying
 */
var Contract = function () {
    var contract_type = {};

    var contract_details = {};
    var _barriers = {};
    var _durations = {};
    var start_dates = {};

    var _open = void 0,
        _close = void 0,
        _form = void 0,
        _barrier = void 0;

    var populateDurations = function populateDurations(current_contract) {
        var current_category = current_contract.contract_category;
        var expiry_type = current_contract.expiry_type;
        var barrier_category = current_contract.barrier_category;
        var start_type = current_contract.start_type;
        var max_duration = current_contract.max_contract_duration;
        var min_duration = current_contract.min_contract_duration;

        if (!_durations[expiry_type]) {
            _durations[expiry_type] = {};
        }

        if (!_durations[expiry_type][current_category]) {
            _durations[expiry_type][current_category] = {};
        }

        if (!_durations[expiry_type][current_category][barrier_category]) {
            _durations[expiry_type][current_category][barrier_category] = {};
        }

        if (!_durations[expiry_type][current_category][barrier_category][start_type]) {
            _durations[expiry_type][current_category][barrier_category][start_type] = {};
        }

        _durations[expiry_type][current_category][barrier_category][start_type].max_contract_duration = max_duration;

        _durations[expiry_type][current_category][barrier_category][start_type].min_contract_duration = min_duration;
    };

    var details = function details(form_name) {
        var contracts = Contract.contracts().contracts_for;

        if (!contracts) return;

        start_dates = { has_spot: 0, list: [] };
        _durations = {};
        _open = contracts.open;
        _close = contracts.close;

        var form_barrier = getFormNameBarrierCategory(form_name);
        _form = form_barrier.form_name;
        if (!_form) {
            return;
        }
        _barrier = form_barrier.barrier_category;

        contracts.available.forEach(function (current_obj) {
            var contract_category = current_obj.contract_category;
            // for callput and callputequals, populate duration for both
            if (_form === contract_category || /callput/.test(_form) && /callput/.test(contract_category)) {
                if (_barrier) {
                    if (_barrier === current_obj.barrier_category) {
                        populateDurations(current_obj);
                    }
                } else {
                    populateDurations(current_obj);
                }
            }
            if (_form === contract_category) {
                if (current_obj.forward_starting_options && current_obj.start_type === 'forward' && sessionStorage.formname !== 'higherlower') {
                    start_dates.list = current_obj.forward_starting_options;
                } else if (current_obj.start_type === 'spot') {
                    start_dates.has_spot = 1;
                }

                var symbol = current_obj.underlying_symbol;
                if (current_obj.barrier_category && current_obj.barrier_category !== 'non_financial') {
                    if (!getPropertyValue(_barriers, symbol)) {
                        _barriers[symbol] = {};
                    }
                    if (!getPropertyValue(_barriers[symbol], contract_category)) {
                        _barriers[symbol][contract_category] = {};
                    }
                    if (!getPropertyValue(_barriers[symbol][contract_category], current_obj.expiry_type)) {
                        _barriers[symbol][contract_category][current_obj.expiry_type] = {};
                    }
                    if (current_obj.barriers === 1) {
                        _barriers[symbol][contract_category][current_obj.expiry_type] = {
                            count: 1,
                            barrier: current_obj.barrier,
                            barrier_category: current_obj.barrier_category
                        };
                    } else if (current_obj.barriers === 2) {
                        _barriers[symbol][contract_category][current_obj.expiry_type] = {
                            count: 2,
                            barrier: current_obj.high_barrier,
                            barrier1: current_obj.low_barrier,
                            barrier_category: current_obj.barrier_category
                        };
                    }
                }

                if (!contract_type[contract_category]) {
                    contract_type[contract_category] = {};
                }

                var type = current_obj.contract_type;
                if (!getPropertyValue(contract_type[contract_category], type)) {
                    contract_type[contract_category][type] = localize(current_obj.contract_display);
                }
            }
        });

        if (_barrier) {
            if (_barriers && _barriers[_form] && _barriers[_form].barrier_category !== _barrier) {
                _barriers = {};
            }
        }
    };

    var getContractForms = function getContractForms() {
        var contracts = Contract.contracts().contracts_for;
        var trade_contract_forms = {};

        if (!contracts) return null;

        contracts.available.forEach(function (current_obj) {
            var contract_category = current_obj.contract_category;
            if (contract_category && !getPropertyValue(trade_contract_forms, contract_category)) {
                if (contract_category === 'callput') {
                    if (current_obj.barrier_category === 'euro_atm') {
                        trade_contract_forms.risefall = localize('Rise/Fall');
                    } else {
                        trade_contract_forms.higherlower = localize('Higher/Lower');
                    }
                } else {
                    trade_contract_forms[contract_category] = localize(current_obj.contract_category_display);
                    if (contract_category === 'digits') {
                        trade_contract_forms.matchdiff = localize('Matches/Differs');
                        if (getLanguage() !== 'ID') {
                            trade_contract_forms.evenodd = localize('Even/Odd');
                            trade_contract_forms.overunder = localize('Over/Under');
                        }
                    } else if (contract_category === 'lookback') {
                        trade_contract_forms.lookbackhigh = localize('High-Close');
                        trade_contract_forms.lookbacklow = localize('Close-Low');
                        trade_contract_forms.lookbackhighlow = localize('High-Low');
                    } else if (contract_category === 'reset') {
                        trade_contract_forms.resetcall = localize('Reset Call');
                        trade_contract_forms.resetput = localize('Reset Put');
                    }
                }
            }
        });

        if (isEmptyObject(trade_contract_forms)) return null;

        if (trade_contract_forms.risefall || trade_contract_forms.higherlower) {
            trade_contract_forms.updown = localize('Up/Down');
        }

        if (trade_contract_forms.endsinout || trade_contract_forms.staysinout) {
            trade_contract_forms.inout = localize('In/Out');
        }

        return trade_contract_forms;
    };

    return {
        details: details,
        contractForms: getContractForms,
        open: function open() {
            return _open;
        },
        close: function close() {
            return _close;
        },
        contracts: function contracts() {
            return contract_details;
        },
        durations: function durations() {
            return _durations;
        },
        startDates: function startDates() {
            return start_dates;
        },
        barriers: function barriers() {
            return _barriers;
        },
        contractType: function contractType() {
            return contract_type;
        },
        form: function form() {
            return _form;
        },
        barrier: function barrier() {
            return _barrier;
        },
        setContracts: function setContracts(data) {
            contract_details = data;
        }
    };
}();

module.exports = Contract;

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Contract = __webpack_require__(58);
var Defaults = __webpack_require__(23);

/*
 * Handles lookback option form
**/

var Lookback = function () {
    var displayLookback = function displayLookback() {
        var multiplier_element = document.getElementById('multiplier_row');
        var multiplier_input = document.getElementById('multiplier');
        var payout_element = document.getElementById('payout_row');

        if (Contract.form() === 'lookback') {
            multiplier_element.show();
            payout_element.hide(); // Hide payout
            if (Defaults.get('multiplier')) {
                multiplier_input.value = Defaults.get('multiplier');
            } else {
                Defaults.set('multiplier', multiplier_input.value);
            }
        } else {
            multiplier_element.hide();
            payout_element.show(); // Show payout
        }
    };

    var getFormula = function getFormula() {
        var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
        var mul = arguments[1];

        var value_map = {
            Multiplier: mul
        };
        var regex = /Multiplier/g;
        var replacer = function replacer(str) {
            return value_map[str] || str;
        };
        var formulaMapping = {
            LBFLOATPUT: 'Multiplier x (High - Close)'.replace(regex, replacer),
            LBFLOATCALL: 'Multiplier x (Close - Low)'.replace(regex, replacer),
            LBHIGHLOW: 'Multiplier x (High - Low)'.replace(regex, replacer)
        };

        return formulaMapping[type.toUpperCase()];
    };

    var isLookback = function isLookback(type) {
        return (/^(LBFLOATCALL|LBFLOATPUT|LBHIGHLOW)$/.test(type)
        );
    };

    var getBarrierLabel = function getBarrierLabel(type) {
        var barrier_map = {
            LBFLOATCALL: ['Low'],
            LBFLOATPUT: ['High'],
            LBHIGHLOW: ['High', 'Low']
        };
        return barrier_map[type] || ['Barrier'];
    };

    return {
        display: displayLookback,
        getFormula: getFormula,
        isLookback: isLookback,
        getBarrierLabel: getBarrierLabel
    };
}();

module.exports = Lookback;

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var moment = __webpack_require__(9);
var countDecimalPlaces = __webpack_require__(47).countDecimalPlaces;
var displayPriceMovement = __webpack_require__(47).displayPriceMovement;
var elementTextContent = __webpack_require__(4).elementTextContent;
var getElementById = __webpack_require__(4).getElementById;
var isVisible = __webpack_require__(4).isVisible;

/*
 * Tick object handles all the process/display related to tick streaming
 *
 * We request tick stream for particular underlying to update current spot
 *
 *
 * Usage:
 * use `Tick.detail` to populate this object
 *
 * then use
 *
 * `Tick.quote()` to get current spot quote
 * `Tick.id()` to get the unique for current stream
 * `Tick.epoch()` to get the tick epoch time
 * 'Tick.display()` to display current spot
 */
var Tick = function () {
    var _quote = '';
    var _id = '';
    var _epoch = '';
    var error_message = '';
    var _spots = {};

    var details = function details(data) {
        error_message = '';

        if (data) {
            if (data.error) {
                error_message = data.error.message;
            } else {
                var tick = data.tick;
                _quote = tick.quote;
                _id = tick.id;
                _epoch = tick.epoch;

                _spots[_epoch] = _quote;
                var epoches = Object.keys(_spots).sort(function (a, b) {
                    return a - b;
                });
                if (epoches.length > 20) {
                    delete _spots[epoches[0]];
                }
            }
        }
    };

    var display = function display() {
        $('#spot').fadeIn(200);
        var message = '';
        if (error_message) {
            message = error_message;
        } else {
            message = _quote;
        }

        var spot_element = getElementById('spot');
        if (parseFloat(message) !== +message) {
            spot_element.className = 'error';
        } else {
            spot_element.classList.remove('error');
            displayPriceMovement(spot_element, elementTextContent(spot_element), message);
            displayIndicativeBarrier();
        }

        elementTextContent(spot_element, message);
    };

    /*
     * display indicative barrier
     */
    var displayIndicativeBarrier = function displayIndicativeBarrier() {
        var current_tick = Tick.quote();

        var unit = getElementById('duration_units');
        var indicative_barrier_tooltip = getElementById('indicative_barrier_tooltip');
        var indicative_high_barrier_tooltip = getElementById('indicative_high_barrier_tooltip');
        var indicative_low_barrier_tooltip = getElementById('indicative_low_barrier_tooltip');
        var barrier_element = getElementById('barrier');
        var high_barrier_element = getElementById('barrier_high');
        var low_barrier_element = getElementById('barrier_low');
        var tooltip = getElementById('barrier_tooltip');
        var span = getElementById('barrier_span');
        var high_tooltip = getElementById('barrier_high_tooltip');
        var high_span = getElementById('barrier_high_span');
        var low_tooltip = getElementById('barrier_low_tooltip');
        var low_span = getElementById('barrier_low_span');

        var value = void 0;

        var end_time = getElementById('expiry_date');
        if (unit && (!isVisible(unit) || unit.value !== 'd') && current_tick && !isNaN(current_tick) && end_time && (!isVisible(end_time) || moment(end_time.getAttribute('data-value')).isBefore(moment().add(1, 'day'), 'day'))) {
            var decimal_places = countDecimalPlaces(current_tick);
            if (isVisible(indicative_barrier_tooltip) && String(barrier_element.value).match(/^[+-]/)) {
                var barrier_value = isNaN(parseFloat(barrier_element.value)) ? 0 : parseFloat(barrier_element.value);

                indicative_barrier_tooltip.textContent = (parseFloat(current_tick) + barrier_value).toFixed(decimal_places);
                tooltip.style.display = 'inherit';
                span.style.display = 'none';
            } else {
                elementTextContent(indicative_barrier_tooltip, '');
                tooltip.style.display = 'none';
                span.style.display = 'inherit';
            }

            if (isVisible(indicative_high_barrier_tooltip) && String(high_barrier_element.value).match(/^[+-]/)) {
                value = parseFloat(high_barrier_element.value);
                value = isNaN(value) ? 0 : value;
                indicative_high_barrier_tooltip.textContent = (parseFloat(current_tick) + value).toFixed(decimal_places);
                high_tooltip.style.display = 'inherit';
                high_span.style.display = 'none';
            } else {
                elementTextContent(indicative_high_barrier_tooltip, '');
                high_tooltip.style.display = 'none';
                high_span.style.display = 'inherit';
            }

            if (isVisible(indicative_low_barrier_tooltip) && String(low_barrier_element.value).match(/^[+-]/)) {
                value = parseFloat(low_barrier_element.value);
                value = isNaN(value) ? 0 : value;
                indicative_low_barrier_tooltip.textContent = (parseFloat(current_tick) + value).toFixed(decimal_places);
                low_tooltip.style.display = 'inherit';
                low_span.style.display = 'none';
            } else {
                elementTextContent(indicative_low_barrier_tooltip, '');
                low_tooltip.style.display = 'none';
                low_span.style.display = 'inherit';
            }
        } else {
            elementTextContent(indicative_barrier_tooltip, '');
            elementTextContent(indicative_high_barrier_tooltip, '');
            elementTextContent(indicative_low_barrier_tooltip, '');
        }
    };

    var clean = function clean() {
        _spots = {};
        _quote = '';
        $('#spot').fadeOut(200, function () {
            // resets spot movement coloring, will continue on the next tick responses
            $(this).removeClass('price_moved_down price_moved_up').text('');
        });
    };

    return {
        details: details,
        display: display,
        clean: clean,
        quote: function quote() {
            return _quote;
        },
        id: function id() {
            return _id;
        },
        epoch: function epoch() {
            return _epoch;
        },
        errorMessage: function errorMessage() {
            return error_message;
        },
        spots: function spots() {
            return _spots;
        },
        setQuote: function setQuote(q) {
            _quote = q;
        }
    };
}();

module.exports = Tick;

/***/ }),
/* 61 */,
/* 62 */,
/* 63 */,
/* 64 */,
/* 65 */,
/* 66 */,
/* 67 */,
/* 68 */,
/* 69 */,
/* 70 */,
/* 71 */,
/* 72 */,
/* 73 */,
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var moment = __webpack_require__(9);
var getLanguage = __webpack_require__(16).get;
var LocalStore = __webpack_require__(6).LocalStore;
var getPropertyValue = __webpack_require__(1).getPropertyValue;
var getStaticHash = __webpack_require__(1).getStaticHash;
var isEmptyObject = __webpack_require__(1).isEmptyObject;

/*
 * Caches WS responses to reduce delay time and number of requests
 * Stores data in LocalStore which is the first one available in: localStorage, sessionStorage, InScriptStore
 *
 * 1. It caches only the response of those calls which determined in `config`
 * 2. It doesn't cache responses which returned error
 * 3. The value is requested by BinarySocket,
 *    if this returns a value according to the logic here, socket code take it as response
 *    but also triggers an async `send` request, to keep the cache updated for next time
 * 4. Uses client's time to set and check for expiry, as the expire durations are not so long to need a more precise one
 *    (And doesn't worth to wait for the response of time call)
 * 5. Some responses should be cached by a particular value from request (e.g. contracts_for_frxAUDJPY)
 *    so there can be more than one value for a particular call
 * 6. Clears the whole cache regardless their expire time on the following events:
 *    6.1. Client changes: login / logout / switch loginid
 *    6.2. Detect a new release (static hash changed)
 */
var SocketCache = function () {
    // keys are msg_type
    // expire: how long to keep the value (in minutes)
    // map_to: to store different responses of the same key, should be array of:
    //     string  : the property value from echo_req
    //     function: return value of the function
    var config = {
        payout_currencies: { expire: 10 },
        active_symbols: { expire: 10, map_to: ['product_type', 'landing_company', getLanguage] },
        contracts_for: { expire: 10, map_to: ['contracts_for', 'product_type', 'currency'] },
        exchange_rates: { expire: 60, map_to: ['base_currency'] }
    };

    var storage_key = 'ws_cache';

    var data_obj = {};

    var set = function set(response) {
        var msg_type = response.msg_type;

        if (!config[msg_type]) return;

        // prevent unwanted page behaviour
        // if a cached version already exists but it gives an error after being called for updating the cache
        var cashed_response = get(response.echo_req);
        if ((response.error || !response[msg_type]) && cashed_response && !cashed_response.error) {
            clear();
            window.location.reload();
            return;
        }

        var key = makeKey(response.echo_req, msg_type);
        var expires = moment().add(config[msg_type].expire, 'm').valueOf();

        if (!data_obj.static_hash) {
            data_obj.static_hash = getStaticHash();
        }

        data_obj[key] = { value: response, expires: expires };
        LocalStore.setObject(storage_key, data_obj);
    };

    var get = function get(request, msg_type) {
        var response = void 0;

        if (isEmptyObject(data_obj)) {
            data_obj = LocalStore.getObject(storage_key);
            if (isEmptyObject(data_obj)) return undefined;
        }

        if (data_obj.static_hash !== getStaticHash()) {
            // new release
            clear();
        }

        var key = makeKey(request, msg_type);
        var response_obj = getPropertyValue(data_obj, key) || {};

        if (moment().isBefore(response_obj.expires)) {
            response = response_obj.value;
        } else {
            // remove if expired
            remove(key);
        }

        return response;
    };

    var makeKey = function makeKey(source_obj, msg_type) {
        var key = msg_type || Object.keys(source_obj).find(function (type) {
            return config[type];
        });

        if (key && !isEmptyObject(source_obj)) {
            ((config[key] || {}).map_to || []).forEach(function (map_key) {
                var value = typeof map_key === 'function' ? map_key() : source_obj[map_key];
                key += map_key ? '_' + (value || '') : '';
            });
        }

        return key;
    };

    var remove = function remove(key, should_match_all) {
        if (should_match_all) {
            Object.keys(data_obj).forEach(function (data_key) {
                if (data_key.indexOf(key) !== -1) {
                    delete data_obj[data_key];
                }
            });
        } else if (key in data_obj) {
            delete data_obj[key];
        }
        LocalStore.setObject(storage_key, data_obj);
    };

    var clear = function clear() {
        LocalStore.remove(storage_key);
        data_obj = {};
    };

    return {
        set: set,
        get: get,
        remove: remove,
        clear: clear
    };
}();

module.exports = SocketCache;

/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var showPopup = __webpack_require__(121);
var elementInnerHtml = __webpack_require__(4).elementInnerHtml;
var localize = __webpack_require__(2).localize;
var urlFor = __webpack_require__(8).urlFor;

var Dialog = function () {
    var baseDialog = function baseDialog(options) {
        var is_alert = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        return new Promise(function (resolve) {
            showPopup({
                url: urlFor('dialog'),
                popup_id: options.id,
                form_id: '#frm_confirm',
                content_id: '#dialog_content',
                additionalFunction: function additionalFunction(container) {
                    var el_dialog = container;
                    var el_btn_ok = container.querySelector('#btn_ok');
                    var el_btn_cancel = container.querySelector('#btn_cancel');

                    if (!el_dialog) return;

                    var message = Array.isArray(options.message) ? options.message.join('<p />') : options.message;
                    elementInnerHtml(container.querySelector('#dialog_message'), localize(message));

                    if (is_alert) {
                        el_btn_cancel.classList.add('invisible');
                    } else {
                        el_btn_cancel.addEventListener('click', function () {
                            el_dialog.remove();
                            if (typeof options.onAbort === 'function') {
                                options.onAbort();
                            }
                            resolve(false);
                        });
                    }

                    el_btn_ok.addEventListener('click', function () {
                        el_dialog.remove();
                        if (typeof options.onConfirm === 'function') {
                            options.onConfirm();
                        }
                        resolve(true);
                    });
                }
            });
        });
    };

    return {
        alert: function alert(options) {
            return baseDialog(options, true);
        },
        confirm: function confirm(options) {
            return baseDialog(options);
        }
    };
}();

module.exports = Dialog;

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Table = function () {
    /**
     *
     * @param {Array[]} body ordered data to pump into table body
     * @param {Object} metadata object containing metadata of table
     * @param {String[]} metadata.cols cols of table
     * @param {String} metadata.id table id
     * @param {String[]} [metadata.tableClass] class used in html
     * @param {String[]} [header] string to be used as Header in table, if not stated then table will not have Header
     * @param {String[]} [footer] string to be used as footer, to have empty footer, use an empty element in array
     * eg. ["", "halo", ""] will have 3 elements in footer, 2 of them being empty
     */
    var createFlexTable = function createFlexTable(body, metadata, header, footer) {
        var $table_container = $('<div></div>', { class: 'table-container' });
        var $table = $('<table></table>', { class: metadata.tableClass || '', id: metadata.id });
        var $body = createFlexTableTopGroup(body, metadata.cols, 'body');

        if (header) {
            var $header = createFlexTableTopGroup([header], metadata.cols, 'header');
            $header.appendTo($table);
        }

        $body.appendTo($table);

        if (footer) {
            var $footer = createFlexTableTopGroup([footer], metadata.cols, 'footer');
            $footer.appendTo($table);
        }

        $table.appendTo($table_container);

        return $table_container;
    };

    /**
     *
     * @param {object[][]} data header strings
     * @param {String[]} metadata cols name
     * @param {'header'|'footer'|'body'} opt optional arg, specifies type of element to create. default to header
     */
    var createFlexTableTopGroup = function createFlexTableTopGroup(data, metadata, opt) {
        var $outer = function () {
            switch (opt) {
                case 'body':
                    return $('<tbody></tbody>');
                case 'footer':
                    return $('<tfoot></tfoot>');
                default:
                    return $('<thead></thead>');
            }
        }();

        for (var i = 0; i < data.length; i++) {
            var inner_type = opt === 'body' ? 'data' : 'header';
            var $tr = createFlexTableRow(data[i], metadata, inner_type);
            $tr.appendTo($outer);
        }

        return $outer;
    };

    /**
     *
     * @param {object[]} data
     * @param {String[]} metadata cols name
     * @param {'header'|'data'} opt optional, default to "header"
     */
    var createFlexTableRow = function createFlexTableRow(data, metadata, opt) {
        if (data.length !== metadata.length) {
            throw new Error('metadata and data does not match');
        }

        var is_data = opt === 'data';

        var $tr = $('<tr></tr>');
        for (var i = 0; i < data.length; i++) {
            var class_name = metadata[i].toLowerCase().replace(/\s/g, '-');
            var row_element = is_data ? $('<td></td>', { class: class_name, html: data[i] }) : $('<th></th>', { class: class_name, html: data[i] });
            row_element.appendTo($tr);
        }

        return $tr;
    };

    var clearTableBody = function clearTableBody(id) {
        var tbody = document.querySelector('#' + id + ' > tbody');
        while (tbody && tbody.firstElementChild) {
            tbody.removeChild(tbody.firstElementChild);
        }
    };

    /**
     *
     * @param {String} id table id
     * @param {Object[]} data array of data to be transform to row
     * @param {Function} rowGenerator takes in one arg, and convert it into row to be append to table body
     */
    var appendTableBody = function appendTableBody(id, data, rowGenerator) {
        var tbody = document.querySelector('#' + id + ' > tbody');
        if (!tbody) return;
        var doc_frag = document.createDocumentFragment();
        data.map(function (ele) {
            var row = rowGenerator(ele);
            doc_frag.appendChild(row);
        });

        tbody.appendChild(doc_frag);
    };

    return {
        createFlexTable: createFlexTable,
        createFlexTableRow: createFlexTableRow,
        clearTableBody: clearTableBody,
        appendTableBody: appendTableBody
    };
}();

module.exports = Table;

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var moment = __webpack_require__(9);
var MBDefaults = __webpack_require__(36);
var Client = __webpack_require__(3);
var SocketCache = __webpack_require__(74);
var getLanguage = __webpack_require__(16).get;
var localize = __webpack_require__(2).localize;
var padLeft = __webpack_require__(17).padLeft;
var toTitleCase = __webpack_require__(17).toTitleCase;
var isEmptyObject = __webpack_require__(1).isEmptyObject;

/*
 * Contract object mocks the trading form we have on our website
 * It parses the contracts json we get from socket.send({contracts_for: 'R_50'})
 */
var MBContract = function () {
    var contracts_for_response = void 0,
        remaining_timeout = void 0,
        current_time_left = void 0,
        $period = void 0,
        $durations = void 0,
        $duration = void 0,
        $count_down_timer = void 0;

    var hidden_class = 'invisible';

    var duration_map = {
        m: 'minute',
        h: 'h',
        d: 'day',
        W: 'week',
        M: 'month',
        Y: 'year'
    };

    var durationText = function durationText(duration, is_jp_client) {
        var dur = duration;
        if (dur && is_jp_client) {
            dur = dur.replace(/([a-z])/, '$1<br>');
            Object.keys(duration_map).forEach(function (key) {
                dur = dur.replace(key, localize(duration_map[key] + (+dur[0] === 1 || /h/.test(key) ? '' : 's')));
            });
        }
        return dur.toUpperCase();
    };

    var periodText = function periodText(trading_period, is_jp_client) {
        var date_start = void 0,
            date_expiry = void 0,
            duration = void 0;
        if ((typeof trading_period === 'undefined' ? 'undefined' : _typeof(trading_period)) === 'object') {
            date_start = trading_period.date_start.epoch;
            date_expiry = trading_period.date_expiry.epoch;
            duration = trading_period.duration;
        } else {
            date_start = trading_period.split('_')[0];
            date_expiry = trading_period.split('_')[1];
            duration = trading_period.split('_')[2];
        }
        duration = duration ? duration.replace('0d', '1d') : '';

        var toDate = function toDate(date) {
            var text_value = moment.utc(date * 1000).utcOffset(is_jp_client ? '+09:00' : '+00:00').locale(getLanguage().toLowerCase());
            if (is_jp_client) {
                text_value = text_value.format('MMM Do, HH:mm').replace(/08:59/, '09:00«');
            } else {
                text_value = text_value.format('HH:mm');
            }
            return text_value;
        };
        return {
            end: is_jp_client ? toDate(date_expiry) : [toDate(date_start), toDate(date_expiry)].join('-') + ' GMT',
            duration: durationText(duration, is_jp_client)
        };
    };

    var populatePeriods = function populatePeriods(should_rebuild) {
        if (!contracts_for_response || isEmptyObject(contracts_for_response)) return;
        var trading_period = void 0,
            start_end = void 0;
        var trading_period_array = [];
        var available_contracts = contracts_for_response.contracts_for.available;
        var selected_option = MBDefaults.get('category');
        $period = $('#period');
        if (!selected_option || !available_contracts) return;
        for (var i = 0; i < available_contracts.length; i++) {
            if (available_contracts[i].contract_category === selected_option) {
                trading_period = available_contracts[i].trading_period;
                if (!trading_period) return;
                start_end = [trading_period.date_start.epoch, trading_period.date_expiry.epoch, trading_period.duration].join('_');
                if (trading_period_array.indexOf(start_end) < 0) {
                    trading_period_array.push(start_end);
                }
            }
        }
        trading_period_array.sort(sortByExpiryTime);
        var $list = $period.find('.list');
        if (should_rebuild) {
            $list.empty();
        }
        var is_jp_client = Client.isJPClient();

        var duration_class = 'gr-3 gr-no-gutter';
        var end_time_class = is_jp_client ? 'gr-6 gr-5-m' : 'gr-6';
        var remain_time_class = is_jp_client ? 'gr-3 gr-4-m gr-no-gutter' : 'gr-6';
        var makeItem = function makeItem(period) {
            var text = periodText(period, is_jp_client);

            var $div_period = $('<div/>', { value: period, class: 'gr-row' });

            var $div_end_time = $('<div/>', { class: 'end ' + end_time_class, text: text.end });
            var $div_remain_time = $('<div/>', { class: 'remaining-time ' + remain_time_class });

            if (is_jp_client) {
                var $div_duration = $('<div/>', { class: 'duration ' + duration_class, html: text.duration });
                $div_period.append($div_duration);
            }

            $div_period.append($div_end_time).append($div_remain_time);

            return $div_period;
        };
        if ($list.children().length === 0) {
            // populate for the first time
            var default_value = MBDefaults.get('period');
            if (trading_period_array.indexOf(default_value) === -1) default_value = '';
            trading_period_array.forEach(function (period, idx) {
                var is_current = !default_value && idx === 0 || period === default_value;
                var $current = makeItem(period);
                $list.append($current);
                if (is_current) {
                    setCurrentItem($period, period);
                }
            });
            MBDefaults.set('period', $period.attr('value'));
            displayRemainingTime(true, is_jp_client);
        } else {
            // update options
            var existing_array = [];
            var missing_array = [];
            $list.find('> div').each(function () {
                existing_array.push($(this).val());
            });

            // add new periods to dropdown
            trading_period_array.forEach(function (period) {
                if (existing_array.indexOf(period) < 0) {
                    missing_array.push(period);
                }
            });
            if (missing_array.length > 0) {
                var $new_item = void 0;
                existing_array = existing_array.concat(missing_array).sort(sortByExpiryTime);
                existing_array.forEach(function (existing, idx) {
                    if ($list.find('[value="' + existing + '"]').length < 1) {
                        $new_item = makeItem(existing);
                        if (idx < 1) {
                            $($new_item).insertBefore($list.children().eq(idx));
                        } else {
                            $($new_item).insertAfter($list.children().eq(idx - 1));
                        }
                    }
                });
            }

            // remove periods that no longer exist
            existing_array.forEach(function (period) {
                if (trading_period_array.indexOf(period) < 0) {
                    $list.find('[value="' + period + '"]').remove();
                }
            });
        }
    };

    var displayRemainingTime = function displayRemainingTime(should_recalculate, is_jp_client) {
        if (typeof $durations === 'undefined' || should_recalculate) {
            // period_value = MBDefaults.get('period');
            $period = $('#period');
            $durations = $period.find('.list > div, .current > div');
        }
        if (!$durations) return;
        $durations.each(function (idx) {
            $duration = $($durations[idx]);
            $count_down_timer = $duration.find('.remaining-time');

            var time_left = parseInt($duration.attr('value').split('_')[1]) - window.time.unix();
            if (time_left <= 0) {
                // clear the expired contracts_for response
                SocketCache.remove('contracts_for', 1);
                location.reload();
            } else if (time_left < 120) {
                $count_down_timer.addClass('alert');
            }
            var remaining_month_day_string = [];
            var remaining_time_string = [];

            var duration = moment.duration(time_left * 1000);

            var all_durations = {
                month: duration.months(),
                day: duration.days(),
                hour: duration.hours(),
                minute: duration.minutes(),
                second: duration.seconds()
            };

            var duration_unit_to_show = void 0;
            Object.keys(all_durations).forEach(function (key) {
                if (/month|day/.test(key)) {
                    if (all_durations[key]) {
                        if (is_jp_client) {
                            duration_unit_to_show = key[0];
                            remaining_month_day_string.push(all_durations[key] + localize(toTitleCase(duration_unit_to_show)));
                        } else {
                            duration_unit_to_show = all_durations[key] === 1 ? key : key + 's';
                            remaining_month_day_string.push(all_durations[key] + ' ' + localize(toTitleCase(duration_unit_to_show)));
                        }
                    }
                } else {
                    remaining_time_string.push(padLeft(all_durations[key] || 0, 2, '0'));
                }
            });

            $count_down_timer.text(remaining_month_day_string.join(is_jp_client ? '' : ' ') + ' ' + remaining_time_string.join(':'));
        });
        current_time_left = parseInt($period.attr('value').split('_')[1]) - window.time.unix();
        if (current_time_left < 120) {
            // make all price buttons inactive if less than 2 minutes remaining
            $('.price-button').addClass('inactive');
        }
        if (remaining_timeout) clearRemainingTimeout();
        remaining_timeout = setTimeout(function () {
            displayRemainingTime(false, is_jp_client);
        }, 500);
    };

    var clearRemainingTimeout = function clearRemainingTimeout() {
        clearTimeout(remaining_timeout);
    };

    var sortByExpiryTime = function sortByExpiryTime(first, second) {
        var a = first.split('_');
        var b = second.split('_');

        var duration1 = a[1] - a[0];
        var duration2 = b[1] - b[0];

        return a[1] === b[1] ? duration1 - duration2 : a[1] - b[1];
    };

    var categories = [{ value: 'callput', type1: 'PUT', type2: 'CALLE' }, { value: 'touchnotouch', type1: 'ONETOUCH', type2: 'NOTOUCH' }, { value: 'endsinout', type1: 'EXPIRYRANGEE', type2: 'EXPIRYMISS' }, { value: 'staysinout', type1: 'RANGE', type2: 'UPORDOWN' }];

    var populateOptions = function populateOptions(should_rebuild) {
        if (!contracts_for_response || isEmptyObject(contracts_for_response)) return;
        var available_contracts = contracts_for_response.contracts_for.available;

        var $category = $('#category');
        var $list = $category.find('.list');
        if (should_rebuild) {
            $list.empty();
        }
        if ($list.children().length === 0) {
            var default_value = MBDefaults.get('category');
            var is_jp_client = Client.isJPClient();
            categories.forEach(function (category, idx) {
                if (available_contracts.find(function (contract) {
                    return contract.contract_category === category.value;
                })) {
                    var is_current = !default_value && idx === 0 || category.value === default_value;
                    var el_contract_type = void 0;
                    if (is_jp_client) {
                        el_contract_type = '<span class="contract-type gr-6 ' + category.type1 + '"><span>' + localize(getTemplate(category.type1).name) + '</span></span>\n                             <span class="contract-type gr-6 ' + category.type2 + ' negative-color"><span>' + localize(getTemplate(category.type2).name) + '</span></span>';
                    } else {
                        el_contract_type = '<div class="category-wrapper gr-6"><div class="contract-type ' + category.type2 + '" /><div>' + localize(getTemplate(category.type2).name) + '</div></div>\n                             <div class="category-wrapper gr-6"><div class="contract-type ' + category.type1 + ' negative-color" /><div>' + localize(getTemplate(category.type1).name) + '</div></div>';
                    }
                    var $current = $('<div/>', {
                        value: category.value,
                        html: el_contract_type,
                        class: 'gr-row'
                    });
                    $list.append($current);
                    if (is_current) {
                        setCurrentItem($category, category.value);
                    }
                }
            });
            MBDefaults.set('category', $category.attr('value'));
        }
        populatePeriods(should_rebuild);
    };

    var getCurrentContracts = function getCurrentContracts() {
        if (!contracts_for_response || isEmptyObject(contracts_for_response)) return [];
        var contracts = [];
        var periods = MBDefaults.get('period').split('_');
        contracts_for_response.contracts_for.available.forEach(function (c) {
            // only allow callput/callputequal contracts here
            if (/callput/.test(c.contract_category) && c.trading_period && +c.trading_period.date_start.epoch === +periods[0] && +c.trading_period.date_expiry.epoch === +periods[1]) {
                contracts.push(c);
            }
        });
        return contracts;
    };

    var getTemplate = function getTemplate(contract_type) {
        var is_jp_client = Client.isJPClient();
        var templates = {
            PUT: {
                opposite: 'CALLE',
                order: is_jp_client ? 0 : 1,
                name: 'Lower',
                description: '[_1] [_2] payout if [_3] is strictly lower than Barrier at close on [_4].'
            },
            CALLE: {
                opposite: 'PUT',
                order: is_jp_client ? 1 : 0,
                name: 'Higher',
                description: '[_1] [_2] payout if [_3] is strictly higher than or equal to Barrier at close on [_4].'
            },
            ONETOUCH: {
                opposite: 'NOTOUCH',
                order: 0,
                name: 'Touches',
                description: '[_1] [_2] payout if [_3] touches Barrier through close on [_4].'
            },
            NOTOUCH: {
                opposite: 'ONETOUCH',
                order: 1,
                name: 'Does Not Touch',
                description: '[_1] [_2] payout if [_3] does not touch Barrier through close on [_4].'
            },
            EXPIRYRANGEE: {
                opposite: 'EXPIRYMISS',
                order: 0,
                name: 'Ends Between',
                description: '[_1] [_2] payout if [_3] ends on or between low and high values of Barrier at close on [_4].'
            },
            EXPIRYMISS: {
                opposite: 'EXPIRYRANGEE',
                order: 1,
                name: 'Ends Outside',
                description: '[_1] [_2] payout if [_3] ends outside low and high values of Barrier at close on [_4].'
            },
            RANGE: {
                opposite: 'UPORDOWN',
                order: 0,
                name: 'Stays Between',
                description: '[_1] [_2] payout if [_3] stays between low and high values of Barrier through close on [_4].'
            },
            UPORDOWN: {
                opposite: 'RANGE',
                order: 1,
                name: 'Goes Outside',
                description: '[_1] [_2] payout if [_3] goes outside of low and high values of Barrier through close on [_4].'
            }
        };
        return contract_type ? templates[contract_type] : templates;
    };

    var getCurrency = function getCurrency() {
        return Client.get('currency') || $('#currency').attr('value') || 'JPY';
    };

    var setCurrentItem = function setCurrentItem($container, value, is_underlying) {
        var $selected = $container.find('.list [value="' + value + '"]');
        if ($selected.length) {
            if (is_underlying) {
                $container.attr('value', value).find('> .current').find('img').attr('src', $selected.find('img').attr('src')).end().find('.name').text($selected.text());
            } else {
                $container.attr('value', value).find('> .current').html($selected.clone());
            }

            $container.find('.list .' + hidden_class).removeClass(hidden_class);
            $selected.addClass(hidden_class);
        }
    };

    return {
        populatePeriods: populatePeriods,
        populateOptions: populateOptions,
        displayRemainingTime: displayRemainingTime,
        getCurrentContracts: getCurrentContracts,
        getTemplate: getTemplate,
        getCurrency: getCurrency,
        setCurrentItem: setCurrentItem,
        getRemainingTime: function getRemainingTime() {
            return current_time_left;
        },
        getContractsResponse: function getContractsResponse() {
            return contracts_for_response;
        },
        setContractsResponse: function setContractsResponse(contracts_for) {
            contracts_for_response = contracts_for;
        },
        onUnload: function onUnload() {
            clearRemainingTimeout();contracts_for_response = {};$durations = undefined;
        }
    };
}();

module.exports = MBContract;

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var CommonFunctions = __webpack_require__(4);
var localize = __webpack_require__(2).localize;

/*
 * Handle Reset option
 */
var Reset = function () {
    /*
     * Displays reset time
     */
    var displayResetTime = function displayResetTime(duration_value, duration_unit) {
        var reset_time_str = '';
        var val = void 0;

        var mid_point = duration_value / 2; // a Reset happens at midpoint

        var duration_map = {
            s: 'seconds',
            m: 'minutes',
            h: 'hour', // currently the max possible Reset time for h is 1hr
            t: 'ticks'
        };

        if (mid_point % 1 !== 0 && /[mh]/.test(duration_unit)) {
            val = Math.floor(mid_point);
            switch (duration_unit) {
                case 'm':
                    reset_time_str = (val ? val + ' ' + localize('minutes') : '') + ' 30 ' + localize('seconds');
                    break;
                case 'h':
                    reset_time_str = (val || '') + ' 30 ' + localize('minutes');
                    break;
                default: // no default
            }
        } else {
            val = duration_unit === 't' ? Math.floor(mid_point) : Math.ceil(mid_point);
            reset_time_str = val + ' ' + localize(duration_map[duration_unit]);
        }

        CommonFunctions.getElementById('reset_time').html(localize('The reset time is [_1]', [reset_time_str])).setAttribute('style', '');
    };

    var hideResetTime = function hideResetTime() {
        CommonFunctions.getElementById('reset_time').style.display = 'none';
    };

    var isNewBarrier = function isNewBarrier(entry_barrier, current_barrier) {
        return +entry_barrier !== +current_barrier;
    };

    var isReset = function isReset(contract_type) {
        return (/reset/i.test(contract_type)
        );
    };

    return {
        displayResetTime: displayResetTime,
        hideResetTime: hideResetTime,
        isNewBarrier: isNewBarrier,
        isReset: isReset
    };
}();

module.exports = Reset;

/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ActiveSymbols = __webpack_require__(119);

/*
 * Symbols object parses the active_symbols json that we get from socket.send({active_symbols: 'brief'}
 * and outputs in usable form, it gives markets, underlyings
 *
 *
 * Usage:
 *
 * use `Symbols.details` to populate this object first
 *
 * then use
 *
 * `Symbols.markets` to get markets like Forex, Random etc
 * `Symbols.underlyings` to get underlyings
 *
 */

var Symbols = function () {
    var trade_markets = {};
    var trade_markets_list = {};
    var trade_underlyings = {};
    var names = {};

    var details = function details(data) {
        var all_symbols = data.active_symbols;
        trade_markets = ActiveSymbols.getMarkets(all_symbols);
        trade_markets_list = ActiveSymbols.getMarketsList(all_symbols);
        trade_underlyings = ActiveSymbols.getTradeUnderlyings(all_symbols);
        names = ActiveSymbols.getSymbolNames(all_symbols);
    };

    return {
        details: details,
        markets: function markets(list) {
            return list ? trade_markets_list : trade_markets;
        },
        getName: function getName(symbol) {
            return names[symbol];
        },
        underlyings: function underlyings() {
            return trade_underlyings;
        },
        getAllSymbols: function getAllSymbols() {
            return names;
        }
    };
}();

module.exports = Symbols;

/***/ }),
/* 80 */,
/* 81 */,
/* 82 */,
/* 83 */,
/* 84 */,
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var moment = __webpack_require__(9);
var isCryptocurrency = __webpack_require__(118).isCryptocurrency;
var SocketCache = __webpack_require__(74);
var LocalStore = __webpack_require__(6).LocalStore;
var State = __webpack_require__(6).State;
var getPropertyValue = __webpack_require__(1).getPropertyValue;
var isEmptyObject = __webpack_require__(1).isEmptyObject;

var ClientBase = function () {
    var storage_key = 'client.accounts';
    var client_object = {};
    var current_loginid = void 0;

    var init = function init() {
        current_loginid = LocalStore.get('active_loginid');
        client_object = getAllAccountsObject();
    };

    var isLoggedIn = function isLoggedIn() {
        return !isEmptyObject(getAllAccountsObject()) && get('loginid') && get('token');
    };

    var isValidLoginid = function isValidLoginid() {
        if (!isLoggedIn()) return true;
        var valid_login_ids = new RegExp('^(MX|MF|VRTC|MLT|CR|FOG)[0-9]+$', 'i');
        return getAllLoginids().every(function (loginid) {
            return valid_login_ids.test(loginid);
        });
    };

    /**
     * Stores the client information in local variable and localStorage
     *
     * @param {String} key                 The property name to set
     * @param {String|Number|Object} value The regarding value
     * @param {String|null} loginid        The account to set the value for
     */
    var set = function set(key, value) {
        var loginid = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : current_loginid;

        if (key === 'loginid' && value !== current_loginid) {
            LocalStore.set('active_loginid', value);
            current_loginid = value;
        } else {
            if (!(loginid in client_object)) {
                client_object[loginid] = {};
            }
            client_object[loginid][key] = value;
            LocalStore.setObject(storage_key, client_object);
        }
    };

    /**
     * Returns the client information
     *
     * @param {String|null} key     The property name to return the value from, if missing returns the account object
     * @param {String|null} loginid The account to return the value from
     */
    var get = function get(key) {
        var loginid = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : current_loginid;

        var value = void 0;
        if (key === 'loginid') {
            value = loginid || LocalStore.get('active_loginid');
        } else {
            var current_client = client_object[loginid] || getAllAccountsObject()[loginid] || client_object;

            value = key ? current_client[key] : current_client;
        }
        if (!Array.isArray(value) && (+value === 1 || +value === 0 || value === 'true' || value === 'false')) {
            value = JSON.parse(value || false);
        }
        return value;
    };

    var getAllAccountsObject = function getAllAccountsObject() {
        return LocalStore.getObject(storage_key);
    };

    var getAllLoginids = function getAllLoginids() {
        return Object.keys(getAllAccountsObject());
    };

    var getAccountType = function getAccountType() {
        var loginid = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : current_loginid;

        var account_type = void 0;
        if (/^VR/.test(loginid)) account_type = 'virtual';else if (/^MF/.test(loginid)) account_type = 'financial';else if (/^MLT|MX/.test(loginid)) account_type = 'gaming';
        return account_type;
    };

    var isAccountOfType = function isAccountOfType(type) {
        var loginid = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : current_loginid;
        var only_enabled = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

        var this_type = getAccountType(loginid);
        return (type === 'virtual' && this_type === 'virtual' || type === 'real' && this_type !== 'virtual' || type === this_type) && (only_enabled ? !get('is_disabled', loginid) : true);
    };

    var getAccountOfType = function getAccountOfType(type, only_enabled) {
        var id = getAllLoginids().find(function (loginid) {
            return isAccountOfType(type, loginid, only_enabled);
        });
        return id ? Object.assign({ loginid: id }, get(null, id)) : {};
    };

    var hasAccountType = function hasAccountType(type, only_enabled) {
        return !isEmptyObject(getAccountOfType(type, only_enabled));
    };

    // only considers currency of real money accounts
    // @param {String} type = crypto|fiat
    var hasCurrencyType = function hasCurrencyType(type) {
        var loginids = getAllLoginids();
        if (type === 'crypto') {
            // find if has crypto currency account
            return loginids.find(function (loginid) {
                return !get('is_virtual', loginid) && isCryptocurrency(get('currency', loginid));
            });
        }
        // else find if have fiat currency account
        return loginids.find(function (loginid) {
            return !get('is_virtual', loginid) && !isCryptocurrency(get('currency', loginid));
        });
    };

    var types_map = {
        virtual: 'Virtual',
        gaming: 'Gaming',
        financial: 'Investment'
    };

    var getAccountTitle = function getAccountTitle(loginid) {
        return types_map[getAccountType(loginid)] || 'Real';
    };

    var responseAuthorize = function responseAuthorize(response) {
        var authorize = response.authorize;
        set('email', authorize.email);
        set('currency', authorize.currency);
        set('is_virtual', +authorize.is_virtual);
        set('session_start', parseInt(moment().valueOf() / 1000));
        set('landing_company_shortcode', authorize.landing_company_name);
        updateAccountList(authorize.account_list);
    };

    var updateAccountList = function updateAccountList(account_list) {
        account_list.forEach(function (account) {
            set('excluded_until', account.excluded_until || '', account.loginid);
            Object.keys(account).forEach(function (param) {
                var param_to_set = param === 'country' ? 'residence' : param;
                var value_to_set = typeof account[param] === 'undefined' ? '' : account[param];
                if (param_to_set !== 'loginid') {
                    set(param_to_set, value_to_set, account.loginid);
                }
            });
        });
    };

    var shouldAcceptTnc = function shouldAcceptTnc() {
        if (get('is_virtual')) return false;
        var website_tnc_version = State.getResponse('website_status.terms_conditions_version');
        var client_tnc_status = State.getResponse('get_settings.client_tnc_status');
        return typeof client_tnc_status !== 'undefined' && client_tnc_status !== website_tnc_version;
    };

    var clearAllAccounts = function clearAllAccounts() {
        current_loginid = undefined;
        client_object = {};
        LocalStore.setObject(storage_key, client_object);
    };

    var setNewAccount = function setNewAccount(options) {
        if (!options.email || !options.loginid || !options.token) {
            return false;
        }

        SocketCache.clear();
        localStorage.setItem('GTM_new_account', '1');

        set('token', options.token, options.loginid);
        set('email', options.email, options.loginid);
        set('is_virtual', +options.is_virtual, options.loginid);
        set('loginid', options.loginid);

        return true;
    };

    var currentLandingCompany = function currentLandingCompany() {
        var landing_company_response = State.getResponse('landing_company') || {};
        var this_shortcode = get('landing_company_shortcode');
        var landing_company_prop = Object.keys(landing_company_response).find(function (key) {
            return this_shortcode === landing_company_response[key].shortcode;
        });
        return landing_company_response[landing_company_prop] || {};
    };

    var shouldCompleteTax = function shouldCompleteTax() {
        return isAccountOfType('financial') && !/crs_tin_information/.test((State.getResponse('get_account_status') || {}).status);
    };

    var getMT5AccountType = function getMT5AccountType(group) {
        return group ? group.replace('\\', '_').replace(/_(\d+|master)/, '') : '';
    }; // remove manager id or master distinction from group

    var getBasicUpgradeInfo = function getBasicUpgradeInfo() {
        var upgradeable_landing_companies = State.getResponse('authorize.upgradeable_landing_companies');

        var can_open_multi = false;
        var type = void 0,
            can_upgrade_to = void 0;

        if ((upgradeable_landing_companies || []).length) {
            var current_landing_company = get('landing_company_shortcode');

            can_open_multi = upgradeable_landing_companies.indexOf(current_landing_company) !== -1;

            // only show upgrade message to landing companies other than current
            var canUpgrade = function canUpgrade() {
                for (var _len = arguments.length, landing_companies = Array(_len), _key = 0; _key < _len; _key++) {
                    landing_companies[_key] = arguments[_key];
                }

                return landing_companies.find(function (landing_company) {
                    return landing_company !== current_landing_company && upgradeable_landing_companies.indexOf(landing_company) !== -1;
                });
            };

            can_upgrade_to = canUpgrade('costarica', 'iom', 'malta', 'maltainvest', 'japan');
            if (can_upgrade_to) {
                type = can_upgrade_to === 'maltainvest' ? 'financial' : 'real';
            }
        }

        return {
            type: type,
            can_upgrade: !!can_upgrade_to,
            can_upgrade_to: can_upgrade_to,
            can_open_multi: can_open_multi
        };
    };

    var getLandingCompanyValue = function getLandingCompanyValue(loginid, landing_company, key) {
        var landing_company_object = void 0;
        if (loginid.financial || isAccountOfType('financial', loginid)) {
            landing_company_object = getPropertyValue(landing_company, 'financial_company');
        } else if (loginid.real || isAccountOfType('real', loginid)) {
            landing_company_object = getPropertyValue(landing_company, 'gaming_company');

            // handle accounts that don't have gaming company
            if (!landing_company_object) {
                landing_company_object = getPropertyValue(landing_company, 'financial_company');
            }
        } else {
            var financial_company = (getPropertyValue(landing_company, 'financial_company') || {})[key] || [];
            var gaming_company = (getPropertyValue(landing_company, 'gaming_company') || {})[key] || [];
            landing_company_object = financial_company.concat(gaming_company);
            return landing_company_object;
        }
        return (landing_company_object || {})[key];
    };

    var getRiskAssessment = function getRiskAssessment() {
        var status = State.getResponse('get_account_status.status');
        var is_high_risk = /high/.test(State.getResponse('get_account_status.risk_classification'));

        return isAccountOfType('financial') ? /(financial_assessment|trading_experience)_not_complete/.test(status) : is_high_risk && /financial_assessment_not_complete/.test(status);
    };

    // API_V3: send a list of accounts the client can transfer to
    var canTransferFunds = function canTransferFunds(account) {
        if (account) {
            // this specific account can be used to transfer funds to
            return canTransferFundsTo(account.loginid);
        }
        // at least one account can be used to transfer funds to
        return Object.keys(client_object).some(function (loginid) {
            return canTransferFundsTo(loginid);
        });
    };

    var canTransferFundsTo = function canTransferFundsTo(to_loginid) {
        if (to_loginid === current_loginid || get('is_virtual', to_loginid) || get('is_virtual') || get('is_disabled', to_loginid)) {
            return false;
        }
        var from_currency = get('currency');
        var to_currency = get('currency', to_loginid);
        if (!from_currency || !to_currency) {
            return false;
        }
        // only transfer to other accounts that have the same currency as current account if one is maltainvest and one is malta
        if (from_currency === to_currency) {
            // these landing companies are allowed to transfer funds to each other if they have the same currency
            var same_cur_allowed = {
                maltainvest: 'malta',
                malta: 'maltainvest'
            };
            var from_landing_company = get('landing_company_shortcode');
            var to_landing_company = get('landing_company_shortcode', to_loginid);
            // if same_cur_allowed[from_landing_company] is undefined and to_landing_company is also undefined, it will return true
            // so we should compare '' === undefined instead
            return (same_cur_allowed[from_landing_company] || '') === to_landing_company;
        }
        // or for other clients if current account is cryptocurrency it should only transfer to fiat currencies and vice versa
        var is_from_crypto = isCryptocurrency(from_currency);
        var is_to_crypto = isCryptocurrency(to_currency);
        return is_from_crypto ? !is_to_crypto : is_to_crypto;
    };

    var hasCostaricaAccount = function hasCostaricaAccount() {
        return !!getAllLoginids().find(function (loginid) {
            return (/^CR/.test(loginid)
            );
        });
    };

    return {
        init: init,
        isLoggedIn: isLoggedIn,
        isValidLoginid: isValidLoginid,
        set: set,
        get: get,
        getAllLoginids: getAllLoginids,
        getAccountType: getAccountType,
        isAccountOfType: isAccountOfType,
        getAccountOfType: getAccountOfType,
        hasAccountType: hasAccountType,
        hasCurrencyType: hasCurrencyType,
        getAccountTitle: getAccountTitle,
        responseAuthorize: responseAuthorize,
        shouldAcceptTnc: shouldAcceptTnc,
        clearAllAccounts: clearAllAccounts,
        setNewAccount: setNewAccount,
        currentLandingCompany: currentLandingCompany,
        shouldCompleteTax: shouldCompleteTax,
        getMT5AccountType: getMT5AccountType,
        getBasicUpgradeInfo: getBasicUpgradeInfo,
        getLandingCompanyValue: getLandingCompanyValue,
        getRiskAssessment: getRiskAssessment,
        canTransferFunds: canTransferFunds,
        hasCostaricaAccount: hasCostaricaAccount
    };
}();

module.exports = ClientBase;

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ClientBase = __webpack_require__(85);
var SocketCache = __webpack_require__(74);
var getLanguage = __webpack_require__(16).get;
var State = __webpack_require__(6).State;
var cloneObject = __webpack_require__(1).cloneObject;
var getPropertyValue = __webpack_require__(1).getPropertyValue;
var isEmptyObject = __webpack_require__(1).isEmptyObject;
var getAppId = __webpack_require__(51).getAppId;
var getSocketURL = __webpack_require__(51).getSocketURL;

/*
 * An abstraction layer over native javascript WebSocket,
 * which provides additional functionality like
 * reopen the closed connection and process the buffered requests
 */
var BinarySocketBase = function () {
    var binary_socket = void 0;

    var config = {};
    var buffered_sends = [];
    var req_id = 0;
    var wrong_app_id = 0;
    var is_available = true;
    var is_disconnect_called = false;

    var socket_url = getSocketURL() + '?app_id=' + getAppId() + '&l=' + getLanguage() + '&debug=1';
    var timeouts = {};
    var promises = {};

    var no_duplicate_requests = ['authorize', 'get_settings', 'residence_list', 'landing_company', 'payout_currencies', 'asset_index'];

    var sent_requests = {
        items: [],
        clear: function clear() {
            sent_requests.items = [];
        },
        has: function has(msg_type) {
            return sent_requests.items.indexOf(msg_type) >= 0;
        },
        add: function add(msg_type) {
            if (!sent_requests.has(msg_type)) sent_requests.items.push(msg_type);
        },
        remove: function remove(msg_type) {
            if (sent_requests.has(msg_type)) sent_requests.items.splice(sent_requests.items.indexOf(msg_type, 1));
        }
    };

    var waiting_list = {
        items: {},
        add: function add(msg_type, promise_obj) {
            if (!waiting_list.items[msg_type]) {
                waiting_list.items[msg_type] = [];
            }
            waiting_list.items[msg_type].push(promise_obj);
        },
        resolve: function resolve(response) {
            var msg_type = response.msg_type;
            var this_promises = waiting_list.items[msg_type];
            if (this_promises && this_promises.length) {
                this_promises.forEach(function (pr) {
                    if (!waiting_list.another_exists(pr, msg_type)) {
                        pr.resolve(response);
                    }
                });
                waiting_list.items[msg_type] = [];
            }
        },
        another_exists: function another_exists(pr, msg_type) {
            return Object.keys(waiting_list.items).some(function (type) {
                return type !== msg_type && waiting_list.items[type].indexOf(pr) !== -1;
            });
        }
    };

    var clearTimeouts = function clearTimeouts() {
        Object.keys(timeouts).forEach(function (key) {
            clearTimeout(timeouts[key]);
            delete timeouts[key];
        });
    };

    var isReady = function isReady() {
        return hasReadyState(1);
    };

    var isClose = function isClose() {
        return !binary_socket || hasReadyState(2, 3);
    };

    var hasReadyState = function hasReadyState() {
        for (var _len = arguments.length, states = Array(_len), _key = 0; _key < _len; _key++) {
            states[_key] = arguments[_key];
        }

        return binary_socket && states.some(function (s) {
            return binary_socket.readyState === s;
        });
    };

    var sendBufferedRequests = function sendBufferedRequests() {
        while (buffered_sends.length > 0 && is_available) {
            var req_obj = buffered_sends.shift();
            send(req_obj.request, req_obj.options);
        }
    };

    var wait = function wait() {
        for (var _len2 = arguments.length, msg_types = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            msg_types[_key2] = arguments[_key2];
        }

        var promise_obj = new PromiseClass();
        var is_resolved = true;
        msg_types.forEach(function (msg_type) {
            var last_response = State.get(['response', msg_type]);
            if (!last_response) {
                if (msg_type !== 'authorize' || ClientBase.isLoggedIn()) {
                    waiting_list.add(msg_type, promise_obj);
                    is_resolved = false;
                }
            } else if (msg_types.length === 1) {
                promise_obj.resolve(last_response);
            }
        });
        if (is_resolved) {
            promise_obj.resolve();
        }
        return promise_obj.promise;
    };

    /**
     * @param {Object} data: request object
     * @param {Object} options:
     *      forced  : {boolean}  sends the request regardless the same msg_type has been sent before
     *      msg_type: {string}   specify the type of request call
     *      callback: {function} to call on response of streaming requests
     */
    var send = function send(data) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        var promise_obj = options.promise || new PromiseClass();

        if (!data || isEmptyObject(data)) return promise_obj.promise;

        var msg_type = options.msg_type || no_duplicate_requests.find(function (c) {
            return c in data;
        });

        // Fetch from cache
        if (!options.forced) {
            var response = SocketCache.get(data, msg_type);
            if (response) {
                State.set(['response', msg_type], cloneObject(response));
                if (isReady() && is_available) {
                    // make the request to keep the cache updated
                    binary_socket.send(JSON.stringify(data));
                }
                promise_obj.resolve(response);
                return promise_obj.promise;
            }
        }

        // Fetch from state
        if (!options.forced && msg_type && no_duplicate_requests.indexOf(msg_type) !== -1) {
            var last_response = State.get(['response', msg_type]);
            if (last_response) {
                promise_obj.resolve(last_response);
                return promise_obj.promise;
            } else if (sent_requests.has(msg_type)) {
                return wait(msg_type).then(function (response) {
                    promise_obj.resolve(response);
                    return promise_obj.promise;
                });
            }
        }

        if (!data.req_id) {
            data.req_id = ++req_id;
        }
        promises[data.req_id] = {
            callback: function callback(response) {
                if (typeof options.callback === 'function') {
                    options.callback(response);
                } else {
                    promise_obj.resolve(response);
                }
            },
            subscribe: !!data.subscribe
        };

        if (isReady() && is_available && config.isOnline()) {
            is_disconnect_called = false;
            if (!getPropertyValue(data, 'passthrough') && !getPropertyValue(data, 'verify_email')) {
                data.passthrough = {};
            }

            binary_socket.send(JSON.stringify(data));
            config.wsEvent('send');
            if (msg_type && !sent_requests.has(msg_type)) {
                sent_requests.add(msg_type);
            }
        } else if (+data.time !== 1) {
            // Do not buffer all time requests
            buffered_sends.push({ request: data, options: Object.assign(options, { promise: promise_obj }) });
        }

        return promise_obj.promise;
    };

    var init = function init(options) {
        if (wrong_app_id === getAppId()) {
            return;
        }
        if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) === 'object' && config !== options) {
            config = options;
            buffered_sends = [];
        }
        clearTimeouts();
        config.wsEvent('init');

        if (isClose()) {
            binary_socket = new WebSocket(socket_url);
            State.set('response', {});
        }

        binary_socket.onopen = function () {
            config.wsEvent('open');
            if (ClientBase.isLoggedIn()) {
                send({ authorize: ClientBase.get('token') }, { forced: true });
            } else {
                sendBufferedRequests();
            }

            if (typeof config.onOpen === 'function') {
                config.onOpen(isReady());
            }
        };

        binary_socket.onmessage = function (msg) {
            config.wsEvent('message');
            var response = msg.data ? JSON.parse(msg.data) : undefined;
            if (response) {
                SocketCache.set(response);
                var msg_type = response.msg_type;

                // store in State
                if (!getPropertyValue(response, ['echo_req', 'subscribe']) || /balance|website_status/.test(msg_type)) {
                    State.set(['response', msg_type], cloneObject(response));
                }
                // resolve the send promise
                var this_req_id = response.req_id;
                var pr = this_req_id ? promises[this_req_id] : null;
                if (pr && typeof pr.callback === 'function') {
                    pr.callback(response);
                    if (!pr.subscribe) {
                        delete promises[this_req_id];
                    }
                }
                // resolve the wait promise
                waiting_list.resolve(response);

                if (getPropertyValue(response, ['error', 'code']) === 'InvalidAppID') {
                    wrong_app_id = getAppId();
                }

                if (typeof config.onMessage === 'function') {
                    config.onMessage(response);
                }
            }
        };

        binary_socket.onclose = function () {
            sent_requests.clear();
            clearTimeouts();
            config.wsEvent('close');

            if (wrong_app_id !== getAppId() && typeof config.onDisconnect === 'function' && !is_disconnect_called) {
                config.onDisconnect();
                is_disconnect_called = true;
            }
        };
    };

    var clear = function clear(msg_type) {
        buffered_sends = [];
        if (msg_type) {
            State.set(['response', msg_type], undefined);
            sent_requests.remove(msg_type);
        }
    };

    var availability = function availability(status) {
        if (typeof status !== 'undefined') {
            is_available = !!status;
        }
        return is_available;
    };

    return {
        init: init,
        wait: wait,
        send: send,
        clear: clear,
        clearTimeouts: clearTimeouts,
        availability: availability,
        hasReadyState: hasReadyState,
        sendBuffered: sendBufferedRequests,
        get: function get() {
            return binary_socket;
        },
        setOnDisconnect: function setOnDisconnect(onDisconnect) {
            config.onDisconnect = onDisconnect;
        },
        removeOnDisconnect: function removeOnDisconnect() {
            delete config.onDisconnect;
        }
    };
}();

var PromiseClass = function PromiseClass() {
    var _this = this;

    _classCallCheck(this, PromiseClass);

    this.promise = new Promise(function (resolve, reject) {
        _this.reject = reject;
        _this.resolve = resolve;
    });
};

module.exports = BinarySocketBase;

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var moment = __webpack_require__(9);
var checkInput = __webpack_require__(4).checkInput;
var localize = __webpack_require__(2).localize;
var padLeft = __webpack_require__(17).padLeft;
var toReadableFormat = __webpack_require__(17).toReadableFormat;
var clearable = __webpack_require__(1).clearable;
var isEmptyObject = __webpack_require__(1).isEmptyObject;

var DatePicker = function () {
    var date_pickers = {};
    var localizations = {};

    var init = function init(options) {
        hide(options.selector);
        date_pickers[options.selector] = {};

        if (isEmptyObject(localizations)) {
            localizations = {
                monthNames: localize(['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']),
                monthNamesShort: localize(['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']),
                dayNames: localize(['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']),
                dayNamesMin: localize(['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa']),
                nextText: localize('Next'),
                prevText: localize('Previous')
            };
        }

        config(options);
        $(window).resize(function () {
            checkWidth(options.selector);
        });
    };

    var hide = function hide(selector) {
        $(selector).datepicker('destroy').removeAttr('data-picker').off('keydown');
    };

    var create = function create(selector) {
        var $this = void 0;
        var date_picker = date_pickers[selector];
        $(selector).keydown(function (e) {
            if (e.which === 13) {
                $this = $(this);
                e.preventDefault();
                e.stopPropagation();
                if (date_picker.config_data.type === 'date') {
                    $this.datepicker('setDate', $this.val());
                }
                $this.datepicker('hide');
                $this.blur();
                return false;
            }
            return true;
        }).datepicker(date_picker.config_data);

        // Not possible to tell datepicker where to put it's
        // trigger calendar icon on the page, so we remove it
        // from the DOM and use our own one.
        $('button.ui-datepicker-trigger').remove();
    };

    var config = function config(options) {
        var selector = options.selector;

        var obj_config = {
            dateFormat: 'dd M, yy',
            changeMonth: true,
            changeYear: true,
            native: true, // custom variable to handle showing of native datepicker for field; true by default
            type: 'date' // custom variable to show diff (duration) or date; date by default
        };

        Object.keys(localizations).forEach(function (localization) {
            obj_config[localization] = localizations[localization];
        });

        $.extend(obj_config, options);

        var setDate = function setDate(date) {
            obj_config[date] = typeof options[date] === 'number' ? moment().add(Number(options[date]), 'day').toDate() : options[date];
        };

        if (options.minDate !== undefined) {
            setDate('minDate');
        }

        if (options.maxDate !== undefined) {
            setDate('maxDate');
        }

        var $this = void 0;
        obj_config.onSelect = function (date_text) {
            var year = $('.ui-datepicker-year').val();
            var month = formatDate(Number($('.ui-datepicker-month').val()), 1);
            var day = date_text.split(' ')[0];
            var date = [year, month, day].join('-');
            $this = $(this);
            var old_value = $this.attr('data-value');
            var this_selector = '#' + $this.attr('id');

            $this.attr('data-value', date);

            var duration = date_pickers[selector].config_data.type === 'diff' ? moment.utc(date + ' 23:59:59').diff(moment.utc(), 'days') : null;
            $this.val(duration || date_text);
            if (old_value === date) return false;
            $(this_selector).trigger('change', [duration || date_text]);

            if ($this.hasClass('clearable')) {
                clearable($this);
            }

            return true;
        };

        date_pickers[selector].config_data = $.extend({}, obj_config);

        checkWidth(selector);
    };

    var formatDate = function formatDate(date, add) {
        return padLeft(date + (add || 0), 2, '0');
    };

    var toDate = function toDate(date) {
        return [date.getFullYear(), formatDate(date.getMonth(), 1), formatDate(date.getDate())].join('-');
    };

    var checkWidth = function checkWidth(selector) {
        var $selector = $(selector);
        var date_picker_conf = date_pickers[selector].config_data;
        if ($(window).width() < 770) {
            if (!date_picker_conf.native) {
                hide(selector);
                $selector.attr('type', 'number');
                return;
            }
            if (checkInput('date', 'not-a-date') && $selector.attr('data-picker') !== 'native') {
                hide(selector);
                $selector.attr({ type: 'date', 'data-picker': 'native' }).val($selector.attr('data-value')).removeClass('clear');
                if ($selector.attr('readonly')) $selector.attr('data-readonly', 'readonly').removeAttr('readonly');
                if (date_picker_conf.minDate !== undefined) $selector.attr('min', toDate(date_picker_conf.minDate));
                if (date_picker_conf.maxDate !== undefined) $selector.attr('max', toDate(date_picker_conf.maxDate));
                return;
            }
        }
        if ($(window).width() > 769 && $selector.attr('data-picker') !== 'jquery' || $(window).width() < 770 && !checkInput('date', 'not-a-date')) {
            var value = $selector.attr('data-value') || $selector.val();
            var format_value = value && date_picker_conf.type !== 'diff' ? toReadableFormat(moment(value)) : $selector.val();
            $selector.attr({ type: 'text', 'data-picker': 'jquery', 'data-value': value }).removeAttr('min max').val(format_value);
            if ($selector.attr('data-readonly')) $selector.attr('readonly', 'readonly').removeAttr('data-readonly');
            if ($selector.attr('data-value') && $selector.hasClass('clearable') && !$selector.attr('disabled')) {
                clearable($selector);
            }
            create(selector);
        }
    };

    return {
        init: init,
        hide: hide
    };
}();

module.exports = DatePicker;

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var showChart = __webpack_require__(89).showChart;
var Defaults = __webpack_require__(23);
var getActiveTab = __webpack_require__(175).getActiveTab;
var GetTicks = __webpack_require__(99);
var MBDefaults = __webpack_require__(36);
var JapanPortfolio = __webpack_require__(172);
var getElementById = __webpack_require__(4).getElementById;
var getLanguage = __webpack_require__(16).get;
var State = __webpack_require__(6).State;
var TabSelector = __webpack_require__(95);
var Url = __webpack_require__(8);

/*
 * This file contains the code related to loading of trading page bottom analysis
 * content. It will contain jquery so as to compatible with old code and less rewrite
 *
 * Please note that this will be removed in near future
 */

/*
 * This function is called whenever we change market, form
 * or underlying to load bet analysis for that particular event
 */

var TradingAnalysis = function () {
    // tabListener();
    var hidden_class = 'invisible';
    var tab_selector_id = 'trade_analysis';

    var form_name = void 0,
        current_tab = void 0;

    var requestTradeAnalysis = function requestTradeAnalysis() {
        form_name = (State.get('is_mb_trading') ? MBDefaults.get('category') : Defaults.get('formname')) || 'risefall';

        var map_obj = { matchdiff: 'digits', callputequal: 'risefall', callput: 'higherlower' };
        form_name = map_obj[form_name] || form_name;

        $('#tab_last_digit').setVisibility(/digits|overunder|evenodd/.test(form_name));
        sessionStorage.setItem('currentAnalysisTab', getActiveTab());
        loadAnalysisTab();
    };

    /*
     * This function bind event to link elements of bottom content
     * navigation
     */
    var bindAnalysisTabEvent = function bindAnalysisTabEvent() {
        $('#trade_analysis').find('li a').on('click', function (e) {
            e.preventDefault();
            var li = e.target.parentElement;
            sessionStorage.setItem('currentAnalysisTab', li.id);
            if (!li.classList.contains('active')) {
                loadAnalysisTab(li.id);
            }
        });

        TabSelector.onChangeTab(changeTab);
    };

    /*
     * This function handles all the functionality on how to load
     * tab according to current paramerted
     */
    var loadAnalysisTab = function loadAnalysisTab(tab) {
        current_tab = tab || getActiveTab();

        $('#trade_analysis').find('li').removeClass('active');
        $('#' + current_tab).addClass('active');
        toggleActiveAnalysisTabs();
        JapanPortfolio.init();
        if (State.get('is_mb_trading')) {
            showChart();
        }
        if (current_tab === 'tab_portfolio') {
            JapanPortfolio.show();
        } else {
            JapanPortfolio.hide();
            if (current_tab === 'tab_graph') {
                showChart();
            } else if (current_tab === 'tab_last_digit') {
                var $digit_underlying = $('#digit_underlying');
                var $underlying = $('#underlying');
                var underlying = $underlying.val();
                var underlying_text = $underlying.attr('data-text');
                var tick = $('#tick_count').val() || 100;

                if (underlying !== $digit_underlying.val() && $digit_underlying.val() !== null) {
                    $digit_underlying.find('option[value="' + underlying + '"]').prop('selected', true).trigger('change');
                    var $digit_underlying_dropdown = $digit_underlying.next('div.select-dropdown');

                    // check if custom dropdown exists and sync with underlying dropdown
                    if ($digit_underlying_dropdown) {
                        var $digit_underlying_list = $digit_underlying_dropdown.next('ul.select-options').children('li');
                        $digit_underlying_dropdown.text(underlying_text);
                        $digit_underlying_list.not(undefined).each(function (idx, el) {
                            el.classList.remove('selected');
                        });
                        $digit_underlying_list.filter('[value=\'' + underlying + '\']').addClass('selected');
                    }
                } else {
                    GetTicks.request('', {
                        ticks_history: underlying,
                        count: tick.toString(),
                        end: 'latest'
                    });
                }
            } else if (current_tab === 'tab_explanation') {
                showExplanation();
            }
        }
        if (current_tab) {
            var el_to_show = getElementById(current_tab);
            var el_mobile_tab_header = getElementById('tab_mobile_header');

            TabSelector.slideSelector(tab_selector_id, el_to_show);
            if (el_mobile_tab_header) {
                el_mobile_tab_header.innerHTML = el_to_show.firstChild.innerHTML;
            }
        }

        // workaround for underline during window resize
        window.addEventListener('resize', tabSlider);
    };

    var tabSlider = function tabSlider() {
        TabSelector.slideSelector(tab_selector_id, getElementById(current_tab));
    };

    var changeTab = function changeTab(options) {
        var selector_array = Array.from(getElementById(options.selector).querySelectorAll('li.tm-li:not(.invisible):not(.tab-selector)'));
        var active_index = selector_array.findIndex(function (x) {
            return x.id === getActiveTab();
        });
        var index_to_show = active_index;
        if (options.direction) {
            var array_length = selector_array.length;
            if (options.direction === 'left') {
                index_to_show = active_index - 1;
                index_to_show = index_to_show < 0 ? array_length - 1 : index_to_show;
            } else {
                index_to_show = active_index + 1;
                index_to_show = index_to_show === array_length ? 0 : index_to_show;
            }
        }
        options.el_to_show = selector_array[index_to_show].id;
        if (!options.el_to_show || !options.selector) {
            return;
        }
        sessionStorage.setItem('currentAnalysisTab', options.el_to_show);
        if (!getElementById(options.el_to_show).classList.contains('active')) {
            loadAnalysisTab(options.el_to_show);
        }
    };

    /*
     * function to toggle the active element for analysis menu
     */
    var toggleActiveAnalysisTabs = function toggleActiveAnalysisTabs() {
        current_tab = getActiveTab();

        var analysis_container = getElementById('analysis_content');
        var child_elements = analysis_container.children;
        var current_tab_element = getElementById(current_tab + '-content');
        var classes = current_tab_element.classList;

        for (var i = 0, len = child_elements.length; i < len; i++) {
            child_elements[i].classList.remove('selectedTab');
            child_elements[i].classList.add(hidden_class);
        }

        classes.add('selectedTab');
        classes.remove(hidden_class);
    };

    /*
     * handle the display of proper explanation based on parameters
     */
    var showExplanation = function showExplanation() {
        var $container = $('#tab_explanation-content');

        $container.find('#explanation_winning > div, #explanation_explain > div, #explanation_image').setVisibility(0);
        $container.find('#explanation_winning, #winning_' + form_name + ', #explanation_explain, #explain_' + form_name).setVisibility(1);

        var images = {
            risefall: {
                image1: 'rise-fall-1.svg',
                image2: 'rise-fall-2.svg'
            },
            higherlower: {
                image1: 'higher-lower-1.svg',
                image2: 'higher-lower-2.svg'
            },
            touchnotouch: {
                image1: 'touch-notouch-1.svg',
                image2: 'touch-notouch-2.svg'
            },
            endsinout: {
                image1: 'in-out-1.svg',
                image2: 'in-out-2.svg'
            },
            staysinout: {
                image1: 'in-out-3.svg',
                image2: 'in-out-4.svg'
            },
            updown: {
                image1: 'up-down-1.svg',
                image2: 'up-down-2.svg'
            },
            evenodd: {
                image1: 'evenodd-1.svg',
                image2: 'evenodd-2.svg'
            },
            overunder: {
                image1: 'overunder-1.svg',
                image2: 'overunder-2.svg'
            },
            lookbackhigh: {
                image1: 'close-high-image.svg'
            },
            lookbacklow: {
                image1: 'close-low-image.svg'
            },
            lookbackhighlow: {
                image1: 'high-low-image.svg'
            },
            reset: {
                image1: 'reset-call.svg',
                image2: 'reset-put.svg'
            },
            callputspread: {
                image1: 'call-spread.svg',
                image2: 'put-spread.svg'
            },
            highlowticks: {
                image1: 'high-low-1.svg',
                image2: 'high-low-2.svg'
            }
        };

        if (images[form_name]) {
            var image_path = Url.urlForStatic('images/pages/trade-explanation/' + (getLanguage() === 'JA' ? 'ja/' : ''));
            $container.find('#explanation_image_1').attr('src', image_path + images[form_name].image1);
            if (images[form_name].image2) {
                $container.find('#explanation_image_2').attr('src', image_path + images[form_name].image2).parent().setVisibility(1);
            } else {
                $container.find('#explanation_image_2').parent().setVisibility(0);
            }
            $container.find('#explanation_image').setVisibility(1);
        }
    };

    var onUnload = function onUnload() {
        window.removeEventListener('resize', tabSlider);
    };

    return {
        bindAnalysisTabEvent: bindAnalysisTabEvent,
        onUnload: onUnload,
        request: requestTradeAnalysis
    };
}();

module.exports = TradingAnalysis;

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var getAllSymbols = __webpack_require__(79).getAllSymbols;
var MBDefaults = __webpack_require__(36);
var isJPClient = __webpack_require__(3).isJPClient;
var getElementById = __webpack_require__(4).getElementById;
var getLanguage = __webpack_require__(16).get;
var localize = __webpack_require__(2).localize;
var State = __webpack_require__(6).State;
var getPropertyValue = __webpack_require__(1).getPropertyValue;
var Config = __webpack_require__(51);

var WebtraderChart = function () {
    var chart = void 0,
        WebtraderCharts = void 0,
        is_initialized = void 0;

    var showChart = function showChart() {
        if (State.get('is_chart_allowed')) {
            setChart();
        } else {
            cleanupChart();
            $('#trade_live_chart').hide();
            $('#chart-error').text(localize('Chart is not available for this underlying.')).show();
        }
    };

    var cleanupChart = function cleanupChart() {
        if (typeof getPropertyValue(chart, ['actions', 'destroy']) === 'function') {
            chart.actions.destroy();
        }
        chart = undefined;
    };

    var setChart = function setChart() {
        var is_mb_trading = State.get('is_mb_trading');
        var new_underlying = is_mb_trading ? $('#underlying').attr('value') : getElementById('underlying').value;
        if (($('#tab_graph').hasClass('active') || is_mb_trading) && (!chart || chart.data().instrumentCode !== new_underlying || is_mb_trading && (getChartSettings().time_frame !== chart.data().timePeriod || getChartSettings().chart_type !== chart.data().type))) {
            cleanupChart();
            initChart();
        }
        $('#chart-error').hide();
        $('#trade_live_chart').show();
    };

    var initChart = function initChart() {
        if (!State.get('is_chart_allowed')) return;
        if (!is_initialized) {
            __webpack_require__.e/* require.ensure */(0).then((function () {
                __webpack_require__.e/* require.ensure */(3).then((function (require) {
                    WebtraderCharts = __webpack_require__(569);
                    WebtraderCharts.init({
                        server: Config.getSocketURL(),
                        appId: Config.getAppId(),
                        lang: getLanguage().toLowerCase()
                    });
                    is_initialized = true;
                    addChart();
                }).bind(null, __webpack_require__)).catch(__webpack_require__.oe);
            }).bind(null, __webpack_require__)).catch(__webpack_require__.oe);
        } else {
            addChart();
        }
    };

    var addChart = function addChart() {
        var is_mb_trading = State.get('is_mb_trading');
        var $underlying = $('#underlying');
        var $underlying_code = is_mb_trading ? $underlying.attr('value') : $underlying.val();
        var $underlying_name = is_mb_trading ? $underlying.find('.current .name').text() : getAllSymbols()[$underlying_code];

        var chart_config = {
            instrumentCode: $underlying_code,
            instrumentName: $underlying_name,
            showInstrumentName: true,
            timePeriod: getChartSettings().time_frame,
            type: getChartSettings().chart_type,
            lang: getLanguage().toLowerCase(),
            timezoneOffset: (isJPClient() ? -9 : 0) * 60,
            showShare: !is_mb_trading
        };

        chart = WebtraderCharts.chartWindow.addNewChart($('#webtrader_chart'), chart_config);
    };

    var redrawChart = function redrawChart() {
        if (typeof getPropertyValue(chart, ['actions', 'reflow']) === 'function') {
            chart.actions.reflow();
        }
    };

    var getChartSettings = function getChartSettings() {
        var chart_settings = { time_frame: '1t', chart_type: 'line' };
        if (State.get('is_mb_trading')) {
            var period = MBDefaults.get('period').split('_')[2].substr(0, 2).toUpperCase();
            var period_map = {
                '5H': { time_frame: '1m', chart_type: 'line' },
                '0D': { time_frame: '30m', chart_type: 'ohlc' },
                '1W': { time_frame: '1d', chart_type: 'ohlc' },
                '1M': { time_frame: '1d', chart_type: 'candlestick' },
                '3M': { time_frame: '1d', chart_type: 'candlestick' },
                '1Y': { time_frame: '1d', chart_type: 'candlestick' }
            };
            chart_settings = period_map[period] || chart_settings;
        }
        return chart_settings;
    };

    return {
        showChart: showChart,
        cleanupChart: cleanupChart,
        setChart: setChart,
        redrawChart: redrawChart
    };
}();

module.exports = WebtraderChart;

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var moment = __webpack_require__(9);
var ViewPopupUI = __webpack_require__(131);
var Highchart = __webpack_require__(283);
var Callputspread = __webpack_require__(98);
var Lookback = __webpack_require__(59);
var Reset = __webpack_require__(78);
var TickDisplay = __webpack_require__(126);
var isJPClient = __webpack_require__(3).isJPClient;
var Clock = __webpack_require__(26);
var BinarySocket = __webpack_require__(5);
var getElementById = __webpack_require__(4).getElementById;
var localize = __webpack_require__(2).localize;
var State = __webpack_require__(6).State;
var urlFor = __webpack_require__(8).urlFor;
var Utility = __webpack_require__(1);

var ViewPopup = function () {
    var contract_id = void 0,
        contract = void 0,
        is_sold = void 0,
        is_sell_clicked = void 0,
        is_sold_before_expiry = void 0,
        chart_started = void 0,
        chart_init = void 0,
        chart_updated = void 0,
        ticks_requested = void 0,
        sell_text_updated = void 0,
        btn_view = void 0,
        multiplier = void 0,
        $container = void 0,
        $loading = void 0;

    var popupbox_id = 'inpage_popup_content_box';
    var wrapper_id = 'sell_content_wrapper';
    var hidden_class = 'invisible';

    var init = function init(button, onClose) {
        btn_view = button;
        contract_id = $(btn_view).attr('contract_id');
        contract = {};
        is_sold = false;
        is_sell_clicked = false;
        is_sold_before_expiry = false;
        chart_started = false;
        chart_init = false;
        chart_updated = false;
        ticks_requested = false;
        sell_text_updated = false;
        $container = '';

        if (typeof onClose === 'function') {
            ViewPopupUI.setOnCloseFunction(onClose);
        }

        if (btn_view) {
            ViewPopupUI.disableButton($(btn_view));
            ViewPopupUI.cleanup(false);
        }

        getContract();

        setLoadingState(true);
    };

    var responseContract = function responseContract(response) {
        if (!response.proposal_open_contract || Utility.isEmptyObject(response.proposal_open_contract)) {
            showErrorPopup(response);
            return;
        }
        // In case of error such as legacy shortcode, this call is returning the error message
        // but no error field. To specify those cases, we check for other fields existence
        if (!Utility.getPropertyValue(response, ['proposal_open_contract', 'shortcode'])) {
            showErrorPopup(response, response.proposal_open_contract.validation_error);
            return;
        }

        $.extend(contract, response.proposal_open_contract);
        // Lookback multiplier value
        multiplier = contract.multiplier;

        if (contract && document.getElementById(wrapper_id)) {
            update();
            return;
        }

        showContract();
    };

    var showContract = function showContract() {
        setLoadingState(false);

        if (!$container) {
            $container = makeTemplate();
        }

        var contract_type_display = {
            ASIANU: 'Asian Up',
            ASIAND: 'Asian Down',
            CALL: 'Higher',
            CALLE: 'Higher or equal',
            PUT: 'Lower',
            PUTE: 'Lower or equal',
            DIGITMATCH: 'Digit Matches',
            DIGITDIFF: 'Digit Differs',
            DIGITODD: 'Digit Odd',
            DIGITEVEN: 'Digit Even',
            DIGITOVER: 'Digit Over',
            DIGITUNDER: 'Digit Under',
            EXPIRYMISS: 'Ends Outside',
            EXPIRYRANGE: 'Ends Between',
            EXPIRYRANGEE: 'Ends Between',
            LBFLOATCALL: 'Close-Low',
            LBFLOATPUT: 'High-Close',
            LBHIGHLOW: 'High-Low',
            RANGE: 'Stays Between',
            RESETCALL: 'Reset Call',
            RESETPUT: 'Reset Put',
            UPORDOWN: 'Goes Outside',
            ONETOUCH: 'Touches',
            NOTOUCH: 'Does Not Touch',
            CALLSPREAD: 'Call Spread',
            PUTSPREAD: 'Put Spread',
            TICKHIGH: 'High Tick',
            TICKLOW: 'Low Tick'
        };

        containerSetText('trade_details_contract_type', localize(contract_type_display[contract.contract_type]));
        containerSetText('trade_details_contract_id', contract.contract_id);
        containerSetText('trade_details_start_date', epochToDateTime(contract.date_start));
        containerSetText('trade_details_end_date', epochToDateTime(contract.date_expiry));
        containerSetText('trade_details_purchase_price', formatMoney(contract.currency, contract.buy_price));
        containerSetText('trade_details_multiplier', formatMoney(contract.currency, multiplier, false, 3, 2));
        if (Lookback.isLookback(contract.contract_type)) {
            containerSetText('trade_details_payout', Lookback.getFormula(contract.contract_type, formatMoney(contract.currency, multiplier, false, 3, 2)));
        } else {
            containerSetText('trade_details_payout', formatMoney(contract.currency, contract.payout));
        }
        Clock.setExternalTimer(updateTimers);
        update();
        ViewPopupUI.repositionConfirmation();

        if (State.get('is_mb_trading')) {
            State.call('ViewPopup.onDisplayed');
        }
    };

    var update = function update() {
        var is_path_dependent_tick = +contract.is_path_dependent;

        is_sold_before_expiry = is_path_dependent_tick ? contract.sell_spot_time && +contract.sell_spot_time < contract.date_expiry : contract.status === 'sold' || contract.sell_time && contract.sell_time < contract.date_expiry;

        var final_price = contract.sell_price || contract.bid_price;
        var is_started = !contract.is_forward_starting || contract.current_spot_time > contract.date_start;
        var is_ended = contract.status !== 'open' || contract.is_expired || contract.is_settleable;
        var indicative_price = final_price && is_ended ? final_price : contract.bid_price || null;
        var is_sold_before_start = contract.sell_time && contract.sell_time < contract.date_start;

        if (Callputspread.isCallputspread(contract.contract_type)) {
            Callputspread.update(null, contract);
        }

        if (contract.barrier_count > 1) {
            containerSetText('trade_details_barrier', is_sold_before_start ? '-' : addComma(contract.high_barrier), '', true);
            containerSetText('trade_details_barrier_low', is_sold_before_start ? '-' : addComma(contract.low_barrier), '', true);
        } else if (contract.barrier) {
            var formatted_barrier = addComma(contract.barrier);
            var mapping = {
                DIGITMATCH: 'Equals',
                DIGITDIFF: 'Not'
            };
            var contract_text = mapping[contract.contract_type];
            var barrier_prefix = contract_text ? localize(contract_text) + ' ' : '';
            // only show entry spot if available and contract was not sold before start time
            containerSetText('trade_details_barrier', contract.entry_tick_time && is_sold_before_start ? '-' : barrier_prefix + formatted_barrier, '', true);

            if (Reset.isReset(contract.contract_type) && Reset.isNewBarrier(contract.entry_spot, contract.barrier)) {
                containerSetText('trade_details_barrier', is_sold_before_start ? '-' : addComma(contract.entry_spot), '', true);
                containerSetText('trade_details_reset_barrier', contract.entry_tick_time && is_sold_before_start ? '-' : barrier_prefix + formatted_barrier, '', true);
            }
        }

        var current_spot = contract.current_spot;
        var current_spot_time = contract.current_spot_time;
        if (is_ended) {
            if (/^(tickhigh|ticklow)$/i.test(contract.contract_type)) {
                current_spot = is_sold_before_expiry ? contract.sell_spot : '';
                current_spot_time = is_sold_before_expiry ? contract.sell_spot_time : '';
            } else {
                current_spot = is_sold_before_expiry ? '' : contract.exit_tick;
                current_spot_time = is_sold_before_expiry ? '' : contract.exit_tick_time;
            }
        }

        if (current_spot) {
            containerSetText('trade_details_current_spot > span', addComma(current_spot));
        } else {
            $('#trade_details_current_spot').parent().setVisibility(0);
        }

        if (current_spot_time) {
            if (window.time && current_spot_time > window.time.unix()) {
                window.time = moment(current_spot_time).utc();
                updateTimers();
            }
            containerSetText('trade_details_current_date', epochToDateTime(current_spot_time));
        } else {
            $('#trade_details_current_date').parent().setVisibility(0);
        }

        containerSetText('trade_details_ref_id', contract.transaction_ids.buy + ' (' + localize('Buy') + ') ' + (contract.transaction_ids.sell ? '<br>' + contract.transaction_ids.sell + ' (' + localize('Sell') + ')' : ''));
        containerSetText('trade_details_indicative_price', indicative_price ? formatMoney(contract.currency, indicative_price) : '-');

        var profit_loss = void 0,
            percentage = void 0;

        if (final_price) {
            profit_loss = final_price - contract.buy_price;
            percentage = addComma(profit_loss * 100 / contract.buy_price, 2);
            containerSetText('trade_details_profit_loss', formatMoney(contract.currency, profit_loss) + '<span class="percent">(' + (percentage > 0 ? '+' : '') + percentage + '%)</span>', { class: profit_loss >= 0 ? 'profit' : 'loss' });
        } else {
            containerSetText('trade_details_profit_loss', '-', { class: 'loss' });
        }

        if (!is_started) {
            containerSetText('trade_details_entry_spot > span', '-');
            containerSetText('trade_details_message', localize('Contract has not started yet'));
        } else {
            if (contract.entry_spot > 0) {
                // only show entry spot if available and contract was not sold before start time
                containerSetText('trade_details_entry_spot > span', is_sold_before_start ? '-' : addComma(contract.entry_spot));
            }
            containerSetText('trade_details_message', contract.validation_error ? contract.validation_error : '&nbsp;');
        }

        if (!chart_started && !contract.tick_count) {
            if (!chart_init) {
                chart_init = true;
                Highchart.showChart(contract);
            }
            Highchart.showChart(contract, 'update');
            if (contract.entry_tick_time) {
                chart_started = true;
            }
        } else if (contract.tick_count && !chart_updated) {
            TickDisplay.updateChart({ id_render: 'tick_chart', request_ticks: !ticks_requested }, contract);
            ticks_requested = true;
            if ('barrier' in contract) {
                chart_updated = true;
            }
        }

        if (!is_sold && is_sold_before_expiry) {
            is_sold = true;
            if (!contract.tick_count) Highchart.showChart(contract, 'update');else TickDisplay.updateChart({ is_sold: true }, contract);
        }
        if (contract.is_valid_to_sell && contract.is_settleable && !contract.is_sold && !is_sell_clicked) {
            ViewPopupUI.forgetStreams();
            BinarySocket.send({ sell_expired: 1 }).then(function (response) {
                getContract(response);
            });
        }
        if (is_ended) {
            contractEnded();
            if (!contract.tick_count) Highchart.showChart(contract, 'update');else TickDisplay.updateChart({ is_sold: true }, contract);
            containerSetText('trade_details_live_remaining', '-');
            Clock.setExternalTimer(); // stop timer
        } else {
            $container.find('#notice_ongoing').setVisibility(1);
        }

        if (!contract.is_valid_to_sell) {
            $container.find('#errMsg').setVisibility(0);
        }

        var _contract = contract,
            barrier = _contract.barrier,
            contract_type = _contract.contract_type,
            entry_spot = _contract.entry_spot;

        if (Reset.isReset(contract_type) && Reset.isNewBarrier(entry_spot, barrier)) {
            TickDisplay.plotResetSpot(barrier);
        }
        // next line is responsible for 'sell at market' flashing on the last tick
        sellSetVisibility(!is_sell_clicked && !is_sold && !is_ended && +contract.is_valid_to_sell === 1);
        contract.chart_validation_error = contract.validation_error;
        contract.validation_error = '';
    };

    // This is called by clock.js in order to sync time updates on header as well as view popup
    var updateTimers = function updateTimers() {
        var now = Math.max(Math.floor((window.time || 0) / 1000), contract.current_spot_time || 0);
        containerSetText('trade_details_live_date', epochToDateTime(now));
        Clock.showLocalTimeOnHover('#trade_details_live_date');

        var is_started = !contract.is_forward_starting || contract.current_spot_time > contract.date_start;
        var remained = contract.date_expiry - now;
        if (!is_started || contract.status !== 'open' || remained < 0) {
            containerSetText('trade_details_live_remaining', '-');
        } else {
            var days = 0;
            var day_seconds = 24 * 60 * 60;
            if (remained > day_seconds) {
                days = Math.floor(remained / day_seconds);
                remained %= day_seconds;
            }
            containerSetText('trade_details_live_remaining', (days > 0 ? days + ' ' + localize(days > 1 ? 'days' : 'day') + ', ' : '') + moment(remained * 1000).utc().format('HH:mm:ss'));
        }
    };

    var contractEnded = function contractEnded() {
        var el_live_date = getElementById('trade_details_live_date');
        if (el_live_date.parentNode) {
            el_live_date.parentNode.setVisibility(0);
        }

        containerSetText('trade_details_current_title', 'Contract Result');
        containerSetText('trade_details_indicative_label', localize('Price'));
        if (Lookback.isLookback(contract.contract_type)) {
            containerSetText('trade_details_spot_label', localize('Close'));
            containerSetText('trade_details_spottime_label', localize('Close Time'));
        } else if (/^(tickhigh|ticklow)$/i.test(contract.contract_type)) {
            var is_high_tick = /^(tickhigh)$/i.test(contract.contract_type);
            var txt_high_low = is_high_tick ? 'Highest' : 'Lowest';
            containerSetText('trade_details_spot_label', localize(txt_high_low + ' Tick'));
            containerSetText('trade_details_spottime_label', localize(txt_high_low + ' Tick Time'));
        } else {
            containerSetText('trade_details_spot_label', localize('Exit Spot'));
            containerSetText('trade_details_spottime_label', localize('Exit Spot Time'));
        }

        // show validation error if contract is not settled yet
        if (!(contract.is_settleable && !contract.is_sold)) {
            containerSetText('trade_details_message', '&nbsp;');
        }
        $container.find('#errMsg').setVisibility(0);
        $container.find('#notice_ongoing').setVisibility(0);
        sellSetVisibility(false);
        // showWinLossStatus(is_win);
        // don't show for japanese clients or contracts that are manually sold before starting
        if (contract.audit_details && !isJPClient() && (!contract.sell_spot_time || contract.sell_spot_time > contract.date_start)) {
            initAuditTable(0);
        }
    };

    var appendAuditLink = function appendAuditLink(element_id) {
        var link = Utility.createElement('a', { href: 'javascript:;', class: 'link-audit button-secondary' });
        var span = Utility.createElement('span', { text: localize('Audit') });
        link.appendChild(span);
        link.addEventListener('click', function () {
            initAuditTable(1);
        });
        getElementById(element_id).appendChild(link);
    };

    // by default shows audit table and hides chart
    var setAuditVisibility = function setAuditVisibility() {
        var show = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

        setAuditButtonsVisibility(!show);
        getElementById('sell_details_chart_wrapper').setVisibility(!show);
        getElementById('sell_details_audit').setVisibility(show);
        ViewPopupUI.repositionConfirmation();
    };

    var setAuditButtonsVisibility = function setAuditButtonsVisibility() {
        var show = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

        var links = document.getElementsByClassName('link-audit');
        for (var i = 0; i < links.length; i++) {
            links[i].setVisibility(show);
        }
    };

    var initAuditTable = function initAuditTable(show) {
        if (document.getElementById('sell_details_audit')) {
            if (show) {
                setAuditVisibility(1);
            } else {
                setAuditButtonsVisibility(1);
            }
            return;
        }

        var div = Utility.createElement('div', { id: 'sell_details_audit', class: 'gr-8 gr-12-m gr-no-gutter invisible' });
        var table = Utility.createElement('table', { id: 'audit_header', class: 'gr-12' });
        var tr = Utility.createElement('tr', { class: 'gr-row' });
        var th_previous = Utility.createElement('th', { class: 'gr-2 gr-3-t gr-3-p gr-3-m' });
        var link = Utility.createElement('a', { class: 'previous-wrapper' });

        link.appendChild(Utility.createElement('span', { class: 'previous align-self-center' }));
        link.appendChild(Utility.createElement('span', { class: 'nowrap', text: localize('View Chart') }));
        link.addEventListener('click', function () {
            setAuditVisibility(0);
        });
        th_previous.appendChild(link);

        tr.appendChild(th_previous);
        tr.appendChild(Utility.createElement('th', { class: 'gr-8 gr-6-t gr-6-p gr-6-m', text: localize('Audit Page') }));
        tr.appendChild(Utility.createElement('th', { class: 'gr-2 gr-3-t gr-3-p gr-3-m' }));
        table.appendChild(tr);
        div.appendChild(table);
        div.insertAfter(getElementById('sell_details_chart_wrapper'));
        populateAuditTable(show);
        showExplanation(div);
    };

    var map_contract_type = {
        'expiry': 'endsinout',
        'asian': 'asian',
        'even|odd': 'evenodd',
        'over|under': 'overunder',
        'digit': 'digits',
        'upordown|range': 'staysinout',
        'touch': 'touchnotouch',
        'reset': 'reset',
        '(call|put)spread': 'callputspread',
        'tick(high|low)': 'highlowticks',
        'call|put': function callPut() {
            return +contract.entry_tick === +contract.barrier ? 'risefall' : 'higherlower';
        }
    };

    var showExplanation = function showExplanation(div) {
        var explanation_section = 'explain_';
        Object.keys(map_contract_type).some(function (type) {
            if (new RegExp(type, 'i').test(contract.contract_type)) {
                explanation_section += typeof map_contract_type[type] === 'function' ? map_contract_type[type]() : map_contract_type[type];
                return true;
            }
            return false;
        });
        var xhttp = new XMLHttpRequest();
        xhttp.onreadystatechange = function () {
            if (this.readyState !== 4 || this.status !== 200) {
                return;
            }
            var div_response = Utility.createElement('div', { html: this.responseText });
            var div_to_show = div_response.querySelector('#' + explanation_section);
            if (div_to_show) {
                div_to_show.classList.add('align-start', 'gr-padding-20', 'explanation-section', 'gr-parent');
                div.appendChild(div_to_show);
                div_to_show.setVisibility(1);
            }
        };
        xhttp.open('GET', urlFor('explanation'), true);
        xhttp.send();
    };

    var parseAuditResponse = function parseAuditResponse(table, array_audit_data) {
        return new Promise(function (resolve) {
            var primary_classes = ['secondary-bg-color', 'content-inverse-color'];
            var secondary_classes = ['fill-bg-color', 'secondary-time'];
            array_audit_data.forEach(function (audit_data) {
                var color = void 0;
                if (audit_data.flag === 'highlight_tick') {
                    color = primary_classes;
                } else if (audit_data.flag === 'highlight_time') {
                    color = secondary_classes;
                }
                createAuditRow(table, audit_data.epoch, audit_data.tick, audit_data.name, color);
            });
            resolve();
        });
    };

    var createAuditTable = function createAuditTable(title) {
        var div = Utility.createElement('div', { class: 'audit-table' });
        var fieldset = Utility.createElement('fieldset', { class: 'align-start' });
        var table = Utility.createElement('table', { class: 'gr-10 gr-centered gr-12-p gr-12-m' });
        fieldset.appendChild(Utility.createElement('legend', { text: localize('Contract ' + title) }));
        fieldset.appendChild(table);
        div.appendChild(fieldset);
        var insert_after = getElementById('audit_header');
        var audit_table = document.getElementsByClassName('audit-table')[0];
        if (audit_table) {
            insert_after = audit_table;
        }
        div.insertAfter(insert_after);
        return {
            table: table,
            div: div
        };
    };

    var createAuditHeader = function createAuditHeader(table) {
        var tr = Utility.createElement('tr', { class: 'gr-row' });

        tr.appendChild(Utility.createElement('td', { class: 'gr-3' }));
        tr.appendChild(Utility.createElement('td', { class: 'gr-4 no-margin secondary-color', text: localize('Spot') }));
        tr.appendChild(Utility.createElement('td', { class: 'gr-5 no-margin secondary-color', text: localize('Spot Time (GMT)') }));

        table.insertBefore(tr, table.childNodes[0]);
    };

    var createAuditRow = function createAuditRow(table, date, tick, remark, td_class) {
        // if we have already added this timestamp in first table, skip adding it again to second table
        // unless it is a highlighted tick like entry or exit spot, or start or end time
        if (document.querySelector('.audit-dates[data-value=\'' + date + '\']') && !remark) {
            return;
        }

        var tr = Utility.createElement('tr', { class: 'gr-row' });
        var td_remark = Utility.createElement('td', { class: 'gr-3 remark', text: remark || '' });
        var td_tick = Utility.createElement('td', { class: 'gr-4', text: tick && !isNaN(tick) ? addComma(tick) : tick || '' });
        var td_date = Utility.createElement('td', { class: 'gr-5 audit-dates', 'data-value': date, 'data-balloon-pos': 'down', text: date && !isNaN(date) ? moment.unix(date).utc().format('YYYY-MM-DD HH:mm:ss') : date || '' });

        tr.appendChild(td_remark);
        tr.appendChild(td_tick);
        tr.appendChild(td_date);

        if (td_class && td_class.length) {
            td_class.forEach(function (c) {
                td_tick.classList.add(c);
                td_date.classList.add(c);
            });
        }

        table.appendChild(tr);
    };

    var populateAuditTable = function populateAuditTable(show_audit_table) {
        var contract_starts = createAuditTable('Starts');
        parseAuditResponse(contract_starts.table, contract.audit_details.contract_start).then(function () {
            if (contract.audit_details.contract_start
            // Hide audit table for Lookback.
            && !/^(LBHIGHLOW|LBFLOATPUT|LBFLOATCALL)/.test(contract.shortcode)) {
                createAuditHeader(contract_starts.table);
                appendAuditLink('trade_details_entry_spot');
            } else {
                contract_starts.div.remove();
            }
            // don't show exit tick information if missing or manual sold
            if (contract.exit_tick_time && !is_sold_before_expiry
            // Hide audit table for Lookback.
            && !/^(LBHIGHLOW|LBFLOATPUT|LBFLOATCALL)/.test(contract.shortcode)) {
                var contract_ends = createAuditTable('Ends');
                parseAuditResponse(contract_ends.table, contract.audit_details.contract_end).then(function () {
                    if (contract.audit_details.contract_end) {
                        createAuditHeader(contract_ends.table);
                        appendAuditLink('trade_details_current_spot');
                    } else {
                        contract_ends.div.remove();
                    }
                    onAuditTableComplete(show_audit_table);
                });
            } else {
                onAuditTableComplete(show_audit_table);
            }
        });
    };

    var onAuditTableComplete = function onAuditTableComplete(show_audit_table) {
        Clock.showLocalTimeOnHover('.audit-dates');
        setAuditVisibility(show_audit_table);
    };

    var makeTemplate = function makeTemplate() {
        $container = $('<div/>').append($('<div/>', { id: wrapper_id }));

        var longcode = contract.longcode;

        $container.prepend($('<div/>', { id: 'sell_bet_desc', class: 'popup_bet_desc drag-handle', text: longcode }));
        var $sections = $('<div/>').append($('<div class="gr-row container"><div id="sell_details_chart_wrapper" class="gr-8 gr-12-m"></div><div id="sell_details_table" class="gr-4 gr-12-m"></div></div>'));
        var barrier_text = 'Barrier',
            low_barrier_text = 'Low Barrier';

        if (Lookback.isLookback(contract.contract_type)) {
            var _Lookback$getBarrierL = Lookback.getBarrierLabel(contract.contract_type, contract.barrier_count);

            var _Lookback$getBarrierL2 = _slicedToArray(_Lookback$getBarrierL, 2);

            barrier_text = _Lookback$getBarrierL2[0];
            low_barrier_text = _Lookback$getBarrierL2[1];
        } else if (contract.barrier_count > 1) {
            barrier_text = 'High Barrier';
        } else if (/^DIGIT(MATCH|DIFF)$/.test(contract.contract_type)) {
            barrier_text = 'Target';
        } else if (/^(tickhigh|ticklow)$/i.test(contract.contract_type)) {
            barrier_text = 'Selected Tick';
        }

        $sections.find('#sell_details_table').append($('<table>\n            <tr id="contract_tabs"><th colspan="2" id="contract_information_tab">' + localize('Contract Information') + '</th></tr><tbody id="contract_information_content">\n            ' + createRow('Contract Type', '', 'trade_details_contract_type') + '\n            ' + createRow('Contract ID', '', 'trade_details_contract_id') + '\n            ' + createRow('Transaction ID', '', 'trade_details_ref_id') + '\n            ' + createRow('Start Time', '', 'trade_details_start_date') + '\n            ' + (!contract.tick_count ? createRow('End Time', '', 'trade_details_end_date') + createRow('Remaining Time', '', 'trade_details_live_remaining') : '') + '\n            ' + (!Lookback.isLookback(contract.contract_type) ? createRow('Entry Spot', '', 'trade_details_entry_spot', 0, '<span></span>') : '') + '\n            ' + createRow(barrier_text, '', 'trade_details_barrier', true) + '\n            ' + (Reset.isReset(contract.contract_type) ? createRow('Reset Barrier', '', 'trade_details_reset_barrier', true) : '') + '\n            ' + (contract.barrier_count > 1 ? createRow(low_barrier_text, '', 'trade_details_barrier_low', true) : '') + '\n            ' + createRow(Callputspread.isCallputspread(contract.contract_type) ? 'Maximum payout' : 'Potential Payout', '', 'trade_details_payout') + '\n            ' + (multiplier && Lookback.isLookback(contract.contract_type) ? createRow('Multiplier', '', 'trade_details_multiplier') : '') + '\n            ' + createRow('Purchase Price', '', 'trade_details_purchase_price') + '\n            </tbody>\n            <th colspan="2" id="barrier_change" class="invisible">' + localize('Barrier Change') + '</th>\n            <tbody id="barrier_change_content" class="invisible"></tbody>\n            <tr><th colspan="2" id="trade_details_current_title">' + localize('Current') + '</th></tr>\n            ' + createRow('Spot', 'trade_details_spot_label', 'trade_details_current_spot', 0, '<span></span>') + '\n            ' + createRow('Spot Time', 'trade_details_spottime_label', 'trade_details_current_date') + '\n            ' + createRow('Current Time', '', 'trade_details_live_date') + '\n            ' + createRow('Indicative', 'trade_details_indicative_label', 'trade_details_indicative_price') + '\n            ' + createRow('Profit/Loss', '', 'trade_details_profit_loss') + '\n            <tr><td colspan="2" class="last_cell" id="trade_details_message">&nbsp;</td></tr>\n            </table>\n            <div id="errMsg" class="notice-msg ' + hidden_class + '"></div>\n            <div id="trade_details_bottom"><div id="contract_sell_wrapper" class="' + hidden_class + '"></div><div id="contract_sell_message"></div><div id="contract_win_status" class="' + hidden_class + '"></div></div>'));

        $sections.find('#sell_details_chart_wrapper').html($('<div/>', { id: contract.tick_count ? 'tick_chart' : 'analysis_live_chart', class: 'live_chart_wrapper' }));

        $container.find('#' + wrapper_id).append($sections.html()).append($('<div/>', { id: 'errMsg', class: 'notice-msg ' + hidden_class })).append($('<div/>', { id: 'notice_ongoing', class: 'fill-bg-color gr-padding-10 ' + hidden_class, text: localize('You can close this window without interrupting your trade.') }));

        ViewPopupUI.showInpagePopup('<div class="' + popupbox_id + '">' + $container.html() + '</div>', '', '#sell_bet_desc');
        return $('#' + wrapper_id);
    };

    var createRow = function createRow(label, label_id, value_id, is_hidden, value) {
        return '<tr' + (is_hidden ? ' class="' + hidden_class + '"' : '') + '><td' + (label_id ? ' id="' + label_id + '"' : '') + '>' + localize(label) + '</td><td' + (value_id ? ' id="' + value_id + '"' : '') + '>' + (value || '') + '</td></tr>';
    };

    var epochToDateTime = function epochToDateTime(epoch) {
        var date_time = moment.utc(epoch * 1000).format('YYYY-MM-DD HH:mm:ss');
        return isJPClient() ? Clock.toJapanTimeIfNeeded(date_time) : date_time + ' GMT';
    };

    // ===== Tools =====
    var containerSetText = function containerSetText(id, string, attributes, is_visible) {
        if (!$container || $container.length === 0) {
            $container = $('#' + wrapper_id);
        }

        var $target = $container.find('#' + id);
        if ($target && $target.length > 0) {
            $target.html(string);
            if (attributes) $target.attr(attributes);
            if (is_visible) $target.parent('tr').setVisibility(1);
        }
    };

    var setLoadingState = function setLoadingState(show_loading) {
        if (show_loading) {
            $loading = $('#trading_init_progress');
            if ($loading.length) {
                $loading.show();
            }
        } else {
            if ($loading.length) {
                $loading.hide();
            }
            if (btn_view) {
                ViewPopupUI.enableButton($(btn_view));
            }
        }
    };

    var showMessagePopup = function showMessagePopup(message, title, msg_class) {
        setLoadingState(false);
        var $con = $('<div/>');
        $con.prepend($('<div/>', { id: 'sell_bet_desc', class: 'popup_bet_desc drag-handle', text: localize(title) }));
        $con.append($('<div/>', { id: wrapper_id }).append($('<div/>', { class: msg_class, html: localize(message) })));
        ViewPopupUI.showInpagePopup('<div class="' + popupbox_id + '">' + $con.html() + '</div>', 'message_popup', '#sell_bet_desc');
    };

    var showErrorPopup = function showErrorPopup(response, message) {
        showMessagePopup(localize(message || 'Sorry, an error occurred while processing your request.'), 'There was an error', 'notice-msg');
        // eslint-disable-next-line no-console
        console.log(response);
    };

    var sellSetVisibility = function sellSetVisibility(show) {
        var sell_wrapper_id = 'sell_at_market_wrapper';
        var sell_button_id = 'sell_at_market';
        var is_exist = $container.find('#' + sell_wrapper_id).length > 0;
        if (show) {
            var is_started = !contract.is_forward_starting || contract.current_spot_time > contract.date_start;
            var $sell_wrapper = $container.find('#contract_sell_wrapper');
            if (is_exist) {
                if (!sell_text_updated && is_started) {
                    addSellNote($sell_wrapper);
                    $sell_wrapper.find('#' + sell_button_id).text(localize('Sell at market'));
                }
                return;
            }

            $sell_wrapper.setVisibility(1).append($('<div/>', { id: sell_wrapper_id }).append($('<button/>', { id: sell_button_id, class: 'button', text: localize(is_started ? 'Sell at market' : 'Sell') })));
            if (is_started) {
                addSellNote($sell_wrapper);
            }

            $container.find('#' + sell_button_id).unbind('click').click(function (e) {
                e.preventDefault();
                e.stopPropagation();
                is_sell_clicked = true;
                sellSetVisibility(false);
                BinarySocket.send({ sell: contract_id, price: contract.bid_price }).then(function (response) {
                    responseSell(response);
                });
            });
        } else {
            if (!is_exist) return;
            $container.find('#' + sell_button_id).unbind('click');
            $container.find('#' + sell_wrapper_id).remove();
        }
    };

    var addSellNote = function addSellNote($sell_wrapper) {
        sell_text_updated = true;
        $sell_wrapper.find('#sell_at_market_wrapper').append($('<div/>', { class: 'note' }).append($('<strong/>', { text: localize('Note') + ': ' })).append($('<span/>', { text: localize('Contract will be sold at the prevailing market price when the request is received by our servers. This price may differ from the indicated price.') })));
    };

    // ===== Requests & Responses =====
    // ----- Get Contract -----
    var getContract = function getContract(option) {
        if (contract_id) {
            ViewPopupUI.forgetStreams();
            var req = {
                contract_id: contract_id,
                proposal_open_contract: 1,
                subscribe: 1
            };
            if (option === 'no-subscribe') delete req.subscribe;
            BinarySocket.send(req, { callback: responseProposal });
        }
    };

    var responseSell = function responseSell(response) {
        if (Utility.getPropertyValue(response, 'error')) {
            if (response.error.code === 'NoOpenPosition') {
                getContract();
            } else {
                $container.find('#errMsg').text(response.error.message).setVisibility(1);
            }
            sellSetVisibility(true);
            is_sell_clicked = false;
            return;
        }
        ViewPopupUI.forgetStreams();
        $container.find('#errMsg').setVisibility(0);
        sellSetVisibility(false);
        if (is_sell_clicked) {
            containerSetText('contract_sell_message', localize('You have sold this contract at [_1] [_2]', [contract.currency, response.sell.sold_for]) + '\n                <br />\n                ' + localize('Your transaction reference number is [_1]', [response.sell.transaction_id]));
        }
        getContract('no-subscribe');
    };

    var responseProposal = function responseProposal(response) {
        if (response.error) {
            if (response.error.code !== 'AlreadySubscribed' && response.echo_req.contract_id === contract_id) {
                showErrorPopup(response, response.error.message);
            }
            return;
        }
        if (response.proposal_open_contract.contract_id === contract_id) {
            ViewPopupUI.storeSubscriptionID(response.proposal_open_contract.id);
            responseContract(response);
        } else {
            BinarySocket.send({ forget: response.proposal_open_contract.id });
        }
        var dates = ['#trade_details_start_date', '#trade_details_end_date', '#trade_details_current_date', '#trade_details_live_date'];
        for (var i = 0; i < dates.length; i++) {
            Clock.showLocalTimeOnHover(dates[i]);
            $(dates[i]).attr('data-balloon-pos', 'left');
        }
    };

    var viewButtonOnClick = function viewButtonOnClick(container_selector) {
        $(container_selector).on('click', '.open_contract_details', function (e) {
            e.preventDefault();
            init(this);
        });
    };

    return {
        init: init,
        viewButtonOnClick: viewButtonOnClick
    };
}();
var addComma = __webpack_require__(7).addComma;

var formatMoney = __webpack_require__(7).formatMoney;

module.exports = ViewPopup;

/***/ }),
/* 91 */,
/* 92 */,
/* 93 */,
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Scroll = function () {
    var $main_container = void 0;

    var sidebarScroll = function sidebarScroll($container) {
        $main_container = $container;

        $container.on('click', '#sidebar-nav li', function () {
            var clicked_li = $(this);
            $.scrollTo($('.section:eq(' + clicked_li.index() + ')'), 500);
            return false;
        });

        if ($container.length) {
            // grab the initial top offset of the navigation
            var $sidebar = $container.find('.sidebar');
            var $sidebar_container = $container.find('.sidebar-container');
            var width = $sidebar.width();
            var sticky_navigation_offset_top = $sidebar.offset().top;

            // With thanks:
            // http://www.backslash.gr/content/blog/webdevelopment/6-navigation-menu-that-stays-on-top-with-jquery

            // our function that decides weather the navigation bar should have "fixed" css position or not.
            var sticky_navigation = function sticky_navigation() {
                if (!$sidebar.is(':visible')) return;
                if (!width) {
                    width = $sidebar.width();
                    sticky_navigation_offset_top = $sidebar.offset().top;
                }
                var scroll_top = $(window).scrollTop(); // our current vertical position from the top

                // if we've scrolled more than the navigation, change its position to fixed to stick to top,
                // otherwise change it back to relative
                if (scroll_top + $sidebar[0].offsetHeight > $sidebar_container[0].offsetHeight + $sidebar_container.offset().top) {
                    $sidebar.css({ position: 'absolute', bottom: 0, top: '', width: width });
                } else if (scroll_top > sticky_navigation_offset_top) {
                    $sidebar.css({ position: 'fixed', top: 0, bottom: '', width: width });
                } else {
                    $sidebar.css({ position: 'relative' });
                }
            };

            // run our function on load
            sticky_navigation();

            var sidebar_nav = $sidebar.find('#sidebar-nav');
            var length = $container.find('.section').length;
            $(window).on('scroll', function () {
                if (!sidebar_nav.is(':visible')) return;
                // and run it again every time you scroll
                sticky_navigation();

                for (var i = 0; i < length; i++) {
                    var section = $('.section:eq(' + i + ')');
                    var section_offset = section.offset();
                    var is_offset_top = section_offset && $(this).scrollTop() >= section_offset.top - 5;
                    if (($(window).scrollTop() === 0 || is_offset_top) && section.css('display') !== 'none') {
                        // ignore hidden elements
                        sidebar_nav.find('li').removeClass('selected');

                        if ($(window).scrollTop() === 0 || sidebar_nav.width() === 0) {
                            // We're at the top of the screen, so highlight first nav item
                            sidebar_nav.find('li:first-child').addClass('selected');
                        } else if ($(window).scrollTop() + $(window).height() >= $(document).height()) {
                            // We're at bottom of screen so highlight last nav item.
                            sidebar_nav.find('li:last-child').addClass('selected');
                        } else {
                            sidebar_nav.find('li:eq(' + i + ')').addClass('selected');
                        }
                    }
                }
            });
        }
    };

    var scrollToTop = function scrollToTop() {
        var is_displaying = false;
        var $scrollup = $('#scrollup');
        $(document).scroll(function () {
            if ($(this).scrollTop() > 100) {
                if (is_displaying) return;
                $scrollup.fadeIn();
                is_displaying = true;
            } else if (is_displaying) {
                $scrollup.fadeOut();
                is_displaying = false;
            }
        });

        $scrollup.click(function () {
            $.scrollTo(0, 500);
        });
    };

    return {
        sidebarScroll: sidebarScroll,
        scrollToTop: scrollToTop,
        offScroll: function offScroll() {
            $(window).off('scroll');
            if ($main_container) {
                $main_container.find('#sidebar-nav li').off('click');
                $main_container = '';
            }
        },
        goToHashSection: function goToHashSection() {
            $('a[href^="#"]').click(function () {
                $.scrollTo($('a[name="' + $(this).attr('href').substr(1) + '"]'), 500, { offset: -10 });
                return false;
            });
            var hash = window.location.hash;
            if (hash) $('a[href="' + hash + '"]').click();
        },
        scrollToHashSection: function scrollToHashSection() {
            var hash = window.location.hash;
            if (hash) $.scrollTo($(hash));
        }
    };
}();

module.exports = Scroll;

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var tabListener = __webpack_require__(25).tabListener;
var getElementById = __webpack_require__(4).getElementById;
var Url = __webpack_require__(8);
var applyToAllElements = __webpack_require__(1).applyToAllElements;

var TabSelector = function () {
    // obj_tabs will be built in the following format:
    // obj_tabs = { first_tab_group_selector_id: { id_tabs: [ id_of_tab_one, id_of_tab_two ] }
    // we will use id_tabs to handle which tab to show when going to the left or right tab
    var obj_tabs = {};

    var onLoad = function onLoad() {
        tabListener();
        obj_tabs = {};
        applyToAllElements('.tab-selector-wrapper .tm-ul', function (tab_selector) {
            var tab_selector_id = tab_selector.getAttribute('id');
            applyToAllElements('.tm-li', function (tab) {
                if (!/tab-selector/.test(tab.className)) {
                    var tab_id = tab.getAttribute('id');
                    if (!obj_tabs[tab_selector_id]) {
                        obj_tabs[tab_selector_id] = { id_tabs: [] };
                    }
                    if (!obj_tabs[tab_selector_id].circles) {
                        obj_tabs[tab_selector_id].circles = getElementById(tab_selector_id + '_circles').children;
                    }
                    obj_tabs[tab_selector_id].id_tabs.push(tab_id);
                }
                tab.addEventListener('click', slideSelectorOnMenuClick);
            }, '', tab_selector);
        });
        // set initial width and margin-left of tab selector
        repositionSelector();
        window.addEventListener('resize', repositionSelector);

        applyToAllElements('.go-left', function (element) {
            element.addEventListener('click', goLeft);
        });
        applyToAllElements('.go-right', function (element) {
            element.addEventListener('click', goRight);
        });
    };

    var repositionSelector = function repositionSelector() {
        var params_hash = Url.paramsHash();
        Object.keys(obj_tabs).forEach(function (tab_id) {
            var id_to_show = params_hash[tab_id] || obj_tabs[tab_id].id_tabs[0];
            var el_to_show = getElementById(id_to_show);
            if (el_to_show.parentNode) {
                var selector = el_to_show.parentNode.getAttribute('id');
                changeTab({ selector: selector, el_to_show: el_to_show });
            }
        });
    };

    var slideSelectorOnMenuClick = function slideSelectorOnMenuClick(e) {
        if (e.target.nodeName !== 'A' || /a-active/.test(e.target.classList)) {
            return;
        }
        var selector = e.target.closest('ul').getAttribute('id');
        var current_index = obj_tabs[selector].id_tabs.indexOf(e.target.parentNode.getAttribute('id'));
        slideSelector(selector, e.target);
        Array.from(obj_tabs[selector].circles).forEach(function (circle, idx) {
            if (idx === current_index) {
                circle.classList.add('selected');
            } else {
                circle.classList.remove('selected');
            }
        });
        updateURL(selector, e.target.parentNode.getAttribute('id'));
    };

    var updateURL = function updateURL(selector, tab_id) {
        Url.updateParamsWithoutReload(_defineProperty({}, selector, tab_id), true);
    };

    var goLeft = function goLeft(e) {
        changeTab({ selector: e.target.getAttribute('data-parent'), direction: 'left' });
    };

    var goRight = function goRight(e) {
        changeTab({ selector: e.target.getAttribute('data-parent'), direction: 'right' });
    };

    var changeTab = function changeTab(options) {
        var params_hash = Url.paramsHash();
        var arr_id_tabs = obj_tabs[options.selector].id_tabs;
        var id_selected_tab = params_hash[options.selector] || obj_tabs[options.selector].id_tabs[0];
        var current_index = arr_id_tabs.indexOf(id_selected_tab);
        var index_to_show = current_index;
        if (options.direction) {
            if (options.direction === 'left') {
                index_to_show = current_index > 0 ? current_index - 1 : arr_id_tabs.length - 1;
            } else {
                index_to_show = current_index === arr_id_tabs.length - 1 ? 0 : current_index + 1;
            }
            options.el_to_show = getElementById(arr_id_tabs[index_to_show]);
            updateURL(options.selector, arr_id_tabs[index_to_show]);
        }

        if (!options.el_to_show || !options.selector) {
            return;
        }

        selectCircle(options.selector, current_index, index_to_show);
        slideSelector(options.selector, options.el_to_show);
        options.el_to_show.getElementsByTagName('a')[0].click();

        if (params_hash.section) {
            setTimeout(function () {
                $.scrollTo($('#' + params_hash.section), 500, { offset: -10 });
            }, 500);
        }
    };

    var slideSelector = function slideSelector(selector, el_to_show) {
        getElementById(selector + '_selector').setAttribute('style', 'width: ' + el_to_show.offsetWidth + 'px; margin-left: ' + el_to_show.offsetLeft + 'px;');
    };

    var selectCircle = function selectCircle(selector, old_index, index_to_show) {
        if (obj_tabs[selector].circles.length > 1) {
            obj_tabs[selector].circles[old_index].classList.remove('selected');
            obj_tabs[selector].circles[index_to_show].classList.add('selected');
        }
    };

    var updateTabDisplay = function updateTabDisplay() {
        applyToAllElements('.tab-menu', function (el_tab_menu) {
            // hide tabs if there is only one tab visible
            var ul = el_tab_menu.querySelector('ul');
            if (ul) {
                var visible_tabs = Array.from(ul.children).filter(function (el) {
                    return !el.classList.contains('tab-selector') && (!el.dataset.show || el.dataset.show && el.classList.contains('data-show-visible'));
                });
                if (visible_tabs.length <= 1) el_tab_menu.setVisibility(0);
            }
            // resize tab selector
            if (el_tab_menu.querySelector('.tab-selector')) {
                repositionSelector();
            }
        });
    };

    var onUnload = function onUnload() {
        window.removeEventListener('resize', repositionSelector);

        applyToAllElements('.tm-li', function (element) {
            element.removeEventListener('click', slideSelectorOnMenuClick);
        });

        applyToAllElements('.go-left', function (element) {
            element.removeEventListener('click', goLeft);
        });
        applyToAllElements('.go-right', function (element) {
            element.removeEventListener('click', goRight);
        });
    };

    var onChangeTab = function onChangeTab(fn) {
        applyToAllElements('.go-left', function (element) {
            element.addEventListener('click', function (e) {
                fn({ selector: e.target.getAttribute('data-parent'), direction: 'left' });
            });
        });
        applyToAllElements('.go-right', function (element) {
            element.addEventListener('click', function (e) {
                fn({ selector: e.target.getAttribute('data-parent'), direction: 'right' });
            });
        });
    };

    return {
        onChangeTab: onChangeTab,
        onLoad: onLoad,
        onUnload: onUnload,
        repositionSelector: repositionSelector,
        slideSelector: slideSelector,
        updateTabDisplay: updateTabDisplay
    };
}();

module.exports = TabSelector;

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var SelectMatcher = __webpack_require__(25).select2Matcher;
var Cookies = __webpack_require__(50);
var generateBirthDate = __webpack_require__(166);
var FormManager = __webpack_require__(18);
var BinaryPjax = __webpack_require__(12);
var Client = __webpack_require__(3);
var BinarySocket = __webpack_require__(5);
var professionalClient = __webpack_require__(181);
var makeOption = __webpack_require__(4).makeOption;
var Geocoder = __webpack_require__(162);
var localize = __webpack_require__(2).localize;
var State = __webpack_require__(6).State;
var urlFor = __webpack_require__(8).urlFor;

var AccountOpening = function () {
    var redirectAccount = function redirectAccount() {
        var upgrade_info = Client.getUpgradeInfo();

        if (!upgrade_info.can_upgrade) {
            BinaryPjax.loadPreviousUrl();
            return -1;
        }

        if (!upgrade_info.is_current_path) {
            BinaryPjax.load(upgrade_info.upgrade_link);
            return 1;
        }
        return 0;
    };

    var populateForm = function populateForm(form_id, getValidations, is_financial) {
        getResidence(form_id, getValidations);
        generateBirthDate();
        if (State.getResponse('landing_company.financial_company.shortcode') === 'maltainvest') {
            professionalClient.init(is_financial, false);
        }
        if (Client.get('residence') !== 'jp') {
            Geocoder.init(form_id);
        }
    };

    var getResidence = function getResidence(form_id, getValidations) {
        BinarySocket.send({ residence_list: 1 }).then(function (response) {
            handleResidenceList(response.residence_list, form_id, getValidations);
        });
    };

    var handleResidenceList = function handleResidenceList(residence_list, form_id, getValidations) {
        if (residence_list.length > 0) {
            var $place_of_birth = $('#place_of_birth');
            var $tax_residence = $('#tax_residence');
            var $phone = $('#phone');
            var residence_value = Client.get('residence') || '';
            var residence_text = '';

            var $options = $('<div/>');
            residence_list.forEach(function (res) {
                $options.append(makeOption({ text: res.text, value: res.value, is_disabled: res.disabled }));

                if (residence_value === res.value) {
                    residence_text = res.text;
                    if (residence_value !== 'jp' && res.phone_idd && !$phone.val()) {
                        $phone.val('+' + res.phone_idd);
                    }
                }
            });

            $('#lbl_residence').html($('<strong/>', { text: residence_text }));

            if ($place_of_birth.length) {
                BinarySocket.wait('get_settings').then(function (response) {
                    var place_of_birth = response.get_settings.place_of_birth;
                    if (place_of_birth) {
                        var txt_place_of_birth = (residence_list.find(function (obj) {
                            return obj.value === place_of_birth;
                        }) || {}).text;
                        $place_of_birth.replaceWith($('<span/>', { text: txt_place_of_birth || place_of_birth, 'data-value': place_of_birth }));
                    } else {
                        $place_of_birth.html($options.html()).val(residence_value);
                    }
                    $place_of_birth.select2({
                        matcher: function matcher(params, data) {
                            return SelectMatcher(params, data);
                        }
                    });
                });
            }

            if ($tax_residence) {
                $tax_residence.html($options.html()).promise().done(function () {
                    setTimeout(function () {
                        $tax_residence.select2().val(getTaxResidence() || residence_value).trigger('change').setVisibility(1);
                    }, 500);
                });
            }

            BinarySocket.send({ states_list: Client.get('residence') }).then(function (data) {
                return handleState(data.states_list, form_id, getValidations);
            });
        }
    };

    var getTaxResidence = function getTaxResidence() {
        var tax_residence = State.getResponse('get_settings.tax_residence');
        return tax_residence ? tax_residence.split(',') : '';
    };

    var handleState = function handleState(states_list, form_id, getValidations) {
        var address_state_id = '#address_state';
        BinarySocket.wait('get_settings').then(function (response) {
            var $address_state = $(address_state_id);

            $address_state.empty();

            var client_state = response.get_settings.address_state;

            if (states_list && states_list.length > 0) {
                $address_state.append($('<option/>', { value: '', text: localize('Please select') }));
                states_list.forEach(function (state) {
                    $address_state.append($('<option/>', { value: state.value, text: state.text }));
                });
                if (client_state) {
                    $address_state.val(client_state);
                }
                $address_state.select2({
                    matcher: function matcher(params, data) {
                        return SelectMatcher(params, data);
                    }
                });
            } else {
                $address_state.replaceWith($('<input/>', { id: 'address_state', name: 'address_state', type: 'text', maxlength: '35', 'data-lpignore': true }));
                $address_state = $(address_state_id);
                if (client_state) {
                    $address_state.text(client_state);
                }
            }
            $address_state.parent().parent().setVisibility(1);

            if (form_id && typeof getValidations === 'function') {
                FormManager.init(form_id, getValidations());
            }
        });
    };

    var handleNewAccount = function handleNewAccount(response, message_type) {
        if (response.error) {
            var errorMessage = response.error.message;
            $('#submit-message').empty();
            $('#client_message').find('.notice-msg').text(response.msg_type === 'sanity_check' ? localize('There was some invalid character in an input field.') : errorMessage).end().setVisibility(1);
        } else {
            localStorage.setItem('is_new_account', 1);
            Client.processNewAccount({
                email: Client.get('email'),
                loginid: response[message_type].client_id,
                token: response[message_type].oauth_token,
                redirect_url: urlFor('user/set-currency')
            });
        }
    };

    var commonValidations = function commonValidations() {
        var req = [{ selector: '#salutation', validations: ['req'] }, { selector: '#first_name', validations: ['req', 'letter_symbol', ['length', { min: 2, max: 30 }]] }, { selector: '#last_name', validations: ['req', 'letter_symbol', ['length', { min: 2, max: 30 }]] }, { selector: '#date_of_birth', validations: ['req'] }, { selector: '#address_line_1', validations: ['req', 'address', ['length', { min: 1, max: 70 }]] }, { selector: '#address_line_2', validations: ['address', ['length', { min: 0, max: 70 }]] }, { selector: '#address_city', validations: ['req', 'letter_symbol', ['length', { min: 1, max: 35 }]] }, { selector: '#address_state', validations: $('#address_state').prop('nodeName') === 'SELECT' ? '' : ['letter_symbol', ['length', { min: 0, max: 35 }]] }, { selector: '#address_postcode', validations: [Client.get('residence') === 'gb' ? 'req' : '', 'postcode', ['length', { min: 0, max: 20 }]] }, { selector: '#phone', validations: ['req', 'phone', ['length', { min: 6, max: 35, value: function value() {
                    return $('#phone').val().replace(/^\+/, '');
                } }]] }, { selector: '#secret_question', validations: ['req'] }, { selector: '#secret_answer', validations: ['req', 'general', ['length', { min: 4, max: 50 }]] }, { selector: '#tnc', validations: [['req', { message: 'Please accept the terms and conditions.' }]], exclude_request: 1 }, { request_field: 'residence', value: Client.get('residence') }, { request_field: 'client_type', value: function value() {
                return $('#chk_professional').is(':checked') ? 'professional' : 'retail';
            } }];

        if (Cookies.get('affiliate_tracking')) {
            req.push({ request_field: 'affiliate_token', value: Cookies.getJSON('affiliate_tracking').t });
        }

        return req;
    };

    var selectCheckboxValidation = function selectCheckboxValidation(form_id) {
        var validations = [];
        var validation = void 0,
            id = void 0;
        $(form_id).find('select, input[type=checkbox]').each(function () {
            id = $(this).attr('id');
            if (!/^(tnc|address_state|chk_professional|chk_tax_id)$/.test(id)) {
                validation = { selector: '#' + id, validations: ['req'] };
                if (id === 'not_pep') {
                    validation.exclude_request = 1;
                    validation.validations = [['req', { message: localize('Please confirm that you are not a politically exposed person.') }]];
                }
                validations.push(validation);
            }
        });
        return validations;
    };

    var showHidePulser = function showHidePulser(should_show) {
        $('.upgrademessage').children('a').setVisibility(should_show);
    };

    return {
        redirectAccount: redirectAccount,
        populateForm: populateForm,
        handleNewAccount: handleNewAccount,
        commonValidations: commonValidations,
        selectCheckboxValidation: selectCheckboxValidation,
        showHidePulser: showHidePulser
    };
}();

module.exports = AccountOpening;

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var localize = __webpack_require__(2).localize;

/*
 * Notifications manages various notification messages
 *
 */

var MBNotifications = function () {
    /*
     * options: Object {
     *     text       : {string}  message text to display
     *     uid        : {string}  unique id to prevent duplicating the same message and also used to hide the message
     *     dismissible: {boolean} dismissible messages can be hidden by client
     * }
     */
    var showErrorMessage = function showErrorMessage(options) {
        var $note_wrapper = getContainer();
        var $this_uid = $note_wrapper.find('#' + options.uid);

        if (!options.uid || $this_uid.length === 0) {
            $note_wrapper.prepend(generateMessage(options));
        } else if ($this_uid.html() !== options.text) {
            $this_uid.replaceWith(generateMessage(options));
        }

        $.scrollTo($note_wrapper, 500, { offset: -5 });
        hideSpinnerShowTrading();
    };

    var generateMessage = function generateMessage(options) {
        var $message = $('<div class="notice-msg gr-12 center-text' + (options.dismissible ? ' dismissible' : '') + '"\n            ' + (options.uid ? ' id="' + options.uid + '"' : '') + '>' + localize(options.text) + '\n                ' + (options.dismissible ? '<div class="notification-dismiss">x</div>' : '') + '\n            </div>');

        if (options.dismissible) {
            $message.click(function () {
                dismissMessage(this);
            });
        }

        return $message;
    };

    var hideErrorMessage = function hideErrorMessage(uid) {
        if (uid) {
            getContainer().find('#' + uid).remove();
        }
    };

    var dismissMessage = function dismissMessage(obj) {
        $(obj).remove();
    };

    var getContainer = function getContainer() {
        return $('#notifications_wrapper');
    };

    var hideSpinnerShowTrading = function hideSpinnerShowTrading() {
        $('#main_loading').setVisibility(0);
        $('#mb-trading-wrapper').setVisibility(1);
    };

    return {
        hideSpinnerShowTrading: hideSpinnerShowTrading,

        show: showErrorMessage,
        hide: hideErrorMessage
    };
}();

module.exports = MBNotifications;

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var formatMoney = __webpack_require__(7).formatMoney;

var constants = {
    slider: {
        height: 14,
        fill: '#e98024',
        label: {
            color: '#fff',
            fontSize: '9px',
            offsetY: 4,
            offsetX: 6
        }
    },
    interval: {
        cap_width: 10,
        stroke: '#2a3052',
        strokeWidth: 2,
        label: {
            color: '#000',
            fontSize: '12px',
            offsetX: 2
        },
        top_label: {
            offsetY: -4
        },
        bottom_label: {
            offsetY: 13
        }
    },
    barrier_series_name: 'barrier_points'
};

var Callputspread = function () {
    var state = {
        el_slider: null,
        el_slider_label: null,
        el_interval: null,
        el_interval_top_label: null,
        el_interval_bottom_laber: null,
        chart: null,
        contract: null
    };

    /*
        METHODS THAT DRAW ON CHART:
    */

    var redrawInterval = function redrawInterval() {
        if (!state.chart || !state.contract) return;
        if (state.el_interval) {
            state.el_interval.destroy();
        }

        var _calcIntervalState = calcIntervalState(state.chart, state.contract),
            x = _calcIntervalState.x,
            y0 = _calcIntervalState.y0,
            y1 = _calcIntervalState.y1,
            top_label = _calcIntervalState.top_label,
            bottom_label = _calcIntervalState.bottom_label;

        var _constants$interval = constants.interval,
            cap_width = _constants$interval.cap_width,
            stroke = _constants$interval.stroke,
            strokeWidth = _constants$interval.strokeWidth;

        state.el_interval = state.chart.renderer.path(getIntervalPath(x, y0, y1, cap_width)).attr({
            stroke: stroke,
            'stroke-width': strokeWidth
        }).add();
        if (state.el_interval_top_label) {
            state.el_interval_top_label.destroy();
        }
        if (state.el_interval_bottom_laber) {
            state.el_interval_bottom_laber.destroy();
        }
        var _constants$interval$l = constants.interval.label,
            color = _constants$interval$l.color,
            fontSize = _constants$interval$l.fontSize,
            offsetX = _constants$interval$l.offsetX;

        var label_styles = {
            color: color,
            fontSize: fontSize,
            'z-index': -1
        };
        state.el_interval_top_label = state.chart.renderer.text(top_label, x + offsetX, y0 + constants.interval.top_label.offsetY, true).css(label_styles).add();
        state.el_interval_bottom_laber = state.chart.renderer.text(bottom_label, x + offsetX, y1 + constants.interval.bottom_label.offsetY, true).css(label_styles).add();
    };

    var redrawSlider = function redrawSlider() {
        if (!state.chart || !state.contract) return;
        if (state.el_slider) {
            state.el_slider.destroy();
        }

        var _calcSliderState = calcSliderState(state.chart, state.contract),
            x = _calcSliderState.x,
            y = _calcSliderState.y,
            width = _calcSliderState.width;

        var _constants$slider = constants.slider,
            height = _constants$slider.height,
            fill = _constants$slider.fill;

        state.el_slider = state.chart.renderer.path(getSliderPath(x, y, width, height)).attr({
            fill: fill,
            'stroke-width': 0
        }).add();
        if (state.el_slider_label) {
            state.el_slider_label.destroy();
        }
        var _constants$slider$lab = constants.slider.label,
            color = _constants$slider$lab.color,
            fontSize = _constants$slider$lab.fontSize,
            offsetX = _constants$slider$lab.offsetX,
            offsetY = _constants$slider$lab.offsetY;

        state.el_slider_label = state.chart.renderer.text(formatMoney(state.contract.currency, state.contract.bid_price), x + width / 2 + offsetX, y + offsetY, true).attr({ align: 'center' }).css({ color: color, fontSize: fontSize }).add();
    };

    /*
        Calc Functions (no side effects!):
    */

    var calcMarginRight = function calcMarginRight(contract) {
        var formatted_max_payout = formatMoney(contract.currency, contract.payout, true);
        // margin size is based on max payout char length
        return 15 + 7.5 * formatted_max_payout.length;
    };

    var calcSliderState = function calcSliderState(chart, contract) {
        var plot_end_x = chart.plotWidth + chart.plotLeft;
        var x_offset = (constants.interval.cap_width + constants.interval.strokeWidth) / 2;

        var _chart$series$find$da = chart.series.find(function (series) {
            return series.name === constants.barrier_series_name;
        }).data.map(function (point) {
            return point.plotY + chart.plotTop;
        }),
            _chart$series$find$da2 = _slicedToArray(_chart$series$find$da, 2),
            high_barrier_y = _chart$series$find$da2[0],
            low_barrier_y = _chart$series$find$da2[1];

        var contract_type = contract.contract_type,
            payout = contract.payout,
            bid_price = contract.bid_price;

        var k = contract_type === 'CALLSPREAD' ? 1 - bid_price / payout : bid_price / payout;
        return {
            x: plot_end_x + x_offset,
            y: high_barrier_y + (low_barrier_y - high_barrier_y) * k,
            width: calcMarginRight(contract) - 17
        };
    };

    var calcIntervalState = function calcIntervalState(chart, contract) {
        var plot_end_x = chart.plotWidth + chart.plotLeft;

        var _chart$series$find$da3 = chart.series.find(function (series) {
            return series.name === constants.barrier_series_name;
        }).data.map(function (point) {
            return point.plotY + chart.plotTop;
        }),
            _chart$series$find$da4 = _slicedToArray(_chart$series$find$da3, 2),
            high_barrier_y = _chart$series$find$da4[0],
            low_barrier_y = _chart$series$find$da4[1];

        var _map = [contract.payout, 0].map(function (payout) {
            return formatMoney(contract.currency, payout);
        }),
            _map2 = _slicedToArray(_map, 2),
            display_maximum_payout = _map2[0],
            display_minimum_payout = _map2[1];

        var _ref = contract.contract_type === 'CALLSPREAD' ? [display_maximum_payout, display_minimum_payout] : [display_minimum_payout, display_maximum_payout],
            _ref2 = _slicedToArray(_ref, 2),
            top_label = _ref2[0],
            bottom_label = _ref2[1];

        return {
            x: plot_end_x,
            y0: high_barrier_y,
            y1: low_barrier_y,
            top_label: top_label,
            bottom_label: bottom_label
        };
    };

    /*
        PUBLIC API:
    */

    var init = function init(chart, contract) {
        // Adds invisible points with barrier coordinates,
        // so barriers are always visible on the chart
        var x0 = contract.date_start * 1000;
        var high_barrier = contract.high_barrier,
            low_barrier = contract.low_barrier;

        chart.addSeries({
            name: constants.barrier_series_name,
            type: 'scatter',
            marker: { enabled: false },
            data: [{
                y: +high_barrier,
                x: x0
            }, {
                y: +low_barrier,
                x: x0
            }]
        });
        update(chart, contract);
    };

    var isCallputspread = function isCallputspread(contract_type) {
        return (/^(CALLSPREAD|PUTSPREAD)$/i.test(contract_type)
        );
    };

    var getChartOptions = function getChartOptions(contract) {
        return {
            marginRight: calcMarginRight(contract),
            redrawHandler: function redrawHandler() {
                return update();
            }
        };
    };

    var update = function update(chart, contract) {
        state.chart = chart || state.chart;
        state.contract = contract || state.contract;
        redrawInterval();
        redrawSlider();
    };

    return {
        init: init,
        isCallputspread: isCallputspread,
        getChartOptions: getChartOptions,
        update: update
    };
}();

/*
    HELPER FUNCTIONS THAT RETURN SVG PATH:
*/

var getSliderPath = function getSliderPath(x, y, width, height) {
    var half = height / 2;
    return ['M', x, y, 'l', half, -half, 'h', width, 'v', height, 'h', -width, 'z'];
};

var getIntervalPath = function getIntervalPath(x, y0, y1, cap_width) {
    var half_cap = cap_width / 2;
    return ['M', x, y0, 'h', cap_width, 'm', -half_cap, 0, 'v', y1 - y0, 'm', -half_cap, 0, 'h', cap_width];
};

module.exports = Callputspread;

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Barriers = __webpack_require__(124);
var updateWarmChart = __webpack_require__(31).updateWarmChart;
var DigitInfo = __webpack_require__(282);
var Defaults = __webpack_require__(23);
var getActiveTab = __webpack_require__(175).getActiveTab;
var Purchase = __webpack_require__(178);
var Tick = __webpack_require__(60);
var TickDisplay = __webpack_require__(126);
var MBDefaults = __webpack_require__(36);
var MBTick = __webpack_require__(123);
var BinarySocket = __webpack_require__(5);
var State = __webpack_require__(6).State;

var GetTicks = function () {
    var underlying = void 0;

    var request = function request(symbol, req, _callback) {
        underlying = State.get('is_mb_trading') ? MBDefaults.get('underlying') : Defaults.get('underlying');
        if (underlying && req && _callback && (underlying !== req.ticks_history || !req.subscribe)) {
            BinarySocket.send(req, { callback: _callback });
        } else {
            var sendRequest = function sendRequest() {
                BinarySocket.send(req || {
                    ticks_history: symbol || underlying,
                    style: 'ticks',
                    end: 'latest',
                    count: 20,
                    subscribe: 1
                }, {
                    callback: function callback(response) {
                        var type = response.msg_type;

                        if (typeof _callback === 'function') {
                            _callback(response);
                        }

                        if (State.get('is_mb_trading')) {
                            MBTick.processTickStream(response);
                            return;
                        }

                        if (type === 'tick') {
                            processTick(response);
                            if (getActiveTab() === 'tab_last_digit') {
                                DigitInfo.updateChart(response);
                            }
                        } else if (type === 'history') {
                            processHistory(response);
                            if (getActiveTab() === 'tab_last_digit') {
                                DigitInfo.showChart(response.echo_req.ticks_history, response.history.prices);
                            }
                        }
                    }
                });
            };

            if (!req || req.subscribe) {
                BinarySocket.send({ forget_all: ['ticks', 'candles'] }).then(function () {
                    sendRequest();
                });
            } else {
                sendRequest();
            }
        }
    };

    var processTick = function processTick(tick) {
        var symbol = underlying;
        if (tick.echo_req.ticks === symbol || tick.tick && tick.tick.symbol === symbol) {
            Tick.details(tick);
            Tick.display();
            TickDisplay.updateChart(tick);
            Purchase.updateSpotList();
            if (!Barriers.isBarrierUpdated()) {
                Barriers.display();
                Barriers.setBarrierUpdate(true);
            }
            updateWarmChart();
        }
    };

    var processHistory = function processHistory(res) {
        if (res.history && res.history.times && res.history.prices) {
            for (var i = 0; i < res.history.times.length; i++) {
                Tick.details({
                    tick: {
                        epoch: res.history.times[i],
                        quote: res.history.prices[i]
                    }
                });
            }
        }
    };

    return {
        request: request
    };
}();

module.exports = GetTicks;

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var moment = __webpack_require__(9);
var commonTrading = __webpack_require__(31);
var displayPriceMovement = __webpack_require__(47).displayPriceMovement;
var getStartDateNode = __webpack_require__(47).getStartDateNode;
var getTradingTimes = __webpack_require__(47).getTradingTimes;
var Contract = __webpack_require__(58);
var Defaults = __webpack_require__(23);
var getLookBackFormula = __webpack_require__(59).getFormula;
var isLookback = __webpack_require__(59).isLookback;
var BinarySocket = __webpack_require__(5);
var formatMoney = __webpack_require__(7).formatMoney;
var CommonFunctions = __webpack_require__(4);
var localize = __webpack_require__(2).localize;
var getPropertyValue = __webpack_require__(1).getPropertyValue;

/*
 * Price object handles all the functions we need to display prices
 *
 * We create Price proposal that we need to send to server to get price,
 * longcode and all other information that we need to get the price for
 * current contract
 *
 *
 * Usage:
 *
 * `socket.send(Price.proposal())` to send price proposal to sever
 * `Price.display()` to display the price details returned from server
 */
var Price = function () {
    var type_display_id_mapping = {};
    var form_id = 0;

    var createProposal = function createProposal(type_of_contract) {
        var proposal = {
            proposal: 1,
            subscribe: 1
        };

        var contract_type = type_of_contract;
        var start_date = getStartDateNode();
        var start_time = CommonFunctions.getElementById('time_start');
        var underlying = CommonFunctions.getElementById('underlying');
        var amount_type = CommonFunctions.getElementById('amount_type');
        var currency = CommonFunctions.getVisibleElement('currency');
        var payout = CommonFunctions.getElementById('amount');
        var expiry_type = CommonFunctions.getElementById('expiry_type');
        var duration = CommonFunctions.getElementById('duration_amount');
        var duration_unit = CommonFunctions.getElementById('duration_units');
        var end_date = CommonFunctions.getElementById('expiry_date');
        var barrier = CommonFunctions.getElementById('barrier');
        var high_barrier = CommonFunctions.getElementById('barrier_high');
        var low_barrier = CommonFunctions.getElementById('barrier_low');
        var prediction = CommonFunctions.getElementById('prediction');
        var selected_tick = CommonFunctions.getElementById('selected_tick');
        var multiplier = CommonFunctions.getElementById('multiplier');

        if (payout && CommonFunctions.isVisible(payout) && payout.value) {
            proposal.amount = parseFloat(payout.value);
        }

        if (multiplier && CommonFunctions.isVisible(multiplier) && multiplier.value) {
            proposal.amount = multiplier.value;
        }

        if (amount_type && CommonFunctions.isVisible(amount_type) && amount_type.value && !isLookback(type_of_contract)) {
            proposal.basis = amount_type.value;
        }

        if (isLookback(type_of_contract)) {
            proposal.basis = 'multiplier';
        }

        if (contract_type) {
            proposal.contract_type = type_of_contract;
        }

        if (currency && (currency.value || currency.getAttribute('value'))) {
            proposal.currency = currency.value || currency.getAttribute('value');
        }

        if (underlying && underlying.value) {
            proposal.symbol = underlying.value;
        }

        if (start_date && CommonFunctions.isVisible(start_date) && start_date.value !== 'now') {
            var time = start_time.value.split(':');
            var set_time = moment.utc(Number(start_date.value) * 1000).hour(time[0]).minute(time[1]);

            proposal.date_start = set_time ? set_time.unix() : undefined;
        }

        if (expiry_type && CommonFunctions.isVisible(expiry_type) && expiry_type.value === 'duration') {
            proposal.duration = parseInt(duration.value);
            proposal.duration_unit = duration_unit.value;
        } else if (expiry_type && CommonFunctions.isVisible(expiry_type) && expiry_type.value === 'endtime') {
            var end_date2 = end_date.getAttribute('data-value');
            var end_time2 = Defaults.get('expiry_time');
            if (!end_time2) {
                var trading_times = getTradingTimes();
                var trading_times_end_date2 = getPropertyValue(trading_times, [end_date2, underlying.value]);
                if (trading_times_end_date2 && trading_times_end_date2.length && trading_times_end_date2[0] !== '--') {
                    if (trading_times_end_date2.length > 1) {
                        end_time2 = trading_times_end_date2[1];
                    } else {
                        end_time2 = trading_times_end_date2;
                    }
                }
            }

            proposal.date_expiry = moment.utc(end_date2 + ' ' + (end_time2 || '23:59:59')).unix();
            // For stopping tick trade behaviour
            proposal.duration_unit = 'm';
        }

        if (barrier && CommonFunctions.isVisible(barrier) && barrier.value) {
            proposal.barrier = barrier.value;
        }

        if (high_barrier && CommonFunctions.isVisible(high_barrier) && high_barrier.value) {
            proposal.barrier = high_barrier.value;
        }

        if (low_barrier && CommonFunctions.isVisible(low_barrier) && low_barrier.value) {
            proposal.barrier2 = low_barrier.value;
        }

        if (prediction && CommonFunctions.isVisible(prediction)) {
            proposal.barrier = parseInt(prediction.value);
        }

        if (selected_tick && CommonFunctions.isVisible(selected_tick)) {
            proposal.selected_tick = parseInt(selected_tick.value);
            // the only possibility for duration and duration tick is 5 ticks
            // so we show a label and directly pass those values here
            proposal.duration = Defaults.get('duration_amount');
            proposal.duration_unit = Defaults.get('duration_units');
        }

        if (contract_type) {
            proposal.contract_type = type_of_contract;
        }

        proposal.passthrough = {
            form_id: form_id
        };

        commonTrading.resetPriceMovement();

        return proposal;
    };

    var display = function display(details, contract_type) {
        var proposal = details.proposal;
        var id = proposal ? proposal.id : '';
        var params = details.echo_req;

        var type = params.contract_type;
        if (id && !type) {
            type = type_display_id_mapping[id];
        }

        if (params && id && Object.getOwnPropertyNames(params).length > 0) {
            type_display_id_mapping[id] = type;
        }

        var position = commonTrading.contractTypeDisplayMapping(type);

        if (!position) {
            return;
        }

        // hide all containers except current one
        if (position === 'middle') {
            if ($('#price_container_top').is(':visible') || $('#price_container_bottom').is(':visible')) {
                $('#price_container_top').fadeOut(0);
                $('#price_container_bottom').fadeOut(0);
            }
        } else if ($('#price_container_middle').is(':visible')) {
            $('#price_container_middle').fadeOut(0);
        }

        var container = CommonFunctions.getElementById('price_container_' + position);
        if (!container) return;
        if (!$(container).is(':visible')) {
            $(container).fadeIn(200);
        }

        var h4 = container.getElementsByClassName('contract_heading')[0];
        var amount = container.getElementsByClassName('contract_amount')[0];
        var payout_amount = container.getElementsByClassName('contract_payout')[0];
        var contract_multiplier = container.getElementsByClassName('contract_multiplier')[0];
        var stake = container.getElementsByClassName('stake')[0];
        var payout = container.getElementsByClassName('payout')[0];
        var multiplier = container.getElementsByClassName('multiplier')[0];
        var purchase = container.getElementsByClassName('purchase_button')[0];
        var description = container.getElementsByClassName('contract_description')[0];
        var longcode = container.getElementsByClassName('contract_longcode')[0];
        var comment = container.getElementsByClassName('price_comment')[0];
        var error = container.getElementsByClassName('contract_error')[0];
        var currency = CommonFunctions.getVisibleElement('currency');

        if (!h4) return;
        var display_text = type && contract_type ? contract_type[type] : '';
        if (display_text) {
            h4.setAttribute('class', 'contract_heading ' + type);
            CommonFunctions.elementTextContent(h4, display_text);
        }

        var setData = function setData() {
            var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            if (!data.display_value) {
                amount.classList.remove('price_moved_up', 'price_moved_down');
            }
            CommonFunctions.elementTextContent(stake, localize('Stake') + ': ');
            CommonFunctions.elementInnerHtml(amount, data.display_value ? formatMoney(currency.value || currency.getAttribute('value'), data.display_value) : '-');

            if (!data.payout) {
                amount.classList.remove('price_moved_up', 'price_moved_down');
            }
            CommonFunctions.elementTextContent(payout, localize('Payout') + ': ');
            CommonFunctions.elementInnerHtml(payout_amount, data.payout ? formatMoney(currency.value || currency.getAttribute('value'), data.payout) : '-');
            // Lookback multiplier
            CommonFunctions.elementTextContent(multiplier, localize('Multiplier') + ': ');
            CommonFunctions.elementInnerHtml(contract_multiplier, data.multiplier ? formatMoney(currency.value || currency.getAttribute('value'), data.multiplier, false, 3, 2) : '-');

            if (data.longcode && window.innerWidth > 500) {
                if (description) description.setAttribute('data-balloon', data.longcode);
                if (longcode) CommonFunctions.elementTextContent(longcode, data.longcode);
            } else {
                if (description) description.removeAttribute('data-balloon');
                if (longcode) CommonFunctions.elementTextContent(longcode, '');
            }
        };

        var setPurchaseStatus = function setPurchaseStatus(enable) {
            purchase.parentNode.classList[enable ? 'remove' : 'add']('button-disabled');
        };

        if (details.error) {
            setPurchaseStatus(0);
            comment.hide();
            setData();
            error.show();
            CommonFunctions.elementTextContent(error, details.error.message);
        } else {
            setData(proposal);
            if ($('#websocket_form').find('.error-field:visible').length > 0) {
                setPurchaseStatus(0);
            } else {
                setPurchaseStatus(1);
            }
            comment.show();
            error.hide();
            if (isLookback(type)) {
                CommonFunctions.elementInnerHtml(comment, localize('Payout') + ': ' + getLookBackFormula(type));
            } else {
                commonTrading.displayCommentPrice(comment, currency.value || currency.getAttribute('value'), proposal.ask_price, proposal.payout);
            }
            var old_price = purchase.getAttribute('data-display_value');
            var old_payout = purchase.getAttribute('data-payout');
            if (amount) displayPriceMovement(amount, old_price, proposal.display_value);
            if (payout_amount) displayPriceMovement(payout_amount, old_payout, proposal.payout);
            purchase.setAttribute('data-purchase-id', id);
            purchase.setAttribute('data-ask-price', proposal.ask_price);
            purchase.setAttribute('data-display_value', proposal.display_value);
            purchase.setAttribute('data-payout', proposal.payout);
            purchase.setAttribute('data-symbol', id);
            Object.keys(params).forEach(function (key) {
                if (key && key !== 'proposal') {
                    purchase.setAttribute('data-' + key, params[key]);
                }
            });
        }
    };

    var clearMapping = function clearMapping() {
        type_display_id_mapping = {};
    };

    var clearFormId = function clearFormId() {
        form_id = 0;
    };

    /*
     * Function to request for cancelling the current price proposal
     */
    var processForgetProposals = function processForgetProposals() {
        commonTrading.showPriceOverlay();
        var forget_proposal = BinarySocket.send({ forget_all: 'proposal' });
        forget_proposal.then(function () {
            Price.clearMapping();
        });
        return forget_proposal;
    };

    var processForgetProposalOpenContract = function processForgetProposalOpenContract() {
        return BinarySocket.send({ forget_all: 'proposal_open_contract' });
    };

    /*
     * Function to process and calculate price based on current form
     * parameters or change in form parameters
     */
    var processPriceRequest = function processPriceRequest() {
        Price.incrFormId();
        commonTrading.showPriceOverlay();
        var types = Contract.contractType()[Contract.form()];
        if (Contract.form() === 'digits') {
            switch (sessionStorage.getItem('formname')) {
                case 'matchdiff':
                    types = {
                        DIGITMATCH: 1,
                        DIGITDIFF: 1
                    };
                    break;
                case 'evenodd':
                    types = {
                        DIGITEVEN: 1,
                        DIGITODD: 1
                    };
                    break;
                case 'overunder':
                    types = {
                        DIGITOVER: 1,
                        DIGITUNDER: 1
                    };
                    break;
                default:
                    break;
            }
        }

        if (Contract.form() === 'lookback') {
            switch (sessionStorage.getItem('formname')) {
                case 'lookbackhigh':
                    types = {
                        LBFLOATPUT: 1
                    };
                    break;
                case 'lookbacklow':
                    types = {
                        LBFLOATCALL: 1
                    };
                    break;
                case 'lookbackhighlow':
                    types = {
                        LBHIGHLOW: 1
                    };
                    break;
                default:
                    break;
            }
        }

        processForgetProposalOpenContract();
        processForgetProposals().then(function () {
            Object.keys(types || {}).forEach(function (type_of_contract) {
                BinarySocket.send(Price.proposal(type_of_contract), { callback: function callback(response) {
                        if (response.error && response.error.code === 'AlreadySubscribed') {
                            BinarySocket.send({ forget_all: 'proposal' });
                        } else if (response.echo_req && response.echo_req !== null && response.echo_req.passthrough && response.echo_req.passthrough.form_id === form_id) {
                            Price.display(response, Contract.contractType()[Contract.form()]);
                        }
                        commonTrading.hideOverlayContainer();
                        commonTrading.hidePriceOverlay();
                    } });
            });
        });
    };

    return {
        display: display,
        clearMapping: clearMapping,
        clearFormId: clearFormId,
        processForgetProposals: processForgetProposals,
        processForgetProposalOpenContract: processForgetProposalOpenContract,
        processPriceRequest: processPriceRequest,

        proposal: createProposal,
        idDisplayMapping: function idDisplayMapping() {
            return type_display_id_mapping;
        },
        incrFormId: function incrFormId() {
            form_id++;
        }
    };
}();

module.exports = Price;

/***/ }),
/* 101 */,
/* 102 */,
/* 103 */,
/* 104 */,
/* 105 */,
/* 106 */,
/* 107 */,
/* 108 */,
/* 109 */,
/* 110 */,
/* 111 */,
/* 112 */,
/* 113 */,
/* 114 */,
/* 115 */,
/* 116 */,
/* 117 */,
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var getLanguage = __webpack_require__(16).get;
var localize = __webpack_require__(2).localize;
var State = __webpack_require__(6).State;
var getPropertyValue = __webpack_require__(1).getPropertyValue;

var currencies_config = {};

var formatMoney = function formatMoney(currency_value, amount, exclude_currency) {
    var decimals = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    var minimumFractionDigits = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;

    var money = amount;
    if (money) money = String(money).replace(/,/g, '');
    var sign = money && Number(money) < 0 ? '-' : '';
    var decimal_places = decimals || getDecimalPlaces(currency_value);

    money = isNaN(money) ? 0 : Math.abs(money);
    if (typeof Intl !== 'undefined') {
        var options = {
            minimumFractionDigits: minimumFractionDigits || decimal_places,
            maximumFractionDigits: decimal_places
        };
        money = new Intl.NumberFormat(getLanguage().toLowerCase().replace('_', '-'), options).format(money);
    } else {
        money = addComma(money, decimal_places);
    }

    return sign + (exclude_currency ? '' : formatCurrency(currency_value)) + money;
};

var formatCurrency = function formatCurrency(currency) {
    return '<span class="symbols ' + (currency || '').toLowerCase() + '"></span>';
}; // defined in binary-style

var addComma = function addComma(num, decimal_points, is_crypto) {
    var number = String(num || 0).replace(/,/g, '');
    if (typeof decimal_points !== 'undefined') {
        number = (+number).toFixed(decimal_points);
    }
    if (is_crypto) {
        number = parseFloat(+number);
    }

    return number.toString().replace(/(^|[^\w.])(\d{4,})/g, function ($0, $1, $2) {
        return $1 + $2.replace(/\d(?=(?:\d\d\d)+(?!\d))/g, '$&,');
    });
};

var isJPClient = function isJPClient() {
    return !!State.get('is_jp_client');
};

var getFiatDecimalPlaces = function getFiatDecimalPlaces() {
    return isJPClient() ? 0 : 2;
};

var calcDecimalPlaces = function calcDecimalPlaces(currency) {
    return isCryptocurrency(currency) ? 8 : getFiatDecimalPlaces();
};

var getDecimalPlaces = function getDecimalPlaces(currency) {
    return (
        // need to check currencies_config[currency] exists instead of || in case of 0 value
        currencies_config[currency] ? getPropertyValue(currencies_config, [currency, 'fractional_digits']) : calcDecimalPlaces(currency)
    );
};

var setCurrencies = function setCurrencies(website_status) {
    currencies_config = website_status.currencies_config;
};

// (currency in crypto_config) is a back-up in case website_status doesn't include the currency config, in some cases where it's disabled
var isCryptocurrency = function isCryptocurrency(currency) {
    return (/crypto/i.test(getPropertyValue(currencies_config, [currency, 'type'])) || currency in crypto_config
    );
};

var crypto_config = {
    BTC: { name: 'Bitcoin', min_withdrawal: 0.002, pa_max_withdrawal: 5, pa_min_withdrawal: 0.002 },
    BCH: { name: 'Bitcoin Cash', min_withdrawal: 0.002, pa_max_withdrawal: 5, pa_min_withdrawal: 0.002 },
    ETH: { name: 'Ether', min_withdrawal: 0.002, pa_max_withdrawal: 5, pa_min_withdrawal: 0.002 },
    ETC: { name: 'Ether Classic', min_withdrawal: 0.002, pa_max_withdrawal: 5, pa_min_withdrawal: 0.002 },
    LTC: { name: 'Litecoin', min_withdrawal: 0.002, pa_max_withdrawal: 5, pa_min_withdrawal: 0.002 },
    DAI: { name: 'Dai', min_withdrawal: 0.002, pa_max_withdrawal: 2000, pa_min_withdrawal: 10 }
};

var getMinWithdrawal = function getMinWithdrawal(currency) {
    return isCryptocurrency(currency) ? getPropertyValue(crypto_config, [currency, 'min_withdrawal']) || 0.002 : 1;
};

// @param {String} limit = max|min
var getPaWithdrawalLimit = function getPaWithdrawalLimit(currency, limit) {
    if (isCryptocurrency(currency)) {
        return getPropertyValue(crypto_config, [currency, 'pa_' + limit + '_withdrawal']);
    }
    return limit === 'max' ? 2000 : 10;
};

var getCurrencyName = function getCurrencyName(currency) {
    return localize(getPropertyValue(crypto_config, [currency, 'name']) || '');
};

var getMinPayout = function getMinPayout(currency) {
    return getPropertyValue(currencies_config, [currency, 'stake_default']);
};

module.exports = {
    formatMoney: formatMoney,
    formatCurrency: formatCurrency,
    addComma: addComma,
    getDecimalPlaces: getDecimalPlaces,
    setCurrencies: setCurrencies,
    isCryptocurrency: isCryptocurrency,
    getCurrencyName: getCurrencyName,
    getMinWithdrawal: getMinWithdrawal,
    getMinPayout: getMinPayout,
    getPaWithdrawalLimit: getPaWithdrawalLimit,
    getCurrencies: function getCurrencies() {
        return currencies_config;
    }
};

/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isEmptyObject = __webpack_require__(1).isEmptyObject;

var ActiveSymbols = function () {
    var groupBy = function groupBy(xs, key) {
        return xs.reduce(function (rv, x) {
            (rv[x[key]] = rv[x[key]] || []).push(x);
            return rv;
        }, {});
    };

    var extend = function extend(a, b) {
        if (!a || !b) return null;
        Object.keys(b).forEach(function (key) {
            a[key] = b[key];
        });
        return a;
    };

    var clone = function clone(obj) {
        return extend({}, obj);
    };

    var markets = {};
    var submarkets = {};
    var symbols = {};

    var getMarkets = function getMarkets(all_symbols) {
        if (!isEmptyObject(markets)) {
            return clone(markets);
        }

        var all_markets = groupBy(all_symbols, 'market');
        Object.keys(all_markets).forEach(function (key) {
            var market_name = key;
            var market_symbols = all_markets[key];
            var symbol = market_symbols[0];
            markets[market_name] = {
                name: symbol.market_display_name,
                is_active: !symbol.is_trading_suspended && symbol.exchange_is_open
            };
            getSubmarketsForMarket(market_symbols, markets[market_name]);
        });
        return clone(markets);
    };

    var clearData = function clearData() {
        markets = {};
        symbols = {};
        submarkets = {};
    };

    var getSubmarketsForMarket = function getSubmarketsForMarket(all_symbols, market) {
        if (!isEmptyObject(market.submarkets)) {
            return clone(market.submarkets);
        }
        market.submarkets = {};

        var all_submarkets = groupBy(all_symbols, 'submarket');

        Object.keys(all_submarkets).forEach(function (key) {
            var submarket_name = key;
            var submarket_symbols = all_submarkets[key];
            var symbol = submarket_symbols[0];

            market.submarkets[submarket_name] = {
                name: symbol.submarket_display_name,
                is_active: !symbol.is_trading_suspended && symbol.exchange_is_open
            };

            getSymbolsForSubmarket(submarket_symbols, market.submarkets[submarket_name]);
        });
        return clone(market.submarkets);
    };

    var getSymbolsForSubmarket = function getSymbolsForSubmarket(all_symbols, submarket) {
        if (isEmptyObject(submarket.symbols)) {
            submarket.symbols = {};
            all_symbols.forEach(function (symbol) {
                submarket.symbols[symbol.symbol] = {
                    display: symbol.display_name,
                    symbol_type: symbol.symbol_type,
                    is_active: !symbol.is_trading_suspended && symbol.exchange_is_open,
                    pip: symbol.pip,
                    market: symbol.market,
                    submarket: symbol.submarket
                };
            });
        }
        return clone(submarket.symbols);
    };

    var getSubmarkets = function getSubmarkets(active_symbols) {
        if (isEmptyObject(submarkets)) {
            var all_markets = getMarkets(active_symbols);
            Object.keys(all_markets).forEach(function (key) {
                var market = all_markets[key];
                var all_submarkets = getSubmarketsForMarket(active_symbols, market);
                extend(submarkets, all_submarkets);
            });
        }
        return clone(submarkets);
    };

    var getSymbols = function getSymbols(active_symbols) {
        if (isEmptyObject(symbols)) {
            var all_submarkets = getSubmarkets(active_symbols);
            Object.keys(all_submarkets).forEach(function (key) {
                var submarket = all_submarkets[key];
                var all_symbols = getSymbolsForSubmarket(active_symbols, submarket);
                extend(symbols, all_symbols);
            });
        }
        return clone(symbols);
    };

    var getMarketsList = function getMarketsList(active_symbols) {
        var trade_markets_list = {};
        extend(trade_markets_list, getMarkets(active_symbols));
        extend(trade_markets_list, getSubmarkets(active_symbols));
        return trade_markets_list;
    };

    var getTradeUnderlyings = function getTradeUnderlyings(active_symbols) {
        var trade_underlyings = {};
        var all_symbols = getSymbols(active_symbols);
        Object.keys(all_symbols).forEach(function (key) {
            var symbol = all_symbols[key];
            if (!trade_underlyings[symbol.market]) {
                trade_underlyings[symbol.market] = {};
            }
            if (!trade_underlyings[symbol.submarket]) {
                trade_underlyings[symbol.submarket] = {};
            }
            trade_underlyings[symbol.market][key] = symbol;
            trade_underlyings[symbol.submarket][key] = symbol;
        });
        return trade_underlyings;
    };

    var getSymbolNames = function getSymbolNames(active_symbols) {
        var all_symbols = clone(getSymbols(active_symbols));
        Object.keys(all_symbols).forEach(function (key) {
            all_symbols[key] = all_symbols[key].display;
        });
        return all_symbols;
    };

    return {
        getMarkets: getMarkets,
        getSubmarkets: getSubmarkets,
        getMarketsList: getMarketsList,
        getTradeUnderlyings: getTradeUnderlyings,
        getSymbolNames: getSymbolNames,
        clearData: clearData,
        getSymbols: getSymbols
    };
}();

module.exports = ActiveSymbols;

/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Table = __webpack_require__(76);

var FlexTableUI = function () {
    var config = void 0;

    var init = function init(conf) {
        config = conf;

        var $tableContainer = Table.createFlexTable([], getMetadata(), config.header, config.footer);

        // Table.appendTablebody expects the table to already
        // exist in the DOM, so we need to append first
        $tableContainer.appendTo(config.container);
        extend(config.data);
    };

    var getMetadata = function getMetadata() {
        return {
            id: config.id,
            tableClass: config.class,
            cols: config.cols
        };
    };

    var extend = function extend(data) {
        var cols = config.cols;
        var formatter = config.formatter;
        var style = config.style;
        Table.appendTableBody(config.id, data, function (datum) {
            var $row = Table.createFlexTableRow(formatter(datum), cols, 'data');
            if (style) {
                style($row, datum);
            }
            return $row[0];
        });
    };

    var displayError = function displayError(message, colspan) {
        var $tr = $('<tr/>', { class: 'flex-tr' });
        var $td = $('<td/>', { colspan: colspan });
        var $p = $('<p/>', { class: 'notice-msg center-text', text: message });
        return $('#' + config.id + ' tbody').append($tr.append($td.append($p)));
    };

    var replace = function replace(data) {
        if (config) {
            Table.clearTableBody(config.id);
            extend(data);
        }
    };

    var clear = function clear() {
        if (config) {
            replace([]);
            $('#' + config.id + ' > tfoot').hide();
        }
    };

    return {
        init: init,
        displayError: displayError,
        replace: replace,
        clear: clear
    };
}();

module.exports = FlexTableUI;

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Validation = __webpack_require__(56);
var getElementById = __webpack_require__(4).getElementById;
var createElement = __webpack_require__(1).createElement;

var cache = {};

var showPopup = function showPopup(options) {
    if (cache[options.url]) {
        callback(options);
    } else {
        var xhttp = new XMLHttpRequest();
        xhttp.onreadystatechange = function () {
            if (this.readyState !== 4 || this.status !== 200) {
                return;
            }
            cache[options.url] = this.responseText;
            callback(options);
        };
        xhttp.open('GET', options.url, true);
        xhttp.send();
    }
};

var callback = function callback(options) {
    var div = createElement('div', { html: cache[options.url] });
    var lightbox = createElement('div', { id: options.popup_id, class: 'lightbox' });
    lightbox.appendChild(div.querySelector(options.content_id));
    document.body.appendChild(lightbox);

    if (options.validations) {
        Validation.init(options.form_id, options.validations);
    }

    if (typeof options.additionalFunction === 'function') {
        options.additionalFunction(lightbox);
    }

    getElementById(options.form_id.slice(1)).addEventListener('submit', function (e) {
        e.preventDefault();
        if (options.validations) {
            if (Validation.validate(options.form_id)) {
                if (lightbox) {
                    lightbox.remove();
                }
                if (typeof options.onAccept === 'function') {
                    options.onAccept();
                }
            }
        } else if (lightbox) {
            lightbox.remove();
        }
    });
};

module.exports = showPopup;

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var MBContract = __webpack_require__(77);
var MBDefaults = __webpack_require__(36);
var MBNotifications = __webpack_require__(97);
var TradingAnalysis = __webpack_require__(88);
var redrawChart = __webpack_require__(89).redrawChart;
var ViewPopup = __webpack_require__(90);
var Client = __webpack_require__(3);
var BinarySocket = __webpack_require__(5);
var formatMoney = __webpack_require__(7).formatMoney;
var GTM = __webpack_require__(54);
var localize = __webpack_require__(2).localize;
var isEmptyObject = __webpack_require__(1).isEmptyObject;

/*
 * Price object handles all the functions we need to display prices
 *
 * We create Price proposal that we need to send to server to get price,
 * longcode and all other information that we need to get the price for
 * current contract
 *
 */

var MBPrice = function () {
    var price_selector = '.prices-wrapper .price-rows';

    var prices = {};
    var contract_types = {};
    var el_rows = {};
    var barriers = [];
    var req_id = 0;
    var is_displayed = false;
    var is_unwelcome = false;

    var $table = void 0;

    var addPriceObj = function addPriceObj(req) {
        req.barriers.forEach(function (barrier_obj) {
            var barrier = makeBarrier(barrier_obj);
            if (!prices[barrier]) {
                prices[barrier] = {};
            }
            req.contract_type.forEach(function (c_type) {
                prices[barrier][c_type] = {};
                if (!contract_types[c_type]) {
                    contract_types[c_type] = MBContract.getTemplate(c_type);
                }
            });
        });
    };

    var updateTabsAndChart = function updateTabsAndChart() {
        TradingAnalysis.bindAnalysisTabEvent();
        TradingAnalysis.request();
        redrawChart();
    };

    var makeBarrier = function makeBarrier(barrier_object) {
        if (!barrier_object.barrier && barrier_object.error) {
            // error.details will include the barrier value in case of error
            // it is intended to change the original object as we need the barrier value
            barrier_object = barrier_object.error.details; // eslint-disable-line no-param-reassign
        }
        return (barrier_object.barrier2 ? barrier_object.barrier2 + '_' : '') + barrier_object.barrier;
    };

    var display = function display(response) {
        if (isEmptyObject(response.proposal_array.proposals)) {
            // ignore invalid responses
            updateTabsAndChart();
            return;
        }
        Object.keys(response.proposal_array.proposals).forEach(function (contract_type) {
            response.proposal_array.proposals[contract_type].forEach(function (proposal) {
                var barrier = makeBarrier(proposal);
                var prev_proposal = $.extend({}, prices[barrier][contract_type]);
                prices[barrier][contract_type] = $.extend({ echo_req: response.echo_req }, proposal);

                // update previous ask_price to use in price movement
                if (!isEmptyObject(prev_proposal) && !prev_proposal.error) {
                    prices[barrier][contract_type].prev_price = prev_proposal.ask_price;
                }
            });
        });

        if (!is_displayed) {
            populateTable();
        }
        updatePrices();
    };

    var populateTable = function populateTable() {
        if (!$table) {
            $table = $(price_selector);
        }
        $table.off('click', 'button.price-button').on('click', 'button.price-button', processBuy);

        BinarySocket.wait('get_account_status').then(function (response) {
            is_unwelcome = /unwelcome/.test(response.get_account_status.status);
            if (is_unwelcome) {
                MBNotifications.show({
                    text: localize('Sorry, your account is not authorised for any further contract purchases.'),
                    uid: 'UNWELCOME',
                    dismissible: false
                });
            }
        });

        if (!barriers.length) {
            barriers = Object.keys(prices).sort(function (a, b) {
                return +b.split('_')[0] - +a.split('_')[0];
            });
        }

        var el_price_row = document.querySelector('#templates .price-row');
        if (Client.isJPClient()) {
            el_price_row.querySelectorAll('.base-value').forEach(function (el) {
                el.classList.remove('invisible');
            });
        }
        barriers.forEach(function (barrier) {
            el_rows[barrier] = {};
            var el_row = el_price_row.cloneNode(true);
            el_row.setAttribute('data-barrier', barrier);
            el_row.querySelector('.barrier').innerHTML = barrier.replace(/_/g, '<br />');
            Object.keys(contract_types).forEach(function (contract_type) {
                if (!el_rows[barrier][contract_type]) {
                    el_rows[barrier][contract_type] = {};
                }

                var order = contract_types[contract_type].order;
                var el_buy = el_row.querySelectorAll('.buy-price button')[order];
                var el_sell = el_row.querySelectorAll('.sell-price .price-wrapper')[order];

                el_buy.setAttribute('data-barrier', barrier);
                el_buy.setAttribute('data-contract_type', contract_type);

                el_rows[barrier][contract_type].buy = {
                    btn: el_buy,
                    dyn: el_buy.getElementsByClassName('dynamics')[0],
                    val: el_buy.getElementsByClassName('value')[0]
                };
                el_rows[barrier][contract_type].sell = {
                    sell: el_sell,
                    val: el_sell.getElementsByClassName('value')[0]
                };

                if (Client.isJPClient()) {
                    el_rows[barrier][contract_type].buy.base_value = el_buy.getElementsByClassName('base-value')[0];
                    el_rows[barrier][contract_type].sell.base_value = el_sell.getElementsByClassName('base-value')[0];
                }

                updatePriceRow(getValues(prices[barrier][contract_type], contract_type));
            });
            $table.append(el_row);
        });

        hidePriceOverlay();
        MBNotifications.hideSpinnerShowTrading();
        is_displayed = true;

        // Analysis should be initialised after contents being displayed,
        // so the chart is able to get the proper container width/height
        updateTabsAndChart();
    };

    var updatePrices = function updatePrices() {
        Object.keys(contract_types).forEach(function (contract_type) {
            barriers.forEach(function (barrier) {
                var proposal = prices[barrier][contract_type];
                var price_rows = document.querySelectorAll(price_selector + ' div[data-barrier="' + makeBarrier(proposal) + '"]');

                if (!price_rows.length) return;

                var contract_type_opp = contract_types[contract_type].opposite;

                updatePriceRow(getValues(proposal, contract_type));
                updatePriceRow(getValues(prices[barrier][contract_type_opp], contract_type_opp));
            });
        });
    };

    var getValues = function getValues(proposal, contract_type) {
        var barrier = makeBarrier(proposal);
        var payout = proposal.echo_req.amount;
        var proposal_opp = prices[barrier][contract_types[contract_type].opposite];
        var time_left = MBContract.getRemainingTime();
        return {
            contract_type: contract_type,
            barrier: barrier,
            payout: payout / 1000,
            is_active: !proposal.error && proposal.ask_price && !is_unwelcome && time_left > 120,
            message: proposal.error && proposal.error.code !== 'RateLimit' ? proposal.error.message : '',
            ask_price: getAskPrice(proposal),
            sell_price: payout - getAskPrice(proposal_opp),
            ask_price_movement: !proposal.error ? getMovementDirection(proposal.prev_price, proposal.ask_price) : '',
            sell_price_movement: proposal_opp && !proposal_opp.error ? getMovementDirection(proposal_opp.ask_price, proposal_opp.prev_price) : ''
        };
    };

    var getAskPrice = function getAskPrice(proposal) {
        return (
            // In case of RateLimit error, there is no display_value, so we display the request amount
            proposal.error || +proposal.ask_price === 0 ? proposal.echo_req.amount : proposal.ask_price
        );
    };

    var getMovementDirection = function getMovementDirection(prev, current) {
        var movement = '';
        if (prev !== current) {
            movement = current > prev ? 'up' : 'down';
        }
        return movement;
    };

    var updatePriceRow = function updatePriceRow(values) {
        var el_buy = el_rows[values.barrier][values.contract_type].buy;
        var el_sell = el_rows[values.barrier][values.contract_type].sell;

        el_buy.btn.classList[values.is_active ? 'remove' : 'add']('inactive');
        el_buy.btn[values.message ? 'setAttribute' : 'removeAttribute']('data-balloon', values.message);
        el_buy.btn[values.message ? 'setAttribute' : 'removeAttribute']('data-balloon-length', 'medium');
        el_buy.dyn.setAttribute('class', 'dynamics ' + (values.ask_price_movement || ''));
        el_buy.val.textContent = formatPrice(values.ask_price);

        el_sell.sell.classList[values.sell_price ? 'remove' : 'add']('inactive');
        el_sell.val.textContent = formatPrice(values.sell_price);

        if (Client.isJPClient()) {
            el_buy.base_value.textContent = formatPrice(values.ask_price / values.payout);
            el_sell.base_value.textContent = formatPrice(values.sell_price / values.payout);
        }
    };

    var processBuy = function processBuy(e) {
        e.preventDefault();

        if (!Client.isLoggedIn()) {
            MBNotifications.show({ text: localize('Please log in.'), uid: 'LOGIN_ERROR', dismissible: true });
            return;
        }

        var $btn = $(e.target);
        if ($btn.prop('tagName').toLowerCase() !== 'button') {
            $btn = $btn.parents('button.price-button');
        }

        if ($btn.hasClass('inactive')) return;

        var barrier = $btn.attr('data-barrier');
        var contract_type = $btn.attr('data-contract_type');
        if (!barrier || !contract_type) return;

        showPriceOverlay();
        sendBuyRequest(barrier, contract_type);
    };

    var formatPrice = function formatPrice(price) {
        return formatMoney(MBContract.getCurrency(), price, 1);
    };

    var cleanup = function cleanup() {
        prices = {};
        contract_types = {};
        barriers = [];
        is_displayed = false;
        el_rows = {};
        // display loading
        if ($(price_selector).html()) {
            $('#loading-overlay').height($(price_selector).height()).setVisibility(1);
        }
        $(price_selector).html('');
    };

    var sendBuyRequest = function sendBuyRequest(barrier, contract_type) {
        if (MBDefaults.get('disable_trading')) {
            MBNotifications.show({ text: 'You have disabled the trading.', uid: 'TRADING_DISABLED', dismissible: true });
            return;
        }
        MBNotifications.hide('TRADING_DISABLED');

        var proposal = prices[barrier][contract_type];
        if (!proposal || proposal.error) return;

        var req = {
            buy: 1,
            price: proposal.ask_price,
            parameters: {
                contract_type: contract_type,
                amount: proposal.echo_req.amount,
                barrier: proposal.barrier,
                basis: 'payout',
                currency: MBContract.getCurrency(),
                symbol: proposal.echo_req.symbol,
                date_expiry: proposal.echo_req.date_expiry,
                trading_period_start: proposal.echo_req.trading_period_start,
                product_type: 'multi_barrier',
                app_markup_percentage: '0'
            }
        };

        if (proposal.barrier2) {
            req.parameters.barrier2 = proposal.barrier2;
        }

        BinarySocket.send(req).then(function (response) {
            if (response.error) {
                hidePriceOverlay();
                MBNotifications.show({ text: response.error.message, uid: 'BUY_ERROR', dismissible: true });
            } else {
                MBNotifications.hide('BUY_ERROR');
                ViewPopup.init($('<div />', { contract_id: response.buy.contract_id }).get(0));
                GTM.pushPurchaseData(response);
            }
        });
    };

    var showPriceOverlay = function showPriceOverlay() {
        $('#disable-overlay').setVisibility(1);
        $('#loading-overlay').setVisibility(0);
    };

    var hidePriceOverlay = function hidePriceOverlay() {
        if (!MBDefaults.get('disable_trading')) {
            $('#disable-overlay').setVisibility(0);
        }
        $('#loading-overlay').setVisibility(0);
    };

    return {
        display: display,
        addPriceObj: addPriceObj,
        cleanup: cleanup,
        showPriceOverlay: showPriceOverlay,
        hidePriceOverlay: hidePriceOverlay,

        getReqId: function getReqId() {
            return req_id;
        },
        increaseReqId: function increaseReqId() {
            req_id++;cleanup();
        },
        getPrices: function getPrices() {
            return prices;
        },
        onUnload: function onUnload() {
            cleanup();req_id = 0;$table = undefined;
        }
    };
}();

module.exports = MBPrice;

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var MBDefaults = __webpack_require__(36);
var MBNotifications = __webpack_require__(97);
var BinarySocket = __webpack_require__(5);
var getElementById = __webpack_require__(4).getElementById;
var getPropertyValue = __webpack_require__(1).getPropertyValue;

/*
 * MBTick object handles all the process/display related to tick streaming
 *
 * We request tick stream for particular underlying to update current spot
 *
 *
 * Usage:
 * use `MBTick.detail` to populate this object
 *
 * then use
 *
 * `MBTick.quote()` to get current spot quote
 * 'MBTick.display()` to display current spot
 */

var MBTick = function () {
    var _quote = '';
    var error_message = '';

    var details = function details(data) {
        error_message = '';

        if (data) {
            if (data.error) {
                error_message = data.error.message;
            } else {
                _quote = data.tick.quote;
            }
        }
    };

    var display = function display() {
        $('#spot').fadeIn(200);
        var message = '';
        if (error_message) {
            message = error_message;
        } else {
            message = _quote;
        }

        var spot_element = getElementById('spot');
        if (parseFloat(message) !== +message) {
            spot_element.className = 'error';
        } else {
            spot_element.classList.remove('error');
            displayPriceMovement(parseFloat(spot_element.textContent), parseFloat(message));
        }

        spot_element.textContent = message;
    };

    /*
     * Display price/spot movement variation to depict price moved up or down
     */
    var displayPriceMovement = function displayPriceMovement(old_value, current_value) {
        var class_name = 'still';
        if (old_value !== current_value) {
            class_name = current_value > old_value ? 'up' : 'down';
        }
        var $spot = $('#spot');
        $spot.removeClass('up down still').addClass(class_name);
    };

    var request = function request(symbol) {
        BinarySocket.send({
            ticks: symbol,
            subscribe: 1
        }, { callback: processTickStream });
    };

    var processTickStream = function processTickStream(response) {
        if (response.msg_type === 'tick' && MBDefaults.get('underlying') === (response.echo_req.ticks || response.echo_req.ticks_history)) {
            if (getPropertyValue(response, 'error')) {
                MBNotifications.show({ text: response.error.message, uid: 'TICK_ERROR' });
                return;
            }

            details(response);
            display();
        }
    };

    return {
        details: details,
        display: display,
        request: request,
        displayPriceMovement: displayPriceMovement,
        processTickStream: processTickStream,
        quote: function quote() {
            return _quote;
        },
        errorMessage: function errorMessage() {
            return error_message;
        },
        setQuote: function setQuote(q) {
            _quote = q;
        },
        clean: function clean() {
            _quote = '';
            var $spot = $('#spot');
            $spot.fadeOut(200, function () {
                // resets spot movement coloring, will continue on the next tick responses
                $spot.removeClass('up down').text('');
            });
        }
    };
}();

module.exports = MBTick;

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var moment = __webpack_require__(9);
var countDecimalPlaces = __webpack_require__(47).countDecimalPlaces;
var Contract = __webpack_require__(58);
var Defaults = __webpack_require__(23);
var Tick = __webpack_require__(60);
var elementTextContent = __webpack_require__(4).elementTextContent;
var getElementById = __webpack_require__(4).getElementById;
var isVisible = __webpack_require__(4).isVisible;
var localize = __webpack_require__(2).localize;

/*
 * Handles barrier processing and display
 *
 * It process `Contract.barriers` and display them if its applicable
 * for current `Contract.form()
 */

var Barriers = function () {
    var is_barrier_updated = false;

    var display = function display() {
        var barriers = Contract.barriers()[Defaults.get('underlying')];
        var form_name = Contract.form();

        // TODO: remove `reset` when API stops sending barrier for Resets in contracts_for response
        if (barriers && form_name && barriers[form_name] && !/risefall|reset/i.test(Defaults.get('formname'))) {
            var unit = getElementById('duration_units');
            var end_time = getElementById('expiry_date');
            var is_daily = unit && isVisible(unit) && unit.value === 'd' || end_time && isVisible(end_time) && moment(end_time.getAttribute('data-value')).isAfter(moment(), 'day');

            var barrier = barriers[form_name][is_daily ? 'daily' : 'intraday'];
            if (barrier) {
                var current_tick = Tick.quote();
                var decimal_places = countDecimalPlaces(current_tick);

                var indicative_barrier_tooltip = getElementById('indicative_barrier_tooltip');
                var indicative_high_barrier_tooltip = getElementById('indicative_high_barrier_tooltip');
                var indicative_low_barrier_tooltip = getElementById('indicative_low_barrier_tooltip');

                if (barrier.count === 1) {
                    getElementById('high_barrier_row').style.display = 'none';
                    getElementById('low_barrier_row').style.display = 'none';
                    getElementById('barrier_row').setAttribute('style', '');

                    var defaults_barrier = Defaults.get('barrier');
                    var elm = getElementById('barrier');
                    var tooltip = getElementById('barrier_tooltip');
                    var span = getElementById('barrier_span');
                    var barrier_def = defaults_barrier && !isNaN(defaults_barrier) ? defaults_barrier : barrier.barrier || 0;
                    var value = void 0;
                    if (is_daily || !String(barrier.barrier).match(/^[+-]/)) {
                        if (current_tick && !isNaN(current_tick) && String(barrier_def).match(/^[+-]/)) {
                            value = (parseFloat(current_tick) + parseFloat(barrier_def)).toFixed(decimal_places);
                        } else {
                            value = parseFloat(barrier_def);
                        }
                        tooltip.style.display = 'none';
                        span.style.display = 'inherit';
                        // no need to display indicative barrier in case of absolute barrier
                        elementTextContent(indicative_barrier_tooltip, '');
                    } else {
                        if (!String(barrier_def).match(/^[+-]/)) barrier_def = barrier.barrier; // override Defaults value, because it's changing from absolute to relative barrier
                        value = barrier_def;
                        span.style.display = 'none';
                        tooltip.style.display = 'inherit';
                        if (current_tick && !isNaN(current_tick)) {
                            elementTextContent(indicative_barrier_tooltip, (parseFloat(current_tick) + parseFloat(barrier_def)).toFixed(decimal_places));
                        } else {
                            elementTextContent(indicative_barrier_tooltip, '');
                        }
                    }
                    elm.value = elm.textContent = value;
                    Barriers.validateBarrier();
                    Defaults.set('barrier', elm.value);
                    Defaults.remove('barrier_high', 'barrier_low');
                    showHideRelativeTip(barrier.barrier, [tooltip, span]);
                    return;
                } else if (barrier.count === 2) {
                    getElementById('barrier_row').style.display = 'none';
                    getElementById('high_barrier_row').setAttribute('style', '');
                    getElementById('low_barrier_row').setAttribute('style', '');

                    var high_elm = getElementById('barrier_high');
                    var low_elm = getElementById('barrier_low');
                    var high_tooltip = getElementById('barrier_high_tooltip');
                    var high_span = getElementById('barrier_high_span');
                    var low_tooltip = getElementById('barrier_low_tooltip');
                    var low_span = getElementById('barrier_low_span');

                    var defaults_high = Defaults.get('barrier_high');
                    var defaults_low = Defaults.get('barrier_low');

                    var barrier_high = defaults_high && !isNaN(defaults_high) ? defaults_high : barrier.barrier || 0;
                    var barrier_low = defaults_low && !isNaN(defaults_low) ? defaults_low : barrier.barrier1 || 0;
                    var value_high = void 0,
                        value_low = void 0;
                    if (is_daily || !String(barrier.barrier).match(/^[+-]/)) {
                        if (current_tick && !isNaN(current_tick) && String(barrier_high).match(/^[+-]/)) {
                            value_high = (parseFloat(current_tick) + parseFloat(barrier_high)).toFixed(decimal_places);
                            value_low = (parseFloat(current_tick) + parseFloat(barrier_low)).toFixed(decimal_places);
                        } else {
                            value_high = parseFloat(barrier_high);
                            value_low = parseFloat(barrier_low);
                        }

                        high_span.style.display = 'inherit';
                        high_tooltip.style.display = 'none';
                        low_span.style.display = 'inherit';
                        low_tooltip.style.display = 'none';

                        elementTextContent(indicative_high_barrier_tooltip, '');
                        elementTextContent(indicative_low_barrier_tooltip, '');
                    } else {
                        // override Defaults value, if it's changing from absolute to relative barrier
                        if (!String(barrier_high).match(/^[+-]/) || !String(barrier_low).match(/^[+-]/)) {
                            barrier_high = barrier.barrier;
                            barrier_low = barrier.barrier1;
                        }
                        value_high = barrier_high;
                        value_low = barrier_low;

                        high_span.style.display = 'none';
                        high_tooltip.style.display = 'inherit';
                        low_span.style.display = 'none';
                        low_tooltip.style.display = 'inherit';

                        var barrierVal = function barrierVal(tick, barrier_value) {
                            return (tick + parseFloat(barrier_value)).toFixed(decimal_places);
                        };

                        if (current_tick && !isNaN(current_tick)) {
                            var tick = parseFloat(current_tick);
                            elementTextContent(indicative_high_barrier_tooltip, barrierVal(tick, barrier_high));
                            elementTextContent(indicative_low_barrier_tooltip, barrierVal(tick, barrier_low));
                        } else {
                            elementTextContent(indicative_high_barrier_tooltip, '');
                            elementTextContent(indicative_low_barrier_tooltip, '');
                        }
                    }
                    high_elm.value = high_elm.textContent = value_high;
                    low_elm.value = low_elm.textContent = value_low;

                    Defaults.remove('barrier');
                    showHideRelativeTip(barrier.barrier, [high_tooltip, high_span, low_tooltip, low_span]);
                    Barriers.validateBarrier();
                    Defaults.set('barrier_high', high_elm.value);
                    Defaults.set('barrier_low', low_elm.value);
                    return;
                }
            }
        }

        var elements = document.getElementsByClassName('barrier_class');
        for (var i = 0; i < elements.length; i++) {
            elements[i].style.display = 'none';
        }
        Defaults.remove('barrier', 'barrier_high', 'barrier_low');
    };

    /**
    * Validate Barriers
    */
    var validateBarrier = function validateBarrier() {
        var barrier_element = getElementById('barrier');
        var empty = isNaN(parseFloat(barrier_element.value)) || parseFloat(barrier_element.value) === 0;
        var barrier_high_element = getElementById('barrier_high');

        if (isVisible(barrier_element) && empty) {
            barrier_element.classList.add('error-field');
        } else {
            barrier_element.classList.remove('error-field');
        }

        if (isVisible(barrier_high_element)) {
            var barrier_low_element = getElementById('barrier_low');
            var error_node = getElementById('barrier_high_error');
            var is_high_barrier_greater = +barrier_high_element.value > +barrier_low_element.value;
            barrier_high_element.classList[is_high_barrier_greater ? 'remove' : 'add']('error-field');
            error_node.classList[is_high_barrier_greater ? 'add' : 'remove']('invisible');
        }
    };

    var showHideRelativeTip = function showHideRelativeTip(barrier, arr_el) {
        var has_relative_barrier = String(barrier).match(/^[+-]/);
        var barrier_text = localize('Add +/– to define a barrier offset. For example, +0.005 means a barrier that\'s 0.005 higher than the entry spot.');
        arr_el.forEach(function (el) {
            if (has_relative_barrier) {
                el.setAttribute('data-balloon', barrier_text);
                el.setAttribute('data-balloon-length', 'xlarge');
            } else {
                el.removeAttribute('data-balloon');
                el.removeAttribute('data-balloon-length');
            }
        });
    };

    return {
        display: display,
        validateBarrier: validateBarrier,
        isBarrierUpdated: function isBarrierUpdated() {
            return is_barrier_updated;
        },
        setBarrierUpdate: function setBarrierUpdate(flag) {
            is_barrier_updated = flag;
        }
    };
}();

module.exports = Barriers;

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Dropdown = __webpack_require__(25).selectDropdown;
var moment = __webpack_require__(9);
var Barriers = __webpack_require__(124);
var commonTrading = __webpack_require__(31);
var commonIndependent = __webpack_require__(47);
var Contract = __webpack_require__(58);
var Defaults = __webpack_require__(23);
var Price = __webpack_require__(100);
var Reset = __webpack_require__(78);
var BinarySocket = __webpack_require__(5);
var DatePicker = __webpack_require__(87);
var CommonFunctions = __webpack_require__(4);
var localize = __webpack_require__(2).localize;
var State = __webpack_require__(6).State;
var toISOFormat = __webpack_require__(17).toISOFormat;
var toReadableFormat = __webpack_require__(17).toReadableFormat;
var createElement = __webpack_require__(1).createElement;
var getPropertyValue = __webpack_require__(1).getPropertyValue;

/*
 * Handles duration processing display
 *
 * It process `Contract.durations()` and display them according to
 * the current `Contract.form()` and `Contract.barriers()`
 *
 * It also populate expiry type select box i.e Durations and Endtime select
 *
 */

var Durations = function () {
    var selected_duration = {};
    var smallest_duration = {};
    var has_end_date = 0;

    var displayDurations = function displayDurations(time_start_val) {
        var date_time_start = moment(Defaults.get('date_start') * 1000);
        if (time_start_val) {
            var start_time = time_start_val.split(':');
            date_time_start = date_time_start.utc().hour(start_time[0]).minute(start_time[1]);
        }

        var start_type = void 0;
        if (Defaults.get('date_start') !== 'now' && State.get('is_start_dates_displayed') && date_time_start.isAfter(moment())) {
            start_type = 'forward';
        } else {
            start_type = 'spot';
        }

        if (Defaults.get('formname') === 'highlowticks') {
            Barriers.display(); // hide barrier field, instead of selecting barrier we select tick number
            Defaults.set('expiry_type', 'duration');
            Defaults.set('duration_amount', 5);
            Defaults.set('duration_units', 't');
            // display label instead of populating durations
            CommonFunctions.getElementById('expiry_row').style.display = 'none';
            return false;
        }

        var durations = Contract.durations();
        if (durations === false) {
            CommonFunctions.getElementById('expiry_row').style.display = 'none';
            Defaults.remove('expiry_type', 'duration_amount', 'duration_units', 'expiry_date', 'expiry_time');
            return false;
        }

        CommonFunctions.getElementById('expiry_row').style.display = 'flex';

        var target = CommonFunctions.getElementById('duration_units');
        var form_name = Contract.form();
        var barrier_category = Contract.barrier();
        var duration_container = {};

        while (target && target.firstChild) {
            target.removeChild(target.firstChild);
        }

        Object.keys(durations).forEach(function (key) {
            Object.keys(durations[key][form_name] || []).forEach(function (form) {
                var obj = {};
                if (barrier_category) {
                    obj = durations[key][form_name][barrier_category];
                } else {
                    obj = durations[key][form_name][form];
                }
                Object.keys(obj).forEach(function (type) {
                    if (start_type) {
                        if (start_type === type) {
                            if (!getPropertyValue(duration_container, start_type)) {
                                duration_container[key] = obj[start_type];
                            }
                        }
                    } else if (!getPropertyValue(duration_container, type)) {
                        duration_container[key] = obj[type];
                    }
                });
            });
        });

        var duration_list = {};
        Object.keys(duration_container).forEach(function (duration) {
            var text_mapping_min = durationTextValueMappings(duration_container[duration].min_contract_duration);
            var text_mapping_max = durationTextValueMappings(duration_container[duration].max_contract_duration);
            var min_unit = text_mapping_min.unit;
            var max_to_min_base = convertDurationUnit(+text_mapping_max.value, text_mapping_max.unit, min_unit);

            if (duration === 'intraday') {
                switch (min_unit) {
                    case 's':
                        duration_list[min_unit] = makeDurationOption(text_mapping_min, text_mapping_max);
                        if (max_to_min_base >= 60) {
                            duration_list.m = makeDurationOption(durationTextValueMappings('1m'), text_mapping_max);
                            if (max_to_min_base >= 3600) {
                                duration_list.h = makeDurationOption(durationTextValueMappings('1h'), text_mapping_max);
                            }
                        }
                        break;
                    case 'm':
                        duration_list[min_unit] = makeDurationOption(text_mapping_min, text_mapping_max);
                        if (max_to_min_base >= 60) {
                            duration_list.h = makeDurationOption(durationTextValueMappings('1h'), text_mapping_max);
                        }
                        break;
                    case 'h':
                        duration_list[min_unit] = makeDurationOption(text_mapping_min, text_mapping_max);
                        break;
                    default:
                        duration_list[min_unit] = makeDurationOption(text_mapping_min, text_mapping_max);
                        break;
                }
            } else if (duration === 'daily' || duration === 'tick') {
                duration_list[min_unit] = makeDurationOption(text_mapping_min, text_mapping_max);
            }
        });

        var list = Object.keys(duration_list).sort(function (a, b) {
            return commonTrading.durationOrder(a) > commonTrading.durationOrder(b) ? 1 : -1;
        });

        smallest_duration = {
            amount: duration_list[list[0]].dataset.minimum,
            unit: list[0]
        };

        has_end_date = 0;
        for (var k = 0; k < list.length; k++) {
            var d = list[k];
            if (d !== 't') {
                has_end_date = 1;
            }
            if (getPropertyValue(duration_list, d)) {
                target.appendChild(duration_list[d]);
            }
        }

        if (selected_duration.unit) {
            if (!commonTrading.selectOption(selected_duration.unit, target)) {
                selected_duration = {};
            }
        }
        return durationPopulate();
    };

    var makeDurationOption = function makeDurationOption(map_min, map_max) {
        var option = createElement('option', { value: map_min.unit, 'data-minimum': map_min.value, text: map_min.text });
        if (map_max.value && map_max.unit) {
            var max = convertDurationUnit(map_max.value, map_max.unit, map_min.unit);
            if (max) {
                option.setAttribute('data-maximum', max);
            }
        }
        if (map_min.unit === Defaults.get('duration_units')) {
            option.setAttribute('selected', 'selected');
        }
        return option;
    };

    var convertDurationUnit = function convertDurationUnit(value, from_unit, to_unit) {
        if (!value || !from_unit || !to_unit) return null;
        if (from_unit === to_unit) return value;
        var seconds = {
            s: 1,
            m: 60,
            h: 3600,
            d: 3600 * 24
        };
        return value * seconds[from_unit] / seconds[to_unit];
    };

    var displayEndTime = function displayEndTime() {
        var date_start = CommonFunctions.getElementById('date_start').value;
        var now = !date_start || date_start === 'now';
        var current_moment = moment(now ? window.time : parseInt(date_start) * 1000);
        var smallest_end_time = current_moment.add(smallest_duration.amount, smallest_duration.unit);
        var default_end_time = Defaults.get('expiry_date');

        var expiry_date = default_end_time && moment(default_end_time).isAfter(smallest_end_time) ? moment(default_end_time) : smallest_end_time.add(5, 'minutes').utc();
        var expiry_time = Defaults.get('expiry_time') || current_moment.format('HH:mm');
        var expiry_date_iso = toISOFormat(expiry_date);

        if (moment.utc(expiry_date_iso + ' ' + expiry_time).valueOf() < current_moment.valueOf()) {
            expiry_date = current_moment;
            expiry_date_iso = toISOFormat(expiry_date);
            expiry_time = current_moment.format('HH:mm');
        }

        var expiry_date_el = CommonFunctions.getElementById('expiry_date');
        var expiry_time_el = CommonFunctions.getElementById('expiry_time');

        expiry_date_el.value = toReadableFormat(expiry_date);
        expiry_date_el.setAttribute('data-value', expiry_date_iso);
        expiry_time_el.value = expiry_time;
        expiry_time_el.setAttribute('data-value', expiry_time);
        Defaults.set('expiry_date', expiry_date_iso);
        Defaults.set('expiry_time', expiry_time);
        setTime(expiry_time);

        durationPopulate();
    };

    var durationTextValueMappings = function durationTextValueMappings(str) {
        var mapping = {
            s: localize('seconds'),
            m: localize('minutes'),
            h: localize('hours'),
            d: localize('days'),
            t: localize('ticks')
        };

        var arry = str ? str.toString().match(/[a-zA-Z]+|[0-9]+/g) : [];
        var obj = {};

        if (arry.length > 1) {
            obj.unit = arry[1];
            obj.text = mapping[arry[1]];
            obj.value = arry[0];
        } else {
            obj.unit = 't';
            obj.text = mapping.t;
            obj.value = arry[0];
        }

        return obj;
    };

    var duration_map = {
        t: 'tick',
        s: 'second',
        m: 'minute',
        h: 'hour',
        d: 'day'
    };

    var durationPopulate = function durationPopulate() {
        var unit = CommonFunctions.getElementById('duration_units');
        var selected_unit = unit.options[unit.selectedIndex];

        if (!selected_unit) return false;

        var duration_amount_id = '#duration_amount';
        var unit_min_value = selected_unit.getAttribute('data-minimum');
        var unit_max_value = selected_unit.getAttribute('data-maximum');
        var unit_value = Defaults.get('duration_amount') || unit_min_value;
        Dropdown('#duration_units');
        CommonFunctions.elementTextContent(CommonFunctions.getElementById('duration_minimum'), unit_min_value);
        CommonFunctions.elementTextContent(CommonFunctions.getElementById('duration_unit'), localize(duration_map[unit.value] + (+unit_min_value > 1 ? 's' : '')));
        CommonFunctions.elementTextContent(CommonFunctions.getElementById('duration_maximum'), unit_max_value);
        if (selected_duration.amount && selected_duration.unit > unit_value) {
            unit_value = selected_duration.amount;
        }
        CommonFunctions.getElementById('duration_amount').value = unit_value;
        Defaults.set('duration_amount', unit_value);
        displayExpiryType();
        Dropdown('#expiry_type');

        Defaults.set('duration_units', unit.value);

        // jquery for datepicker
        if (unit.value === 'd') {
            var tomorrow = window.time ? new Date(window.time.valueOf()) : new Date();
            tomorrow.setDate(tomorrow.getDate() + 1);
            DatePicker.init({
                selector: duration_amount_id,
                type: 'diff',
                minDate: 1,
                maxDate: 365,
                native: false
            });
        } else {
            DatePicker.hide(duration_amount_id);
        }

        var $duration_amount = $(duration_amount_id);
        $duration_amount.change(function (e) {
            e.stopPropagation();
            var data_min_value = unit.options[unit.selectedIndex].getAttribute('data-minimum');
            var value = e.target.value || data_min_value; // set to min value if no input value
            $duration_amount.val(value);
        });

        var requested = changeExpiryTimeType();

        validateMinDurationAmount();
        // we need to call it here as for days we need to show absolute barriers
        Barriers.display();

        return requested;
    };

    var expiryDateOnChange = function expiryDateOnChange($expiry_date) {
        $expiry_date.off('change').on('change', function () {
            if (!CommonFunctions.dateValueChanged(this, 'date')) {
                return false;
            }
            var selected_value = void 0;
            if ($(this).is('select')) {
                selected_value = $(this).find('option:selected').attr('data-value');
                $expiry_date.attr('data-value', selected_value);
            } else {
                selected_value = this.getAttribute('data-value');
            }
            var requested = selectEndDate(moment(selected_value));
            if (requested < 1) {
                commonTrading.timeIsValid($('#expiry_time'));
                Price.processPriceRequest();
            }
            return true;
        });
    };

    var removeCustomDropDown = function removeCustomDropDown(element) {
        // restore back from custom dropdown to input
        if (element.is('input') && element.parent('div.select').length) {
            element.parent().replaceWith(function () {
                var curr_element = element;
                return curr_element;
            });
        }
    };

    var changeExpiryTimeType = function changeExpiryTimeType() {
        var requested = -1;
        if (CommonFunctions.getElementById('expiry_type').value === 'endtime') {
            var $expiry_date = $('#expiry_date');
            var date_start_val = CommonFunctions.getElementById('date_start').value || 'now';
            var is_now = isNow(date_start_val);
            var is_risefall = /risefall/.test(Defaults.get('formname')) || false;

            if (is_now || !is_risefall) {
                if (!$expiry_date.is('input')) {
                    $expiry_date.replaceWith($('<input/>', { id: 'expiry_date', type: 'text', readonly: 'readonly', autocomplete: 'off', 'data-value': $expiry_date.attr('data-value') })).val(toReadableFormat($expiry_date.attr('data-value')));
                    $expiry_date = $('#expiry_date');
                    expiryDateOnChange($expiry_date);
                    removeCustomDropDown($expiry_date);
                }
                DatePicker.init({
                    selector: '#expiry_date',
                    minDate: smallest_duration.unit === 'd' ? 1 : 0,
                    maxDate: 365
                });
            } else {
                var min_date = moment.unix(date_start_val).utc();
                var next_day = moment.unix(date_start_val).utc().add(1, 'day');
                var start_dates = Contract.startDates();

                var selected_start_day_index = CommonFunctions.getElementById('date_start').selectedIndex;

                var max_date = void 0;
                if (start_dates && start_dates.list && start_dates.list.length) {
                    var start_dates_length = start_dates.list.length;
                    start_dates.list.some(function (date) {
                        // for the last day we will add +1 day as we don't know if offered or not we let back-end decide
                        if (moment.unix(date.open).utc().format('dd') === next_day.format('dd') || selected_start_day_index === start_dates_length) {
                            max_date = next_day;
                            return true;
                        }
                        return false;
                    });
                }
                if (!$expiry_date.is('select')) {
                    $expiry_date.replaceWith($('<select/>', { id: 'expiry_date', 'data-value': toISOFormat(min_date) }));
                    $expiry_date = $('#expiry_date');
                    expiryDateOnChange($expiry_date);
                } else {
                    $expiry_date.empty().attr('data-value', toISOFormat(min_date));
                }
                appendExpiryDateValues($expiry_date, min_date);
                if (max_date) {
                    appendExpiryDateValues($expiry_date, max_date);
                }
                requested = selectEndDate(min_date);
            }
        }
        return requested;
    };

    var appendExpiryDateValues = function appendExpiryDateValues($expiry_date, date) {
        $expiry_date.append($('<option/>', { text: date.format('ddd - DD MMM, YYYY'), 'data-value': toISOFormat(date) }));
    };

    var displayExpiryType = function displayExpiryType() {
        var target = CommonFunctions.getElementById('expiry_type');
        var fragment = document.createDocumentFragment();

        // in case of having endtime as expiry_type and change the form to contract types
        // which only have duration and do not support endtime, it should change the Default value
        // to get corrected based on contract situations
        if ($('#expiry_type').find('option[value=' + Defaults.get('expiry_type') + ']').length === 0 && target.value) {
            Defaults.set('expiry_type', target.value);
        }

        var current_selected = Defaults.get('expiry_type') || target.value || 'duration';

        CommonFunctions.getElementById('expiry_type_' + current_selected).style.display = 'flex';
        // need to hide the non selected one
        CommonFunctions.getElementById('expiry_type_' + (current_selected === 'duration' ? 'endtime' : 'duration')).style.display = 'none';

        while (target && target.firstChild) {
            target.removeChild(target.firstChild);
        }

        var option = createElement('option', { value: 'duration', text: localize('Duration') });

        if (current_selected === 'duration') {
            option.setAttribute('selected', 'selected');
        }
        fragment.appendChild(option);

        if (has_end_date && !Reset.isReset(Contract.form())) {
            option = createElement('option', { value: 'endtime', text: localize('End Time') });
            if (current_selected === 'endtime') {
                option.setAttribute('selected', 'selected');
            }
            fragment.appendChild(option);
        }
        target.appendChild(fragment);
    };

    var isNow = function isNow(date_start) {
        return date_start ? date_start === 'now' : !State.get('is_start_dates_displayed') || CommonFunctions.getElementById('date_start').value === 'now';
    };

    var isSameDay = function isSameDay() {
        var expiry_date = CommonFunctions.getElementById('expiry_date');
        var date_start_val = CommonFunctions.getElementById('date_start').value;
        // if 'now' is selected, take first option's value
        if (!date_start_val || isNaN(+date_start_val)) {
            date_start_val = window.time;
        } else {
            date_start_val = moment.unix(date_start_val).utc();
        }
        var expiry_date_day = moment.utc(expiry_date.getAttribute('data-value'));
        return date_start_val.isSame(expiry_date_day, 'day');
    };

    var selectEndDate = function selectEndDate(end_date) {
        var expiry_time = CommonFunctions.getElementById('expiry_time');
        var expiry_time_row = CommonFunctions.getElementById('expiry_time_row');
        var end_date_readable = toReadableFormat(end_date);
        var end_date_iso = toISOFormat(end_date);
        var $expiry_date = $('#expiry_date');
        Dropdown('#expiry_date');
        if ($expiry_date.is('input')) {
            $expiry_date.val(end_date_readable).attr('data-value', end_date_iso);

            removeCustomDropDown($expiry_date);
        }
        Defaults.set('expiry_date', end_date_iso);
        if (isNow() && !isSameDay()) {
            Defaults.remove('expiry_time');
            expiry_time_row.hide();
            Barriers.display();
            $(expiry_time).val('').attr('data-value', '');
            Defaults.set('expiry_time', '');
            return processTradingTimesRequest(end_date_iso);
        } // else
        return showExpiryTime(expiry_time, expiry_time_row);
    };

    var hideExpiryTime = function hideExpiryTime(expiry_time) {
        var requested = setTime('');
        Defaults.remove('expiry_time');
        expiry_time.hide();
        Barriers.display();
        return requested;
    };

    var showExpiryTime = function showExpiryTime() {
        var el_expiry_time = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : CommonFunctions.getElementById('expiry_time');
        var el_expiry_time_row = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CommonFunctions.getElementById('expiry_time_row');

        var el_time_start = CommonFunctions.getElementById('time_start');
        var is_same_day = isSameDay();
        var expiry_time_val = el_expiry_time.value;
        var time_start_val = el_time_start.value;
        var new_time = void 0,
            time_changed = void 0,
            keep_time_unchanged = void 0;
        if (!expiry_time_val) {
            new_time = moment(window.time);
            expiry_time_val = new_time.format('HH:mm');
        }
        if (!time_start_val) {
            time_start_val = moment(window.time).format('HH:mm');
        }
        if (!is_same_day && expiry_time_val >= time_start_val) {
            var time_start = time_start_val.split(':');
            new_time = moment(window.time).hour(time_start[0]).minute(time_start[1]);
            if (+time_start[0] === 0 && +time_start[1] === 0) {
                keep_time_unchanged = true;
            } else {
                new_time = new_time.add(-10, 'minutes');
            }
        } else if (is_same_day && expiry_time_val <= time_start_val) {
            var _time_start = time_start_val.split(':');
            new_time = moment(window.time).hour(_time_start[0]).minute(_time_start[1]);
        }
        if (is_same_day && expiry_time_val < time_start_val) {
            var time = time_start_val.split(':');
            new_time = moment(window.time).hour(time[0]).minute(time[1]);
        }
        var min_max_time_end = commonIndependent.getMinMaxTimeEnd();
        var min_time = isNaN(min_max_time_end.minTime) ? min_max_time_end.minTime.format('HH:mm') : min_max_time_end.minTime;
        var max_time = isNaN(min_max_time_end.maxTime) ? min_max_time_end.maxTime.format('HH:mm') : min_max_time_end.maxTime;
        if ((new_time || expiry_time_val) < min_time) {
            new_time = min_max_time_end.minTime;
        } else if ((new_time || expiry_time_val) > max_time) {
            new_time = min_max_time_end.maxTime.add(-10, 'minutes');
        }
        if (new_time) {
            if (!keep_time_unchanged) {
                new_time = new_time.add(5, 'minutes');
            }
            new_time = new_time.utc().format('HH:mm');
            el_expiry_time.value = new_time;
            el_expiry_time.setAttribute('data-value', new_time);
            time_changed = setTime(el_expiry_time.value, 1);
        } else {
            time_changed = setTime(Defaults.get('expiry_time') || el_expiry_time.value);
        }
        Defaults.set('expiry_time', Defaults.get('expiry_time') || el_expiry_time.value);
        el_expiry_time_row.show();
        Barriers.display();
        return time_changed;
    };

    var old_date = void 0;
    var processTradingTimesRequest = function processTradingTimesRequest(date) {
        if (old_date === date) {
            return false;
        }
        old_date = date;
        var trading_times = commonIndependent.getTradingTimes();
        if (getPropertyValue(trading_times, date)) {
            Price.processPriceRequest();
        } else {
            commonTrading.showPriceOverlay();
            BinarySocket.send({ trading_times: date }).then(function (response) {
                commonIndependent.processTradingTimesAnswer(response);
                Price.processPriceRequest();
            });
        }
        return true;
    };

    var validateMinDurationAmount = function validateMinDurationAmount() {
        var duration_amount_element = CommonFunctions.getElementById('duration_amount');
        var duration_wrapper_element = CommonFunctions.getElementById('duration_wrapper');

        if (!CommonFunctions.isVisible(duration_amount_element)) {
            duration_wrapper_element.setVisibility(0);
            return;
        }

        var duration_min_element = CommonFunctions.getElementById('duration_minimum');
        var duration_max_element = CommonFunctions.getElementById('duration_maximum');
        duration_wrapper_element.setVisibility(1);

        if (+duration_amount_element.value < +duration_min_element.textContent) {
            duration_amount_element.classList.add('error-field');
            duration_wrapper_element.classList.add('error-msg');
            Reset.hideResetTime();
        } else if (+duration_max_element.textContent && +duration_amount_element.value > +duration_max_element.textContent) {
            duration_amount_element.classList.add('error-field');
            duration_wrapper_element.classList.remove('error-msg');
            Reset.hideResetTime();
        } else {
            duration_amount_element.classList.remove('error-field');
            duration_wrapper_element.classList.remove('error-msg');
            if (Reset.isReset(Contract.form())) {
                Reset.displayResetTime(duration_amount_element.value, Defaults.get('duration_units'));
            } else {
                Reset.hideResetTime();
            }
        }
    };

    var onStartDateChange = function onStartDateChange(value) {
        var $date_start_select = $('#date_start');
        if (!value || !$date_start_select.find('option[value=' + value + ']').length) {
            return 0;
        }

        $date_start_select.val(value);

        $('#time_start_row').setVisibility(value !== 'now');
        var time_start = CommonFunctions.getElementById('time_start');
        if (value === 'now') {
            time_start.value = '';
        } else {
            commonIndependent.checkValidTime(time_start, $date_start_select, Defaults.get('time_start'));
        }

        var make_price_request = 1;
        var requested = void 0;
        var displayed = displayDurations(time_start.value);
        if (+displayed > 0) {
            make_price_request = -1;
        } else if (value !== 'now' && Defaults.get('expiry_type') === 'endtime') {
            var end_time = moment(parseInt(value) * 1000).add(5, 'minutes').utc();
            setTime(Defaults.get('expiry_time') ? Defaults.get('expiry_time') : end_time.format('HH:mm'));
            var expiry_date = Defaults.get('expiry_date') ? moment(Defaults.get('expiry_date')) : '';
            if (expiry_date) {
                var date_start = moment(+$date_start_select.val() * 1000);
                // if chosen end date is not start date or one day after start date, reset its value
                if (expiry_date.format('DDD') !== date_start.format('DDD') && expiry_date.format('DDD') !== date_start.add(1, 'day').format('DDD')) {
                    expiry_date = end_time;
                }
            }
            requested = selectEndDate(expiry_date || end_time);
        } else if (value === 'now' && isSameDay() && Defaults.get('expiry_type') === 'endtime') {
            var expiry_time = Defaults.get('expiry_time') || moment().utc().add(5, 'minutes').format('HH:mm');
            var times = expiry_time.split(':');
            if (times.length > 1) {
                var moment_expiry_time = moment.utc();
                moment_expiry_time = moment_expiry_time.hour(times[0]).minute(times[1]);
                var now = moment.utc();
                if (moment_expiry_time.isBefore(now)) {
                    expiry_time = now.add(5, 'minutes').format('HH:mm');
                }
            }
            requested = setTime(expiry_time);
        } else {
            requested = hideExpiryTime(CommonFunctions.getElementById('expiry_time_row'));
        }
        if (requested) {
            make_price_request = -1;
        }
        commonTrading.timeIsValid($('#expiry_time'));
        return make_price_request;
    };

    var setTime = function setTime(time, process_new_time) {
        var $expiry_time = $('#expiry_time');
        if ($expiry_time.attr('data-value') !== time || $expiry_time.val() !== time || process_new_time) {
            $expiry_time.val(time).attr('data-value', time);
            Defaults.set('expiry_time', time);
            if (commonTrading.timeIsValid($expiry_time)) {
                Price.processPriceRequest();
                return true;
            }
        }
        return false;
    };

    return {
        displayEndTime: displayEndTime,
        selectEndDate: selectEndDate,
        validateMinDurationAmount: validateMinDurationAmount,
        onStartDateChange: onStartDateChange,
        setTime: setTime,
        isNow: isNow,
        expiryDateOnChange: expiryDateOnChange,

        display: displayDurations,
        populate: durationPopulate,
        selectAmount: function selectAmount(a) {
            selected_duration.amount = a;
        },
        selectUnit: function selectUnit(u) {
            selected_duration.unit = u;
        }
    };
}();

module.exports = Durations;

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var moment = __webpack_require__(9);
var requireHighstock = __webpack_require__(31).requireHighstock;
var Reset = __webpack_require__(78);
var Tick = __webpack_require__(60);
var updatePurchaseStatus = __webpack_require__(127).updatePurchaseStatus;
var ViewPopupUI = __webpack_require__(131);
var BinarySocket = __webpack_require__(5);
var addComma = __webpack_require__(118).addComma;
var CommonFunctions = __webpack_require__(4);
var localize = __webpack_require__(2).localize;

var TickDisplay = function () {
    var number_of_ticks = void 0,
        display_symbol = void 0,
        contract_start_ms = void 0,
        contract_category = void 0,
        should_set_barrier = void 0,
        barrier = void 0,
        display_decimals = void 0,
        show_contract_result = void 0,
        price = void 0,
        payout = void 0,
        ticks_needed = void 0,
        x_indicators = void 0,
        chart = void 0,
        Highcharts = void 0,
        applicable_ticks = void 0,
        contract_start_moment = void 0,
        counter = void 0,
        spots_list = void 0,
        tick_init = void 0,
        subscribe = void 0,
        reset_spot_plotted = void 0,
        response_id = void 0,
        contract = void 0,
        selected_tick = void 0;

    var id_render = 'tick_chart';

    var winning_color = 'rgba(46, 136, 54, 0.2)';
    var losing_color = 'rgba(204, 0, 0, 0.1)';

    var selected_tick_style = 'margin-left: 10px; display: inline-block; border-radius: 6px; background-color: orange; width:10px; height: 10px;';

    var color = 'orange';
    var marker = {
        fillColor: color,
        lineColor: color,
        lineWidth: 3,
        radius: 4,
        states: { hover: { fillColor: color, lineColor: color, lineWidth: 3, radius: 4 } }
    };

    var initialize = function initialize(data, options) {
        // setting up globals
        applicable_ticks = [];
        number_of_ticks = parseInt(data.number_of_ticks);
        display_symbol = data.display_symbol;
        contract_start_ms = parseInt(data.contract_start) * 1000;
        contract_category = data.contract_category;
        should_set_barrier = !contract_category.match('digits');
        barrier = data.barrier;
        display_decimals = data.display_decimals || 2;
        show_contract_result = data.show_contract_result;
        reset_spot_plotted = false;

        if (data.id_render) {
            id_render = data.id_render;
        }

        if (data.show_contract_result) {
            price = parseFloat(data.price);
            payout = parseFloat(data.payout);
        }

        var minimize = data.show_contract_result;
        var end_time = parseInt(data.contract_start) + parseInt((number_of_ticks + 2) * 5);

        setXIndicators();
        requireHighstock(function (Highstock) {
            Highcharts = Highstock;
            initializeChart({
                minimize: minimize,
                plot_from: data.previous_tick_epoch * 1000,
                plot_to: new Date(end_time * 1000).getTime(),
                width: data.width ? data.width : undefined
            }, options);
        });
    };

    var setXIndicators = function setXIndicators() {
        var exit_tick_index = number_of_ticks - 1;
        if (contract_category.match('asian')) {
            ticks_needed = number_of_ticks;
            x_indicators = {
                _0: { label: 'Entry Spot', id: 'start_tick' }
            };
            x_indicators['_' + exit_tick_index] = {
                label: 'Exit Spot',
                id: 'exit_tick',
                dashStyle: 'Dash'
            };
        } else if (contract_category.match(/callput|reset/i)) {
            ticks_needed = number_of_ticks + 1;
            x_indicators = {
                _0: { label: 'Entry Spot', id: 'entry_tick' }
            };
            x_indicators['_' + number_of_ticks] = {
                label: 'Exit Spot',
                id: 'exit_tick',
                dashStyle: 'Dash'
            };
            if (contract_category.match('reset')) {
                var reset_time_index = Math.floor(number_of_ticks / 2); // use index to draw ticks reset_time
                x_indicators['_' + reset_time_index] = {
                    index: reset_time_index,
                    label: 'Reset Time',
                    id: 'reset_tick',
                    color: '#000'
                };
            }
        } else if (contract_category.match('touchnotouch')) {
            ticks_needed = number_of_ticks + 1;
            x_indicators = {
                _0: { label: 'Entry Spot', id: 'entry_tick' }
            };
        } else if (contract_category.match('digits')) {
            ticks_needed = number_of_ticks;
            x_indicators = {
                _0: { label: 'Tick 1', id: 'start_tick' }
            };
            x_indicators['_' + exit_tick_index] = {
                label: 'Tick ' + number_of_ticks,
                id: 'last_tick',
                dashStyle: 'Dash'
            };
        } else if (contract_category.match('highlowticks')) {
            ticks_needed = number_of_ticks;
            x_indicators = {
                _0: { label: 'Entry Spot', id: 'start_tick' }
            };
            x_indicators['_' + exit_tick_index] = {
                label: 'Exit Spot',
                id: 'exit_tick'
            };
        } else {
            x_indicators = {};
        }
    };

    var initializeChart = function initializeChart(config, data) {
        Highcharts.setOptions({
            lang: { thousandsSep: ',' }
        });
        chart = new Highcharts.Chart(_extends({
            chart: {
                type: 'line',
                renderTo: id_render,
                width: config.width || (config.minimize ? 394 : null),
                height: config.minimize ? 143 : null,
                backgroundColor: null,
                events: { load: function load() {
                        return plot(config.plot_from, config.plot_to);
                    } },
                marginLeft: 50
            },
            credits: { enabled: false },
            tooltip: {
                formatter: function formatter() {
                    var new_y = addComma(this.y.toFixed(display_decimals));
                    var mom = moment.utc(applicable_ticks[this.x].epoch * 1000).format('dddd, MMM D, HH:mm:ss');
                    return mom + '<br/>' + display_symbol + ' ' + new_y;
                }
            },
            title: {
                text: show_contract_result ? '' : display_symbol,
                style: { fontSize: '16px' }
            }
        }, contract_category === 'highlowticks' && { subtitle: { text: '<div style="' + selected_tick_style + '"></div> ' + localize('Selected Tick'), useHTML: true } }, {
            xAxis: {
                type: 'linear',
                min: 0,
                max: number_of_ticks + 1,
                labels: { enabled: false }
            },
            yAxis: {
                opposite: false,
                labels: {
                    align: 'left',
                    x: 0,
                    formatter: function formatter() {
                        return addComma(this.value.toFixed(display_decimals));
                    }
                },
                title: ''
            },
            series: [{
                data: []
            }],
            exporting: { enabled: false, enableImages: false },
            legend: { enabled: false }
        }));
        if (data) {
            dispatch(data);
        }
    };

    var addBarrier = function addBarrier() {
        if (!should_set_barrier) {
            return;
        }

        var barrier_type = /^(asian|highlowticks)$/.test(contract_category) ? contract_category : 'static';

        var calculated_barrier = '';
        if (barrier_type === 'static') {
            var first_quote = applicable_ticks[0].quote;
            var barrier_quote = first_quote;

            if (barrier) {
                var final_barrier = barrier_quote + parseFloat(barrier);
                // sometimes due to rounding issues, result is 1.009999 while it should
                // be 1.01
                final_barrier = Number(Math.round(final_barrier + 'e' + display_decimals) + 'e-' + display_decimals);
                barrier_quote = final_barrier;
            } else if (contract && contract.barrier) {
                barrier_quote = parseFloat(contract.barrier);
            }

            chart.yAxis[0].addPlotLine({
                id: 'tick-barrier',
                value: barrier_quote,
                label: {
                    text: localize('Barrier') + ' (' + addComma(barrier_quote) + ')',
                    align: Reset.isReset(contract_category) ? 'right' : 'center',
                    x: Reset.isReset(contract_category) ? -60 : 0
                },
                color: 'green',
                width: 2,
                zIndex: 2
            });
            calculated_barrier = barrier_quote;
            should_set_barrier = false;
        }

        if (barrier_type === 'asian') {
            var total = 0;
            for (var i = 0; i < applicable_ticks.length; i++) {
                total += parseFloat(applicable_ticks[i].quote);
            }
            // round calculated barrier
            var calc_barrier = (total / applicable_ticks.length).toFixed(parseInt(display_decimals) + 1);

            chart.yAxis[0].removePlotLine('tick-barrier');
            chart.yAxis[0].addPlotLine({
                id: 'tick-barrier',
                value: calc_barrier,
                color: 'green',
                label: {
                    text: localize('Average') + ' (' + addComma(calc_barrier) + ')',
                    align: 'center'
                },
                width: 2,
                zIndex: 2
            });
            calculated_barrier = calc_barrier;
        }

        if (barrier_type === 'highlowticks') {
            if (/^(won|lost)$/.test(contract.status)) {
                // for contracts that won, highest/lowest tick will be the quote of the selected tick
                // for contracts that lost, API will send sell spot to mark highest/lowest spot
                var high_low_barrier = contract.status === 'won' ? (applicable_ticks[+selected_tick - 1] || {}).quote : +contract.sell_spot;

                if (high_low_barrier) {
                    should_set_barrier = false;

                    chart.yAxis[0].addPlotLine({
                        id: 'tick-barrier',
                        value: high_low_barrier,
                        color: '#e98024',
                        label: {
                            text: localize(/^tickhigh_/i.test(contract.shortcode) ? 'Highest Tick' : 'Lowest Tick') + ' (' + addComma(high_low_barrier) + ')',
                            align: 'center'
                        },
                        width: 2,
                        zIndex: 2,
                        dashStyle: 'dash'
                    });
                }
            }
        }

        if (calculated_barrier) {
            CommonFunctions.elementInnerHtml(CommonFunctions.getElementById('contract_purchase_barrier'), localize('Barrier') + ': ' + calculated_barrier);
        }
    };

    var add = function add(indicator) {
        chart.xAxis[0].addPlotLine({
            value: indicator.index,
            id: indicator.id,
            label: { text: indicator.label, x: /start_tick|entry_tick/.test(indicator.id) ? -15 : 5 },
            color: indicator.color || '#e98024',
            width: 2,
            zIndex: 2,
            dashStyle: indicator.dashStyle || ''
        });
    };

    var evaluateContractOutcome = function evaluateContractOutcome() {
        if (contract.status && contract.status !== 'open') {
            if (contract.status === 'won') {
                if (show_contract_result) {
                    $('#' + id_render).css('background-color', winning_color);
                }
                updatePurchaseStatus(payout, price, localize('This contract won'));
            } else if (contract.status === 'lost') {
                if (show_contract_result) {
                    $('#' + id_render).css('background-color', losing_color);
                }
                updatePurchaseStatus(0, -price, localize('This contract lost'));
            }

            addSellSpot();
        }

        if (Reset.isReset(contract_category) && Reset.isNewBarrier(contract.entry_spot, contract.barrier)) {
            plotResetSpot(+contract.barrier);
        }
    };

    var plot = function plot() {
        contract_start_moment = moment(contract_start_ms).utc();
        counter = 0;
        applicable_ticks = [];
    };

    var dispatch = function dispatch(data) {
        var tick_chart = CommonFunctions.getElementById(id_render);

        if (!CommonFunctions.isVisible(tick_chart) || !data || !data.tick && !data.history) {
            return;
        }

        if (subscribe && data.tick && document.getElementById('sell_content_wrapper')) {
            response_id = data.tick.id;
            ViewPopupUI.storeSubscriptionID(response_id);
        }

        var epoches = void 0,
            spots2 = void 0,
            chart_display_decimals = void 0;

        if (document.getElementById('sell_content_wrapper')) {
            if (data.tick) {
                Tick.details(data);
                if (!chart_display_decimals) {
                    chart_display_decimals = data.tick.quote.split('.')[1].length || 2;
                }
            } else if (data.history) {
                if (!chart_display_decimals) {
                    chart_display_decimals = data.history.prices[0].split('.')[1].length || 2;
                }
            }
            if (!tick_init && contract) {
                var category = 'callput';
                if (/asian/i.test(contract.shortcode)) {
                    category = 'asian';
                } else if (/digit/i.test(contract.shortcode)) {
                    category = 'digits';
                } else if (/touch/i.test(contract.shortcode)) {
                    category = 'touchnotouch';
                } else if (/reset/i.test(contract.shortcode)) {
                    category = 'reset';
                } else if (/^(tickhigh|ticklow)_/i.test(contract.shortcode)) {
                    category = 'highlowticks';
                }
                initialize({
                    symbol: contract.underlying,
                    number_of_ticks: contract.tick_count,
                    contract_category: category,
                    longcode: contract.longcode,
                    display_symbol: contract.display_name,
                    contract_start: contract.date_start,
                    display_decimals: chart_display_decimals,
                    show_contract_result: 0
                }, data);
                spots_list = {};
                tick_init = 'initialized';
                return;
            }
        }
        if (data.tick) {
            spots2 = Tick.spots();
            epoches = Object.keys(spots2).sort(function (a, b) {
                return a - b;
            });
        } else if (data.history) {
            epoches = data.history.times;
        }

        var has_finished = applicable_ticks && ticks_needed && applicable_ticks.length >= ticks_needed;
        var has_sold = contract && contract.sell_spot_time && applicable_ticks && applicable_ticks.find(function (_ref) {
            var epoch = _ref.epoch;
            return +epoch === +contract.sell_spot_time;
        }) !== undefined;

        if (!has_finished && !has_sold && (!data.tick || !contract.status || contract.status === 'open')) {
            var should_show_all_ticks = true;
            for (var d = 0; d < epoches.length; d++) {
                var tick = void 0;
                if (data.tick) {
                    tick = {
                        epoch: parseInt(epoches[d]),
                        quote: parseFloat(spots2[epoches[d]])
                    };
                } else if (data.history) {
                    tick = {
                        epoch: parseInt(data.history.times[d]),
                        quote: parseFloat(data.history.prices[d])
                    };
                }

                var current_tick_count = applicable_ticks.length + 1;
                // for contracts that lost, sell spot time will have the value of the highest/lowest tick
                // if current tick is selected tick and current tick occurs after sell spot time (highest/lowest tick), then don't show it
                if (contract.status === 'lost' && current_tick_count > +selected_tick && tick.epoch > +contract.sell_spot_time) {
                    should_show_all_ticks = false;
                }

                if (contract_start_moment && tick.epoch > contract_start_moment.unix() && !spots_list[tick.epoch] && should_show_all_ticks) {
                    if (!chart || !chart.series) return;
                    chart.series[0].addPoint([counter, tick.quote], true, false);

                    if (+selected_tick === current_tick_count) {
                        var points = chart.series[0].points;
                        points[points.length - 1].update({ marker: marker });
                    }

                    applicable_ticks.push(tick);
                    spots_list[tick.epoch] = tick.quote;
                    var indicator_key = '_' + counter;

                    var exit_time = contract ? Math.min(+contract.sell_spot_time, +contract.exit_tick_time) || +contract.sell_spot_time || +contract.exit_tick_time : '';

                    if (!x_indicators[indicator_key] && tick.epoch === exit_time && contract_category !== 'highlowticks') {
                        x_indicators[indicator_key] = {
                            index: counter,
                            label: getExitLabel(),
                            dashStyle: 'Dash'
                        };
                    }

                    if (typeof x_indicators[indicator_key] !== 'undefined') {
                        x_indicators[indicator_key].index = counter;
                        add(x_indicators[indicator_key]);
                    }

                    addBarrier();
                    counter++;
                }
            }
            if (Reset.isReset(contract_category) && data.history) {
                plotResetSpot();
            }
        }
    };

    var removePlotLine = function removePlotLine(id) {
        var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'y';

        if (!chart) return;
        chart[type + 'Axis'][0].removePlotLine(id);
    };

    var plotResetSpot = function plotResetSpot(r_barrier) {
        if (reset_spot_plotted || !chart) return;

        var is_resetcall = contract.contract_type === 'RESETCALL';
        var entry_barrier = contract.entry_spot;
        var reset_barrier = r_barrier || contract.barrier;

        if (!+entry_barrier || !+reset_barrier) return;

        if (+entry_barrier !== +reset_barrier) {
            removePlotLine('tick-barrier', 'y');

            chart.yAxis[0].addPlotLine({
                id: 'tick-reset-barrier',
                value: +reset_barrier,
                label: { text: localize('Reset Barrier') + ' (' + addComma(reset_barrier) + ')', align: 'right', x: -60, y: is_resetcall ? 15 : -5 },
                color: 'green',
                width: 2,
                zIndex: 3
            });
            chart.yAxis[0].addPlotLine({
                id: 'tick-barrier',
                value: +entry_barrier,
                label: { text: localize('Barrier') + ' (' + addComma(entry_barrier) + ')', align: 'right', x: -60, y: is_resetcall ? -5 : 15 },
                color: 'green',
                width: 2,
                zIndex: 3,
                dashStyle: 'dot'
            });

            CommonFunctions.elementInnerHtml(CommonFunctions.getElementById('contract_purchase_barrier'), localize('Reset Barrier') + ': ' + reset_barrier);
            reset_spot_plotted = true;
        }

        evaluateContractOutcome();
    };

    var addSellSpot = function addSellSpot() {
        if (!applicable_ticks || !contract) return;

        if (contract_category === 'highlowticks') {
            addBarrier();
            return;
        }

        var index = applicable_ticks.findIndex(function (_ref2) {
            var epoch = _ref2.epoch;
            return epoch === +contract.sell_spot_time;
        });

        // if sell spot time is later than exit tick time, use that instead
        if (index === -1) {
            index = applicable_ticks.findIndex(function (_ref3) {
                var epoch = _ref3.epoch;
                return epoch === +contract.exit_tick_time;
            });
        }

        if (index === -1) return;

        var indicator_key = '_' + index;

        if (x_indicators[indicator_key]) return;

        x_indicators[indicator_key] = {
            index: index,
            label: getExitLabel(),
            dashStyle: 'Dash'
        };

        add(x_indicators[indicator_key]);
    };

    var getExitLabel = function getExitLabel() {
        return contract && contract.sell_spot_time && contract.exit_tick_time && +contract.sell_spot_time >= +contract.exit_tick_time ? 'Exit Spot' : 'Sell Spot';
    };

    var updateContract = function updateContract(proposal_open_contract) {
        contract = proposal_open_contract;

        if (/^(tickhigh|ticklow)_/i.test(contract.shortcode)) {
            var arr_shortcode = contract.shortcode.split('_');
            selected_tick = arr_shortcode[arr_shortcode.length - 1];
        } else {
            selected_tick = '';
        }
    };

    var updateChart = function updateChart(data, proposal_open_contract) {
        subscribe = 'false';
        if (proposal_open_contract) {
            updateContract(proposal_open_contract);
        }

        if (data.is_sold) {
            addSellSpot();
        } else if (proposal_open_contract) {
            if (data.id_render) {
                id_render = data.id_render;
            }

            var request = {
                ticks_history: contract.underlying,
                start: contract.date_start,
                end: 'latest'
            };
            if (contract.current_spot_time < contract.date_expiry) {
                request.subscribe = 1;
                subscribe = 'true';
            } else if (!/^(tickhigh|ticklow)_/i.test(contract.shortcode) && contract.sell_spot_time && +contract.sell_spot_time < +contract.date_expiry) {
                request.end = contract.sell_spot_time;
            } else {
                request.end = contract.date_expiry;
            }
            if (data.request_ticks) {
                // we shouldn't send this multiple times on every update
                tick_init = '';
                BinarySocket.send(request, { callback: dispatch });
            }
        } else {
            dispatch(data);
        }
    };

    return {
        plotResetSpot: plotResetSpot,
        updateChart: updateChart,
        init: initialize,
        resetSpots: function resetSpots() {
            spots_list = {};updateContract({});$('#' + id_render).css('background-color', '#F2F2F2');
        },
        setStatus: function setStatus(proposal_open_contract) {
            updateContract(proposal_open_contract);
            evaluateContractOutcome();
        }
    };
}();

module.exports = TickDisplay;

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Client = __webpack_require__(3);
var formatMoney = __webpack_require__(7).formatMoney;
var localize = __webpack_require__(2).localize;

var updatePurchaseStatus = function updatePurchaseStatus(final_price, pnl, contract_status) {
    $('#contract_purchase_heading').text(localize(contract_status));
    var $payout = $('#contract_purchase_payout');
    var $cost = $('#contract_purchase_cost');
    var $profit = $('#contract_purchase_profit');
    var currency = Client.get('currency');

    $payout.html($('<div/>', { text: localize('Buy price') }).append($('<p/>', { html: formatMoney(currency, Math.abs(pnl)) })));
    $cost.html($('<div/>', { text: localize('Final price') }).append($('<p/>', { html: formatMoney(currency, final_price) })));
    if (!final_price) {
        $profit.html($('<div/>', { text: localize('Loss') }).append($('<p/>', { html: formatMoney(currency, pnl) })));
    } else {
        $profit.html($('<div/>', { text: localize('Profit') }).append($('<p/>', { html: formatMoney(currency, final_price - pnl) })));
        updateContractBalance(Client.get('balance'));
    }
};

var updateContractBalance = function updateContractBalance(balance) {
    $('#contract_purchase_balance').html(localize('Account balance:') + ' ' + formatMoney(Client.get('currency'), balance));
};

module.exports = {
    updatePurchaseStatus: updatePurchaseStatus,
    updateContractBalance: updateContractBalance
};

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Portfolio = __webpack_require__(295).Portfolio;
var ViewPopup = __webpack_require__(90);
var Client = __webpack_require__(3);
var toJapanTimeIfNeeded = __webpack_require__(26).toJapanTimeIfNeeded;
var BinarySocket = __webpack_require__(5);
var formatMoney = __webpack_require__(7).formatMoney;
var GetAppDetails = __webpack_require__(57);
var localize = __webpack_require__(2).localize;
var urlParam = __webpack_require__(8).param;
var getPropertyValue = __webpack_require__(1).getPropertyValue;
var showLoadingImage = __webpack_require__(1).showLoadingImage;

var PortfolioInit = function () {
    var values = void 0,
        currency = void 0,
        oauth_apps = void 0,
        is_initialized = void 0,
        is_first_response = void 0,
        $portfolio_loading = void 0,
        is_jp_client = void 0;

    var init = function init() {
        updateBalance();

        if (is_initialized) return;

        values = {};
        currency = '';
        oauth_apps = {};
        $portfolio_loading = $('#portfolio-loading');
        is_jp_client = Client.isJPClient();
        $portfolio_loading.show();
        showLoadingImage($portfolio_loading[0]);
        is_first_response = true;
        BinarySocket.send({ portfolio: 1 }).then(function (response) {
            updatePortfolio(response);
        });
        // Subscribe to transactions to auto update new purchases
        BinarySocket.send({ transaction: 1, subscribe: 1 }, { callback: transactionResponseHandler });
        BinarySocket.send({ oauth_apps: 1 }).then(function (response) {
            updateOAuthApps(response);
        });
        is_initialized = true;

        // Display ViewPopup according to contract_id in query string
        var contract_id = urlParam('contract_id');
        if (contract_id) {
            ViewPopup.init($('<div />', { contract_id: contract_id }).get(0));
        }
    };

    var createPortfolioRow = function createPortfolioRow(data, is_first) {
        var new_class = is_first ? '' : 'new';
        var $div = $('<div/>');
        $div.append($('<tr/>', { class: 'tr-first ' + new_class + ' ' + data.contract_id, id: data.contract_id }).append($('<td/>', { class: 'ref' }).append($('<span ' + GetAppDetails.showTooltip(data.app_id, oauth_apps[data.app_id]) + ' data-balloon-position="right">' + data.transaction_id + '</span>'))).append($('<td/>', { class: 'payout' }).append($('<strong/>', { html: +data.payout ? formatMoney(data.currency, data.payout) : '-' }))).append($('<td/>', { class: 'details', text: data.longcode })).append($('<td/>', { class: 'purchase' }).append($('<strong/>', { html: formatMoney(data.currency, data.buy_price) }))).append($('<td/>', { class: 'indicative' }).append($('<strong/>', { class: 'indicative_price', text: '--.--' }))).append($('<td/>', { class: 'button' }).append($('<button/>', { class: 'button open_contract_details nowrap', contract_id: data.contract_id, text: localize('View') })))).append($('<tr/>', { class: 'tr-desc ' + new_class + ' ' + data.contract_id }).append($('<td/>', { colspan: '6', text: data.longcode })));

        if (is_jp_client) {
            var $td = $('<td/>', { class: 'expires nowrap' }).append($('<strong/>', { text: toJapanTimeIfNeeded(data.expiry_time) }));
            $td.insertAfter($div.find('.payout'));
        }

        $('#portfolio-body').prepend($div.html());
    };

    var updateBalance = function updateBalance() {
        var $portfolio_balance = $('#portfolio-balance');
        if ($portfolio_balance.length === 0) return;
        $portfolio_balance.html(Portfolio.getBalance(Client.get('balance'), Client.get('currency')));
        var $if_balance_zero = $('#if-balance-zero');
        if (Client.get('balance') > 0 || Client.get('is_virtual')) {
            $if_balance_zero.setVisibility(0);
        } else {
            $if_balance_zero.setVisibility(1);
        }
    };

    var updatePortfolio = function updatePortfolio(data) {
        if (getPropertyValue(data, 'error')) {
            errorMessage(data.error.message);
            return;
        }

        var portfolio_data = void 0;
        if (data.portfolio.contracts.length !== 0) {
            /**
             * User has at least one contract
             **/
            $('#portfolio-no-contract').hide();
            $.each(data.portfolio.contracts, function (ci, c) {
                // TODO: remove ico exception when all ico contracts are removed
                if (!getPropertyValue(values, c.contract_id) && c.contract_type !== 'BINARYICO') {
                    values[c.contract_id] = {};
                    values[c.contract_id].buy_price = c.buy_price;
                    portfolio_data = Portfolio.getPortfolioData(c);
                    currency = portfolio_data.currency;
                    createPortfolioRow(portfolio_data, is_first_response);
                    setTimeout(function () {
                        $('tr.' + c.contract_id).removeClass('new');
                    }, 1000);
                }
            });
        }
        // no open contracts
        if (!portfolio_data) {
            $('#portfolio-no-contract').show();
            $('#portfolio-table').setVisibility(0);
        } else {
            $('#portfolio-table').setVisibility(1);
            // update footer area data
            updateFooter();

            // request "proposal_open_contract"
            BinarySocket.send({ proposal_open_contract: 1, subscribe: 1 }, { callback: updateIndicative });
        }
        // ready to show portfolio table
        $portfolio_loading.hide();
        $('#portfolio-content').setVisibility(1);
        is_first_response = false;
    };

    var transactionResponseHandler = function transactionResponseHandler(response) {
        if (getPropertyValue(response, 'error')) {
            errorMessage(response.error.message);
        } else if (response.transaction.action === 'buy') {
            BinarySocket.send({ portfolio: 1 }).then(function (res) {
                updatePortfolio(res);
            });
        } else if (response.transaction.action === 'sell') {
            removeContract(response.transaction.contract_id);
        }
    };

    var updateIndicative = function updateIndicative(data) {
        if (getPropertyValue(data, 'error') || !values) {
            return;
        }

        var proposal = Portfolio.getProposalOpenContract(data.proposal_open_contract);
        // avoid updating 'values' before the new contract row added to the table
        if (!getPropertyValue(values, proposal.contract_id)) {
            return;
        }

        // force to sell the expired contract, in order to remove from portfolio
        if (+proposal.is_settleable === 1 && !proposal.is_sold) {
            BinarySocket.send({ sell_expired: 1 });
        }
        var $td = $('#' + proposal.contract_id).find('td.indicative');

        var old_indicative = values[proposal.contract_id].indicative || 0.00;
        values[proposal.contract_id].indicative = proposal.bid_price;

        var status_class = '';
        var no_resale_html = '';
        if (+proposal.is_sold === 1) {
            removeContract(proposal.contract_id);
        } else {
            if (+proposal.is_valid_to_sell !== 1) {
                no_resale_html = $('<span/>', { class: 'message', text: localize('Resale not offered') });
                $td.addClass('no_resale');
            } else {
                if (values[proposal.contract_id].indicative !== old_indicative) {
                    status_class = values[proposal.contract_id].indicative > old_indicative ? 'price_moved_up' : 'price_moved_down';
                }
                $td.removeClass('no_resale');
            }
            $td.html($('<strong/>', { class: 'indicative_price ' + status_class, html: formatMoney(proposal.currency, values[proposal.contract_id].indicative) }).append(no_resale_html));
        }

        updateFooter();
    };

    var updateOAuthApps = function updateOAuthApps(response) {
        oauth_apps = GetAppDetails.buildOauthApps(response);
        GetAppDetails.addTooltip(oauth_apps);
    };

    var removeContract = function removeContract(contract_id) {
        delete values[contract_id];
        $('tr.' + contract_id).removeClass('new').css('opacity', '0.5').fadeOut(1000, function () {
            $(this).remove();
            if ($('#portfolio-body').find('tr').length === 0) {
                $('#portfolio-table').setVisibility(0);
                $('#cost-of-open-positions, #value-of-open-positions').text('');
                $('#portfolio-no-contract').show();
            }
        });
        updateFooter();
    };

    var updateFooter = function updateFooter() {
        $('#cost-of-open-positions').html(formatMoney(currency, Portfolio.getSumPurchase(values)));
        $('#value-of-open-positions').html(formatMoney(currency, Portfolio.getIndicativeSum(values)));
    };

    var errorMessage = function errorMessage(msg) {
        var $err = $('#portfolio').find('#error-msg');
        if (msg) {
            $err.setVisibility(1).text(msg);
            $portfolio_loading.hide();
        } else {
            $err.setVisibility(0).text('');
        }
    };

    var onLoad = function onLoad() {
        init();
        ViewPopup.viewButtonOnClick('#portfolio-table');
    };

    var onUnload = function onUnload() {
        BinarySocket.send({ forget_all: ['proposal_open_contract', 'transaction'] });
        $('#portfolio-body').empty();
        $('#portfolio-content').setVisibility(0);
        is_initialized = false;
    };

    return {
        updateBalance: updateBalance,
        onLoad: onLoad,
        onUnload: onUnload
    };
}();

module.exports = PortfolioInit;

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var MetaTraderConfig = __webpack_require__(182);
var MetaTraderUI = __webpack_require__(319);
var Client = __webpack_require__(3);
var BinarySocket = __webpack_require__(5);
var Validation = __webpack_require__(56);
var localize = __webpack_require__(2).localize;
var State = __webpack_require__(6).State;
var toTitleCase = __webpack_require__(17).toTitleCase;
var getPropertyValue = __webpack_require__(1).getPropertyValue;

var MetaTrader = function () {
    var mt_companies = MetaTraderConfig.mt_companies;
    var accounts_info = MetaTraderConfig.accounts_info;
    var actions_info = MetaTraderConfig.actions_info;
    var fields = MetaTraderConfig.fields;

    var mt_company = {};

    var onLoad = function onLoad() {
        BinarySocket.wait('landing_company', 'get_account_status').then(function () {
            if (isEligible()) {
                if (Client.get('is_virtual')) {
                    getAllAccountsInfo();
                } else {
                    BinarySocket.send({ get_limits: 1 }).then(getAllAccountsInfo);
                    getExchangeRates();
                }
            } else if (State.getResponse('landing_company.gaming_company.shortcode') === 'malta') {
                // TODO: remove this elseif when we enable mt account opening for malta
                // show specific message to clients from malta landing company as long as there is no mt_company for them
                MetaTraderUI.displayPageError(localize('Our MT5 service is currently unavailable to EU residents due to pending regulatory approval.'));
            } else {
                MetaTraderUI.displayPageError(localize('Sorry, this feature is not available in your jurisdiction.'));
            }
        });
    };

    // we need to calculate min/max equivalent to 1 and 20000 USD, so get exchange rates for all currencies based on USD
    var getExchangeRates = function getExchangeRates() {
        return BinarySocket.send({ exchange_rates: 1, base_currency: 'USD' });
    };

    var isEligible = function isEligible() {
        var has_mt_company = false;
        Object.keys(mt_companies).forEach(function (company) {
            mt_company[company] = State.getResponse('landing_company.mt_' + company + '_company.shortcode');
            if (mt_company[company]) {
                has_mt_company = true;
                addAccount(company);
            }
        });
        return has_mt_company;
    };

    var addAccount = function addAccount(company) {
        ['demo', 'real'].forEach(function (type) {
            Object.keys(mt_companies[company]).forEach(function (acc_type) {
                var company_info = mt_companies[company][acc_type];
                var mt5_account_type = company_info.mt5_account_type;
                var title = localize(toTitleCase(type) + ' ' + company_info.title);
                var is_demo = type === 'demo';

                if (!(is_demo && company_info.is_real_only)) {
                    accounts_info[type + '_' + mt_company[company] + (mt5_account_type ? '_' + mt5_account_type : '')] = {
                        title: title,
                        is_demo: is_demo,
                        mt5_account_type: mt5_account_type,
                        account_type: is_demo ? 'demo' : company,
                        max_leverage: company_info.max_leverage,
                        short_title: company_info.title
                    };
                }
            });
        });
    };

    var getAllAccountsInfo = function getAllAccountsInfo() {
        MetaTraderUI.init(submit);
        BinarySocket.send({ mt5_login_list: 1 }).then(function (response) {
            if (response.error) {
                MetaTraderUI.displayPageError(response.error.message || localize('Sorry, an error occurred while processing your request.'));
                return;
            }
            // Ignore old accounts which are not linked to any group or has deprecated group
            var mt5_login_list = (response.mt5_login_list || []).filter(function (obj) {
                return obj.group && Client.getMT5AccountType(obj.group) in accounts_info;
            });

            // Update account info
            mt5_login_list.forEach(function (obj) {
                var acc_type = Client.getMT5AccountType(obj.group);
                accounts_info[acc_type].info = { login: obj.login };
                setAccountDetails(obj.login, acc_type, response);
            });

            var current_acc_type = getDefaultAccount();
            Client.set('mt5_account', current_acc_type);
            MetaTraderUI.showHideMAM(current_acc_type);

            // Update types with no account
            Object.keys(accounts_info).filter(function (acc_type) {
                return !MetaTraderConfig.hasAccount(acc_type);
            }).forEach(function (acc_type) {
                MetaTraderUI.updateAccount(acc_type);
            });
        });
    };

    var getDefaultAccount = function getDefaultAccount() {
        var default_account = '';
        if (MetaTraderConfig.hasAccount(Client.get('mt5_account'))) {
            default_account = Client.get('mt5_account');
        } else {
            default_account = MetaTraderConfig.getAllAccounts()[0] || '';
        }
        return default_account;
    };

    var setAccountDetails = function setAccountDetails(login, acc_type, data) {
        if (data.mt5_login_list) {
            var info = data.mt5_login_list.find(function (mt5_account) {
                return mt5_account.login === login;
            });
            if (info) {
                accounts_info[acc_type].info = info;
                MetaTraderUI.updateAccount(acc_type);
            }
        }
    };

    var makeRequestObject = function makeRequestObject(acc_type, action) {
        var req = {};

        Object.keys(fields[action]).forEach(function (field) {
            var field_obj = fields[action][field];
            if (field_obj.request_field) {
                req[field_obj.request_field] = MetaTraderUI.$form().find(field_obj.id).val();
            }
        });

        if (!/^(verify_password_reset|revoke_mam)$/.test(action)) {
            // set main command
            req['mt5_' + action.replace(action === 'new_account_mam' ? '_mam' : '', '')] = 1;
        }

        // add additional fields
        $.extend(req, fields[action].additional_fields(acc_type, MetaTraderUI.getToken()));

        return req;
    };

    var submit = function submit(e) {
        e.preventDefault();
        var $btn_submit = $(e.target);
        var acc_type = $btn_submit.attr('acc_type');
        var action = $btn_submit.attr('action');
        MetaTraderUI.hideFormMessage(action);
        if (Validation.validate('#frm_' + action)) {
            MetaTraderUI.disableButton(action);
            // further validations before submit (password_check)
            MetaTraderUI.postValidate(acc_type, action).then(function (is_ok) {
                if (!is_ok) {
                    MetaTraderUI.enableButton(action);
                    return;
                }

                var req = makeRequestObject(acc_type, action);
                BinarySocket.send(req).then(function (response) {
                    if (response.error) {
                        MetaTraderUI.displayFormMessage(response.error.message, action);
                        if (typeof actions_info[action].onError === 'function') {
                            actions_info[action].onError(response, MetaTraderUI.$form());
                        }
                        if (/^MT5(Deposit|Withdrawal)Error$/.test(response.error.code)) {
                            getExchangeRates();
                        }
                    } else {
                        var login = actions_info[action].login ? actions_info[action].login(response) : accounts_info[acc_type].info.login;
                        if (!accounts_info[acc_type].info) {
                            // it's a new account
                            accounts_info[acc_type].info = { login: login, currency: getPropertyValue(response, ['mt5_new_account', 'currency']) };
                            MetaTraderUI.setAccountType(acc_type, true);
                            BinarySocket.send({ mt5_login_list: 1 });
                            MetaTraderUI.loadAction(null, acc_type);
                        } else {
                            // other than revoke mam, other actions are two forms in one action, so we need the parent action to be loaded for them
                            var parent_action = /password/.test(action) ? 'manage_password' : 'cashier';
                            MetaTraderUI.loadAction(action === 'revoke_mam' ? action : parent_action);
                        }
                        BinarySocket.send({ mt5_login_list: 1 }).then(function (response_login_list) {
                            setAccountDetails(login, acc_type, response_login_list);
                            if (/^(revoke_mam|new_account_mam)/.test(action)) {
                                MetaTraderUI.showHideMAM(acc_type);
                            }
                        });
                        if (typeof actions_info[action].success_msg === 'function') {
                            var success_msg = actions_info[action].success_msg(response, acc_type);
                            if (actions_info[action].success_msg_selector) {
                                MetaTraderUI.displayMessage(actions_info[action].success_msg_selector, success_msg, 1);
                            } else {
                                MetaTraderUI.displayMainMessage(success_msg);
                            }
                        }
                        if (typeof actions_info[action].onSuccess === 'function') {
                            actions_info[action].onSuccess(response, MetaTraderUI.$form());
                        }
                    }
                    MetaTraderUI.enableButton(action, response);
                });
            });
        }
    };

    return {
        onLoad: onLoad,
        isEligible: isEligible
    };
}();

module.exports = MetaTrader;

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var moment = __webpack_require__(9);
var formatMoney = __webpack_require__(7).formatMoney;
var localize = __webpack_require__(2).localize;
var LocalStore = __webpack_require__(6).LocalStore;

var RealityCheckData = function () {
    var reality_object = {};

    var resetInvalid = function resetInvalid() {
        var ack = get('ack');
        var interval = +get('interval');
        if (ack !== 0 && ack !== 1) {
            set('ack', 0);
        }
        if (!interval) {
            set('interval', 600000);
        }
    };

    var summaryData = function summaryData(data) {
        var start_time = moment.utc(new Date(data.start_time * 1000));
        var current_time = moment.utc();

        var session_duration = moment.duration(current_time.diff(start_time));
        var duration_string = localize('[_1] days [_2] hours [_3] minutes', [session_duration.get('days'), session_duration.get('hours'), session_duration.get('minutes')]);

        var turnover = +data.buy_amount + +data.sell_amount;
        var profit_loss = +data.sell_amount - +data.buy_amount;

        return {
            start_time_string: localize('Your trading statistics since [_1].', [start_time.format('YYYY-MM-DD HH:mm:ss') + ' GMT']),
            login_time: start_time.format('YYYY-MM-DD HH:mm:ss') + ' GMT',
            current_time: current_time.format('YYYY-MM-DD HH:mm:ss') + ' GMT',
            session_duration: duration_string,
            loginid: data.loginid,
            currency: data.currency,
            turnover: formatMoney(data.currency, +turnover, 1),
            profit_loss: formatMoney(data.currency, +profit_loss, 1),
            contracts_bought: data.buy_count,
            contracts_sold: data.sell_count,
            open_contracts: data.open_contract_count,
            potential_profit: formatMoney(data.currency, +data.potential_profit, 1)
        };
    };

    var set = function set(key, value) {
        reality_object[key] = value;
        return LocalStore.set('reality_check.' + key, value);
    };

    // use this function to get variables that have values
    var get = function get(key) {
        var value = reality_object[key] || LocalStore.get('reality_check.' + key) || '';
        if (+value === 1 || +value === 0 || value === 'true' || value === 'false') {
            value = JSON.parse(value || false);
        }
        return value;
    };

    var clear = function clear() {
        // clear all reality check values from local storage
        Object.keys(localStorage).forEach(function (c) {
            if (/^reality_check\./.test(c)) {
                LocalStore.set(c, '');
            }
        });

        var hash = window.location.hash;
        if (/no-reality-check/.test(hash)) {
            window.location.hash = hash.replace('no-reality-check', '');
        }
    };

    return {
        resetInvalid: resetInvalid,
        summaryData: summaryData,
        set: set,
        get: get,
        clear: clear
    };
}();

module.exports = RealityCheckData;

/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var setExternalTimer = __webpack_require__(26).setExternalTimer;
var BinarySocket = __webpack_require__(5);
var getHighestZIndex = __webpack_require__(1).getHighestZIndex;

var ViewPopupUI = function () {
    var $container = void 0,
        stream_ids = void 0,
        chart_stream_ids = void 0,
        triggerOnClose = void 0;

    var init = function init() {
        $container = null;
    };

    var container = function container(refresh) {
        if (refresh) {
            if ($container) {
                $container.remove();
            }
            $container = null;
        }
        if (!$container) {
            var $con = $('<div class="inpage_popup_container" id="sell_popup_container"><a class="close"></a><div class="inpage_popup_content"></div></div>');
            $con.hide();
            var onClose = function onClose() {
                cleanup(true);
                $(document).off('keydown');
                $(window).off('popstate', onClose);
            };
            $con.find('a.close').on('click', onClose);
            $(document).on('keydown', function (e) {
                if (e.which === 27) onClose();
            });
            $(window).on('popstate', onClose);
            $container = $con;
        }
        return $container;
    };

    var cleanup = function cleanup(is_close) {
        forgetStreams();
        forgetChartStreams();
        setExternalTimer(null);
        closeContainer();
        init();
        if (typeof triggerOnClose === 'function') {
            triggerOnClose();
            if (is_close) {
                triggerOnClose = '';
            }
        }
        $(window).off('resize', function () {
            repositionConfirmation();
        });
    };

    var forgetStreams = function forgetStreams() {
        while (stream_ids && stream_ids.length > 0) {
            var id = stream_ids.pop();
            if (id && id.length > 0) {
                BinarySocket.send({ forget: id });
            }
        }
    };

    var forgetChartStreams = function forgetChartStreams() {
        while (chart_stream_ids && chart_stream_ids.length > 0) {
            var id = chart_stream_ids.pop();
            if (id && id.length > 0) {
                BinarySocket.send({ forget: id });
            }
        }
    };

    var closeContainer = function closeContainer() {
        if ($container) {
            $container.hide().remove();
            $('.popup_page_overlay').hide().remove();
            $container = null;
        }
        $('html').removeClass('no-scroll');
    };

    var disableButton = function disableButton(button) {
        $('.open_contract_details[disabled]').each(function () {
            enableButton($(this));
        });
        button.attr('disabled', 'disabled');
        button.fadeTo(0, 0.5);
    };

    var enableButton = function enableButton(button) {
        button.removeAttr('disabled');
        button.fadeTo(0, 1);
    };

    var showInpagePopup = function showInpagePopup(data, containerClass, dragHandle) {
        var con = container(true);
        if (containerClass) {
            con.addClass(containerClass);
        }
        if (data) {
            $('.inpage_popup_content', con).html(data);
        }
        var body = $(document.body);
        con.css('position', 'fixed').css('z-index', getHighestZIndex() + 100);
        body.append(con);
        con.show();
        // $('html').addClass('no-scroll');
        $(document.body).append($('<div/>', { class: 'popup_page_overlay' }));
        $('.popup_page_overlay').click(function () {
            container().find('a.close').click();
        });
        con.draggable({
            stop: function stop() {
                repositionConfirmationOnDrag();
            },
            handle: dragHandle,
            scroll: false
        });
        repositionConfirmation();
        $(window).resize(function () {
            repositionConfirmation();
        });
        return con;
    };

    var repositionConfirmationOnDrag = function repositionConfirmationOnDrag() {
        var con = container();
        var offset = con.offset();
        var $window = $(window);
        // top
        if (offset.top < $window.scrollTop()) {
            con.offset({ top: $window.scrollTop() });
        }
        // left
        if (offset.left < 0) {
            con.offset({ left: 0 });
        }
        // right
        if (offset.left > $window.width() - con.width()) {
            con.offset({ left: $window.width() - con.width() });
        }
    };

    var repositionConfirmation = function repositionConfirmation(x, y) {
        var con = container();
        var $window = $(window);
        var x_min = 0;
        var y_min = 500;
        if ($window.width() < 767) {
            // To be responsive, on mobiles and phablets we show popup as full screen.
            x_min = 0;
            y_min = 0;
        }
        var new_x = void 0,
            new_y = void 0;
        if (x === undefined) {
            new_x = Math.max(Math.floor(($window.width() - $window.scrollLeft() - con.width()) / 2), x_min) + $window.scrollLeft();
        }
        if (y === undefined) {
            new_y = Math.min(Math.floor(($window.height() - con.height()) / 2), y_min) + $window.scrollTop();
            if (y < $window.scrollTop()) {
                new_y = $window.scrollTop();
            }
        }
        con.offset({ left: x || new_x, top: y || new_y });
        repositionConfirmationOnDrag();
    };

    // ===== Dispatch =====
    var storeSubscriptionID = function storeSubscriptionID(id, is_chart) {
        if (!stream_ids && !is_chart) {
            stream_ids = [];
        }
        if (!chart_stream_ids) {
            chart_stream_ids = [];
        }
        if (id && id.length > 0) {
            if (!is_chart && $.inArray(id, stream_ids) < 0) {
                stream_ids.push(id);
            } else if (is_chart && $.inArray(id, chart_stream_ids) < 0) {
                chart_stream_ids.push(id);
            }
        }
    };

    return {
        cleanup: cleanup,
        forgetStreams: forgetStreams,
        disableButton: disableButton,
        enableButton: enableButton,
        showInpagePopup: showInpagePopup,
        repositionConfirmation: repositionConfirmation,
        storeSubscriptionID: storeSubscriptionID,

        setOnCloseFunction: function setOnCloseFunction(onCloseFnc) {
            triggerOnClose = onCloseFnc;
        }
    };
}();

module.exports = ViewPopupUI;

/***/ }),
/* 132 */,
/* 133 */,
/* 134 */,
/* 135 */,
/* 136 */,
/* 137 */,
/* 138 */,
/* 139 */,
/* 140 */,
/* 141 */,
/* 142 */,
/* 143 */,
/* 144 */,
/* 145 */,
/* 146 */,
/* 147 */,
/* 148 */,
/* 149 */,
/* 150 */,
/* 151 */,
/* 152 */,
/* 153 */,
/* 154 */,
/* 155 */,
/* 156 */,
/* 157 */,
/* 158 */,
/* 159 */,
/* 160 */,
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var urlLang = __webpack_require__(16).urlLang;
var createElement = __webpack_require__(1).createElement;

var Crowdin = function () {
    /**
     * in-context translation provided at: https://staging.binary.com/translations/
     * and uses 'ach' as pseudo language code
     */
    var isInContextEnvironment = function isInContextEnvironment() {
        return (/^https:\/\/staging\.binary\.com\/translations\//i.test(window.location.href) && /ach/i.test(urlLang())
        );
    };

    /**
     * initialize Crowdin in-context environment
     */
    var init = function init() {
        if (isInContextEnvironment()) {
            var lang = document.querySelector('#topbar ul[id$="_language"]');
            if (lang) lang.setVisibility(0);
            /* eslint-disable no-underscore-dangle */
            window._jipt = [];
            window._jipt.push(['project', 'binary-static']);
            /* eslint-enable no-underscore-dangle */
            if (document.body) {
                document.body.appendChild(createElement('script', { type: 'text/javascript', src: document.location.protocol + '//cdn.crowdin.com/jipt/jipt.js' }));
            }
        }
    };

    return {
        init: init,
        isInContext: isInContextEnvironment
    };
}();

module.exports = Crowdin;

/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/* global google */
var scriptjs = __webpack_require__(229);
var localize = __webpack_require__(2).localize;
var applyToAllElements = __webpack_require__(1).applyToAllElements;
var createElement = __webpack_require__(1).createElement;
var Client = __webpack_require__(3);

var Geocoder = function () {
    var el_btn_validate = void 0,
        el_error = void 0;
    var validated = false;

    var init = function init(form_id) {
        scriptjs('https://maps.googleapis.com/maps/api/js?key=AIzaSyAEha6-HeZuI95L9JWmX3m6o-AxQr_oFqU&libraries=places', 'gMaps');

        var form = document.getElementById(form_id.split('#')[1]);
        var addr_1 = '#address_line_1';
        var addr_2 = '#address_line_2';
        var city = '#address_city';
        var state = '#address_state';
        var postcode = '#address_postcode';
        var residence = Client.get('residence');

        var getValue = function getValue(id) {
            return document.getElementById(id.split('#')[1]).value || '';
        };
        var getAddress = function getAddress() {
            return getValue(addr_1) + ' ' + getValue(addr_2) + ', ' + getValue(city) + ', ' + getValue(state) + ' ' + getValue(postcode) + ', ' + residence;
        };

        form.querySelector(city).addEventListener('change', function () {
            if (getValue(addr_1).length && getValue(city).length && !validated) {
                validator(getAddress()).then(function () {
                    validated = true;
                });
            }
        });

        el_error = form.querySelector('#geocode_error');
        applyToAllElements(addr_1 + ', ' + addr_2 + ', ' + city + ', ' + postcode, function (element) {
            element.addEventListener('keyup', function () {
                if (!validated && !el_btn_validate) {
                    el_btn_validate = createElement('button', {
                        id: 'geocode_validate',
                        class: 'button-secondary',
                        text: localize('Validate address')
                    });
                    el_btn_validate.addEventListener('click', function (e) {
                        e.preventDefault();
                        validator(getAddress()).then(function () {
                            validated = true;
                        });
                    });
                    el_error.parentNode.appendChild(el_btn_validate);
                }
                if (el_btn_validate) el_btn_validate.setVisibility(1);
                el_error.setVisibility(0);
            });
        }, '', form);

        return {
            address: getAddress()
        };
    };

    var validate = function validate(form_id) {
        var address = init(form_id).address;
        validator(address).then(function () {
            validated = true;
        });
    };

    var validator = function validator(address) {
        return new Promise(function (resolve) {
            scriptjs.ready('gMaps', function () {
                var geocoder = new google.maps.Geocoder();
                geocoder.geocode({
                    address: address
                }, function (result, status) {
                    // Geocoding status reference:
                    // https://developers.google.com/maps/documentation/javascript/geocoding#GeocodingStatusCodes
                    handleResponse(status);
                    resolve(status);
                });
            });
        });
    };

    var handleResponse = function handleResponse(status) {
        if (/ZERO_RESULTS|INVALID_REQUEST/.test(status)) {
            el_error.setVisibility(1);
            if (el_btn_validate) el_btn_validate.setVisibility(0);
        } else {
            el_error.setVisibility(0);
            if (el_btn_validate) el_btn_validate.setVisibility(0);
        }
    };

    return {
        init: init,
        validate: validate
    };
}();

module.exports = Geocoder;

/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (!('includes' in Array.prototype)) {
    Array.prototype.includes = function includes(searchElement /*, fromIndex*/) {
        'use strict';

        var O = Object(this);
        var len = parseInt(O.length) || 0;
        if (len === 0) {
            return false;
        }
        var n = parseInt(arguments[1]) || 0;
        var k;
        if (n >= 0) {
            k = n;
        } else {
            k = len + n;
            if (k < 0) {
                k = 0;
            }
        }
        var currentElement;
        while (k < len) {
            currentElement = O[k];
            if (searchElement === currentElement || searchElement !== searchElement && currentElement !== currentElement) {
                return true;
            }
            k++;
        }
        return false;
    };
}

/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

if (!('includes' in String.prototype)) {
    String.prototype.includes = function (string, index) {
        if ((typeof string === 'undefined' ? 'undefined' : _typeof(string)) === 'object' && string instanceof RegExp) throw new TypeError("First argument to String.prototype.includes must not be a regular expression");
        return this.indexOf(string, index) !== -1;
    };
}

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var MenuSelector = function () {
    var array_sections = void 0,
        go_back = void 0,
        go_next = void 0;

    var init = function init(sections) {
        var show_div = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

        array_sections = sections;
        go_back = document.getElementById('go_back');
        go_next = document.getElementById('go_next');

        var $sidebar_list_item = $('#sidebar-nav li');
        $sidebar_list_item.click(function () {
            $sidebar_list_item.removeClass('selected');
            $(this).addClass('selected');
        });

        $(window).on('hashchange', showSelectedDiv);
        if (show_div) {
            showSelectedDiv();
        }
    };

    var getHash = function getHash() {
        var hash = window.location.hash;
        return hash && $.inArray(hash.substring(1), array_sections) !== -1 ? hash : '#' + array_sections[0];
    };

    var showSelectedDiv = function showSelectedDiv() {
        var $sections_with_hash = $('.sections[id="' + getHash().substring(1) + '"]');
        if ($sections_with_hash.is(':visible') && $('.sections:visible').length === 1) {
            return;
        }
        $('.sections').setVisibility(0);
        $sections_with_hash.setVisibility(1);
        $('#sidebar-nav a[href="' + getHash() + '"]').parent().addClass('selected');

        if (go_back && go_next) {
            initBackNextButtons();
        }
    };

    var initBackNextButtons = function initBackNextButtons() {
        var current_section = getHash().slice(1);
        var current_index = array_sections.indexOf(current_section);
        if (current_index === 0) {
            go_back.classList.add('button-disabled');
        } else {
            go_back.classList.remove('button-disabled');
            go_back.setAttribute('href', '#' + array_sections[current_index - 1]);
        }
        if (current_index === array_sections.length - 1) {
            go_next.classList.add('button-disabled');
        } else {
            go_next.classList.remove('button-disabled');
            go_next.setAttribute('href', '#' + array_sections[current_index + 1]);
        }
    };

    var clean = function clean() {
        $(window).off('hashchange', showSelectedDiv);
    };

    return {
        init: init,
        clean: clean
    };
}();

module.exports = MenuSelector;

/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var moment = __webpack_require__(9);
var DatePicker = __webpack_require__(87);
var dateValueChanged = __webpack_require__(4).dateValueChanged;
var toISOFormat = __webpack_require__(17).toISOFormat;

var generateBirthDate = function generateBirthDate() {
    var date_of_birth = '#date_of_birth';
    DatePicker.init({
        selector: date_of_birth,
        minDate: -100 * 365,
        maxDate: -18 * 365 - 5,
        yearRange: '-100:-18'
    });
    $(date_of_birth).attr('data-value', toISOFormat(moment())).change(function () {
        return dateValueChanged(this, 'date');
    }).val('');
};

module.exports = generateBirthDate;

/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var moment = __webpack_require__(9);
var DatePicker = __webpack_require__(87);
var isJPClient = __webpack_require__(3).isJPClient;
var dateValueChanged = __webpack_require__(4).dateValueChanged;
var localize = __webpack_require__(2).localize;
var toISOFormat = __webpack_require__(17).toISOFormat;

var getDateToFrom = function getDateToFrom() {
    var date_to_val = $('#date_to').attr('data-value');
    var date_to = void 0,
        date_from = void 0;
    if (date_to_val) {
        date_to = moment.utc(date_to_val).unix() + (isJPClient() ? 15 : 24) * (60 * 60);
        date_from = 0;
    }
    return {
        date_to: date_to,
        date_from: date_from
    };
};

var attachDateToPicker = function attachDateToPicker(fncOnChange) {
    var id_date_to = '#date_to';
    var $date_to = $(id_date_to);
    $date_to.attr('data-value', toISOFormat(moment.utc())).change(function () {
        if (!dateValueChanged(this, 'date')) {
            return false;
        }
        $('.table-container').remove();
        if (typeof fncOnChange === 'function') {
            fncOnChange();
        }
        return true;
    });
    DatePicker.init({
        selector: id_date_to,
        maxDate: 0
    });
    if ($date_to.attr('data-picker') !== 'native') $date_to.val(localize('Today'));
};

module.exports = {
    getDateToFrom: getDateToFrom,
    attachDateToPicker: attachDateToPicker
};

/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var createLanguageDropDown = __webpack_require__(261);
var Client = __webpack_require__(3);
var BinarySocket = __webpack_require__(5);
var getElementById = __webpack_require__(4).getElementById;
var Crowdin = __webpack_require__(161);
var Language = __webpack_require__(16);
var State = __webpack_require__(6).State;
var applyToAllElements = __webpack_require__(1).applyToAllElements;

var checkClientsCountry = function checkClientsCountry() {
    if (Crowdin.isInContext()) return;
    BinarySocket.wait('website_status', 'authorize').then(function () {
        var website_status = State.getResponse('website_status');
        if (!website_status) return;
        var clients_country = website_status.clients_country;
        // only limitLanguage for japanese if ip address is from japan and client is logged out or logged in with jp residence
        if (clients_country === 'jp' && (!Client.isLoggedIn() || Client.get('residence') === 'jp')) {
            limitLanguage('JA');
        } else if (clients_country === 'id') {
            limitLanguage('ID');
        } else {
            createLanguageDropDown(website_status);
        }
    });
};

var limitLanguage = function limitLanguage(lang) {
    if (Language.get() !== lang) {
        window.location.href = Language.urlFor(lang); // need to redirect not using pjax
    }
    if (getElementById('select_language')) {
        $('.languages').remove();
        $('#gmt-clock').addClass('gr-6 gr-11-m').removeClass('gr-5 gr-6-m');
        $('#contact-us').addClass('gr-5').removeClass('gr-2');
    }
};

var checkLanguage = function checkLanguage() {
    if (Language.get() === 'ID') {
        var $academy_link = $('.academy a');
        var academy_href = $academy_link.attr('href');
        var regex = /id/;
        if (!regex.test(academy_href)) {
            $academy_link.attr('href', academy_href + regex);
        }
    }
    if (Client.isJPClient()) {
        $('.ja-hide').setVisibility(0);
        applyToAllElements('.ja-show', function (el) {
            if (!/client_logged_(in|out)/.test(el.classList)) {
                el.setVisibility(1);
            }
        });
        if (Client.get('residence') !== 'jp') {
            $('#topMenuCashier').hide();
        }
    }
};

module.exports = {
    checkClientsCountry: checkClientsCountry,
    checkLanguage: checkLanguage
};

/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var onlyNumericOnKeypress = function onlyNumericOnKeypress(ev, optional_value) {
    var key = ev.which;
    var char = String.fromCharCode(key);
    var array_of_char = [0, 8, 37, 39, 46]; // special keypresses (tab, esc), delete, backspace, arrow keys
    if (optional_value && optional_value.length > 0) {
        array_of_char = array_of_char.concat(optional_value);
    }
    if (char === '.' && ev.target.value.indexOf(char) >= 0 || !/[0-9.]/.test(char) && array_of_char.indexOf(key) < 0 || /['%]/.test(char)) {
        // similarity to arrows key code in some browsers
        ev.returnValue = false;
        ev.preventDefault();
    }
};

module.exports = onlyNumericOnKeypress;

/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Client = __webpack_require__(3);
var CookieStorage = __webpack_require__(6).CookieStorage;
var LocalStore = __webpack_require__(6).LocalStore;
var Url = __webpack_require__(8);
var AffiliatePopup = __webpack_require__(184);

/*
 * Handles utm parameters/referrer to use on signup
 *
 * Priorities:
 * 1. Cookie having utm data (utm_source, utm_medium, utm_campaign) [Expires in 3 months]
 * 2. Query string utm parameters
 * 3. document.referrer
 *
 */

var TrafficSource = function () {
    var cookie = void 0;

    var initCookie = function initCookie() {
        if (!cookie) {
            cookie = new CookieStorage('utm_data');
            cookie.read();
            // expiration date is used when writing cookie
            var now = new Date();
            cookie.expires = now.setMonth(now.getMonth() + 3);
        }
    };

    var getData = function getData() {
        initCookie();
        var data = cookie.value;
        Object.keys(data).map(function (key) {
            data[key] = (data[key] || '').replace(/[^a-zA-Z0-9\s-._]/gi, '').substring(0, 100);
        });
        return data;
    };

    // get source in order of precedence
    var getSource = function getSource() {
        var utm_data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getData();
        return utm_data.utm_source || utm_data.referrer || 'direct';
    };

    var setData = function setData() {
        if (Client.isLoggedIn()) {
            clearData();
            return;
        }

        var current_values = getData();
        var params = Url.paramsHash();
        var param_keys = ['utm_source', 'utm_medium', 'utm_campaign'];

        if (params.utm_source) {
            // url params can be stored only if utm_source is available
            param_keys.map(function (key) {
                if (params[key] && !current_values[key]) {
                    cookie.set(key, params[key]);
                }
            });
        }

        // Store gclid
        if (params.gclid && !Client.isLoggedIn()) {
            LocalStore.set('gclid', params.gclid);
            AffiliatePopup.show();
        }

        var doc_ref = document.referrer;
        var referrer = localStorage.getItem('index_referrer') || doc_ref;
        localStorage.removeItem('index_referrer');
        if (doc_ref && !new RegExp(window.location.hostname, 'i').test(doc_ref)) {
            referrer = doc_ref;
        }
        if (referrer && !current_values.referrer && !params.utm_source && !current_values.utm_source) {
            cookie.set('referrer', Url.getLocation(referrer).hostname);
        }
    };

    var clearData = function clearData() {
        initCookie();
        cookie.remove();
    };

    return {
        getData: getData,
        setData: setData,
        clearData: clearData,
        getSource: getSource
    };
}();

module.exports = TrafficSource;

/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var moment = __webpack_require__(9);
var checkInput = __webpack_require__(4).checkInput;
var localize = __webpack_require__(2).localize;
var padLeft = __webpack_require__(17).padLeft;
var clearable = __webpack_require__(1).clearable;

var TimePicker = function () {
    var time_pickers = {};

    var init = function init(options) {
        hide(options.selector, options.datepickerDate);
        time_pickers[options.selector] = {};

        config(options);
        $(window).resize(function () {
            checkWidth(options.selector);
        });
    };

    var hide = function hide(selector, datepickerDate) {
        $(selector).timepicker('destroy').removeAttr('data-picker').off('keydown keyup input');
        if (!datepickerDate) return;
        if (!moment().isBefore(moment(datepickerDate))) {
            $(selector).attr('data-value', '').val('');
        }
    };

    var create = function create(selector) {
        var $this = void 0;
        $(selector).keydown(function (e) {
            if (e.which === 13) {
                $this = $(this);
                e.preventDefault();
                e.stopPropagation();
                $this.timepicker('setTime', $this.val());
                $this.timepicker('hide');
                $this.blur();
                return false;
            }
            return true;
        }).timepicker(time_pickers[selector].config_data);
    };

    var config = function config(options) {
        var time_now = moment.utc(window.time).clone();

        var obj_config = {
            hourText: localize('Hour'),
            minuteText: localize('Minute'),
            amPmText: localize(['AM', 'PM'])
        };

        if (options.minTime) {
            options.minTime = options.minTime === 'now' ? time_now : moment.utc(options.minTime);
            if (options.minTime.isBefore(time_now) && (!options.maxTime || time_now.unix() !== options.maxTime.unix())) {
                options.minTime = time_now;
            }
            if (options.useLocalTime) options.minTime = options.minTime.local();
            obj_config.minTime = { hour: parseInt(options.minTime.hour()), minute: parseInt(options.minTime.minute()) };
        }

        if (options.maxTime) {
            options.maxTime = moment.utc(options.maxTime);
            var minute = parseInt(options.maxTime.minute());
            var hour = parseInt(options.maxTime.hour());

            if (!(hour === 0 && minute === 0) && !(hour === 23 && minute === 55)) {
                hour = minute < 5 ? hour - 1 : hour;
                minute = minute < 5 ? 55 : Math.ceil((minute - 5) / 5) * 5;
            }

            obj_config.maxTime = { hour: hour, minute: minute };
        }

        var $this = void 0;
        obj_config.onSelect = function (time) {
            $this = $(this);
            var this_selector = '#' + $this.attr('id');
            var old_value = $(this_selector).attr('data-value');

            if (old_value && old_value === time) return false;

            var new_time = void 0;
            if (!time.match(/^(:?[0-3]\d):(:?[0-5]\d):(:?[0-5]\d)$/)) {
                time_now = window.time.clone();
                var invalid = time.match(/([a-z0-9]*):([a-z0-9]*):?([a-z0-9]*)?/);
                var _hour = time_now.format('hh');
                var _minute = time_now.format('mm');
                var second = time_now.format('ss');

                if (typeof invalid[1] !== 'undefined' && isFinite(invalid[1])) _hour = formatTime(invalid[1]);
                if (typeof invalid[2] !== 'undefined' && isFinite(invalid[2])) _minute = formatTime(invalid[2]);
                if (typeof invalid[3] !== 'undefined' && isFinite(invalid[3])) second = formatTime(invalid[3]);

                new_time = moment(time_now.format('YYYY-MM-DD') + ' ' + [_hour, _minute, second].join(':')).format('HH:mm');

                if (old_value && old_value === new_time) return false;
                $this.val(new_time);
            }
            $this.attr('data-value', new_time || time);

            if ($this.hasClass('clearable')) {
                clearable($this);
            }

            $(this_selector).trigger('change', [new_time || time]);

            return true;
        };

        time_pickers[options.selector].config_data = obj_config;

        checkWidth(options.selector);
    };

    var formatTime = function formatTime(time) {
        return padLeft(time, 2, '0');
    };

    var toTime = function toTime(time) {
        return [formatTime(time.hour), formatTime(time.minute), '00'].join(':');
    };

    var checkWidth = function checkWidth(selector) {
        var $selector = $(selector);
        var time_picker_conf = time_pickers[selector].config_data;
        if ($(window).width() < 770 && checkInput('time', 'not-a-time') && $selector.attr('data-picker') !== 'native') {
            hide(selector);
            $selector.attr({ type: 'time', 'data-picker': 'native' }).val($selector.attr('data-value')).removeAttr('readonly').removeClass('clear');

            var minTime = time_picker_conf.minTime;
            if (minTime) $selector.attr('min', toTime(minTime));

            var maxTime = time_picker_conf.maxTime;
            if (maxTime) $selector.attr('max', toTime(maxTime));
            return;
        }
        if ($(window).width() > 769 && $selector.attr('data-picker') !== 'jquery' || $(window).width() < 770 && !checkInput('time', 'not-a-time')) {
            $selector.attr({ type: 'text', 'data-picker': 'jquery', readonly: 'readonly' });
            $selector.removeAttr('min max');
            if ($selector.attr('data-value') && $selector.hasClass('clearable') && !$selector.attr('disabled')) {
                clearable($selector);
            }
            create(selector);
        }
    };

    return {
        init: init
    };
}();

module.exports = TimePicker;

/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Client = __webpack_require__(3);
var PortfolioInit = __webpack_require__(128);
var State = __webpack_require__(6).State;

var JapanPortfolio = function () {
    var $portfolio = void 0;

    var is_portfolio_active = false;

    var init = function init() {
        if (Client.isLoggedIn() && isTradePage()) {
            $('#tab_portfolio').setVisibility(1);
        }

        var $container = $('#tab_portfolio-content');
        $portfolio = $portfolio || $('#portfolio');

        if ($portfolio && (!$portfolio.parent().length || $portfolio.parent().get(0).id !== 'tab_portfolio-content')) {
            $portfolio.detach();
            $container.append($portfolio);
        }
    };

    var show = function show() {
        if (isTradePage() && !is_portfolio_active) {
            PortfolioInit.onLoad();
            is_portfolio_active = true;
        }
    };

    var hide = function hide() {
        if (isTradePage() && is_portfolio_active) {
            PortfolioInit.onUnload();
            is_portfolio_active = false;
        }
        $portfolio = undefined;
    };

    var isTradePage = function isTradePage() {
        return State.get('is_mb_trading');
    };

    return {
        init: init,
        show: show,
        hide: hide
    };
}();

module.exports = JapanPortfolio;

/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var MBContract = __webpack_require__(77);
var MBDefaults = __webpack_require__(36);
var MBNotifications = __webpack_require__(97);
var MBPrice = __webpack_require__(122);
var MBSymbols = __webpack_require__(174);
var MBTick = __webpack_require__(123);
var showChart = __webpack_require__(89).showChart;
var commonTrading = __webpack_require__(31);
var BinaryPjax = __webpack_require__(12);
var Client = __webpack_require__(3);
var BinarySocket = __webpack_require__(5);
var isCryptocurrency = __webpack_require__(7).isCryptocurrency;
var getLanguage = __webpack_require__(16).get;
var localize = __webpack_require__(2).localize;
var State = __webpack_require__(6).State;
var urlForStatic = __webpack_require__(8).urlForStatic;
var getPropertyValue = __webpack_require__(1).getPropertyValue;

var MBProcess = function () {
    var market_status = '';

    var symbols_timeout = void 0,
        contract_timeout = void 0;

    var getSymbols = function getSymbols() {
        BinarySocket.wait('website_status').then(function (website_status) {
            var landing_company_obj = State.getResponse('landing_company');
            var allowed_markets = Client.currentLandingCompany().legal_allowed_markets;
            if (Client.isLoggedIn() && allowed_markets && allowed_markets.indexOf('forex') === -1) {
                BinaryPjax.load('trading');
                return;
            }
            var req = {
                active_symbols: 'brief',
                product_type: 'multi_barrier'
            };
            if (landing_company_obj) {
                req.landing_company = landing_company_obj.financial_company ? landing_company_obj.financial_company.shortcode : 'japan';
            } else if (website_status.website_status.clients_country === 'jp' || getLanguage() === 'JA') {
                req.landing_company = 'japan';
            }
            BinarySocket.send(req, { msg_type: 'active_symbols' }).then(function (response) {
                if (!response.active_symbols || !response.active_symbols.length) {
                    $('#main_loading').replaceWith($('<p/>', { class: 'notice-msg center-text container', text: localize('Sorry, this feature is not available in your jurisdiction.') }));
                    return;
                }
                processActiveSymbols(response);
            });
        });
    };

    /*
     * This function processes the active symbols to get markets
     * and underlying list
     */
    var processActiveSymbols = function processActiveSymbols(data) {
        if (getPropertyValue(data, 'error')) {
            MBNotifications.show({ text: data.error.message, uid: 'ACTIVE_SYMBOLS' });
            return;
        }

        // populate the Symbols object
        MBSymbols.details(data);

        var is_show_all = Client.isLoggedIn() && !Client.isJPClient();
        var symbols_list = is_show_all ? MBSymbols.getAllSymbols() : MBSymbols.underlyings().major_pairs;
        var symbol = MBDefaults.get('underlying');

        if (!symbol || !symbols_list[symbol]) {
            symbol = undefined;
            MBDefaults.remove('underlying');
        }

        // check if all symbols are inactive
        var is_market_closed = true;
        Object.keys(symbols_list).forEach(function (s) {
            if (symbols_list[s].is_active) {
                is_market_closed = false;
            }
        });
        clearSymbolTimeout();
        if (is_market_closed) {
            handleMarketClosed();
        } else {
            handleMarketOpen();
            populateUnderlyings(symbol);

            if (symbol && !symbols_list[symbol].is_active) {
                MBNotifications.show({ text: localize('This symbol is not active. Please try another symbol.'), uid: 'SYMBOL_INACTIVE' });
            } else {
                processMarketUnderlying();
            }
        }
    };

    var populateUnderlyings = function populateUnderlyings(selected) {
        var $underlyings = $('#underlying');
        var all_symbols = MBSymbols.getAllSymbols();

        var $list = $underlyings.find('.list');
        $list.empty();
        $underlyings.find('.current').html($('<div/>', { class: 'gr-row' }).append($('<span/>', { class: 'nav-caret ja-hide' })).append($('<img/>', { class: 'gr-3 gr-no-gutter-m' })).append($('<span/>', { class: 'name gr-6 gr-5-m align-self-center' })).append($('<span/>', { class: 'gr-3 gr-4-m align-self-center still', id: 'spot' })));

        var selected_symbol = selected;
        if (Object.keys(all_symbols).indexOf(selected) === -1) selected_symbol = '';
        Object.keys(all_symbols).forEach(function (symbol, idx) {
            if (all_symbols[symbol].is_active) {
                var is_current = !selected_symbol && idx === 0 || symbol === selected_symbol;
                var $current = $('<div/>', { value: symbol, class: 'gr-4 gr-4-t gr-4-m' }).append($('<img/>', { src: urlForStatic('/images/pages/mb_trading/' + symbol.toLowerCase() + '.svg'), alt: '' })).append($('<div/>', { text: all_symbols[symbol].display, class: 'name align-self-center' }));
                $list.append($current);
                if (is_current) {
                    MBContract.setCurrentItem($underlyings, symbol, 1);
                }
            }
        });
    };

    var selectors = '.trade_form, .price-table, #trading_bottom_content, .selection_wrapper, #trade_live_chart';

    var handleMarketClosed = function handleMarketClosed() {
        $(selectors).setVisibility(0);
        hideShowMbTrading('hide');
        MBNotifications.show({ text: localize('Market is closed. Please try again later.'), uid: 'MARKET_CLOSED' });
        symbols_timeout = setTimeout(function () {
            getSymbols();
        }, 30000);
    };

    var handleMarketOpen = function handleMarketOpen() {
        $(selectors).setVisibility(1);
        hideShowMbTrading('show');
        MBNotifications.hide('MARKET_CLOSED');
    };

    var hideShowMbTrading = function hideShowMbTrading(action) {
        var classes = ['gr-5 ', 'gr-12 ']; // the extra space is so gr-5-m is not replaced
        var show = action === 'show';
        var $parent = $('#mb_trading').parent();
        $parent.attr('class', $parent.attr('class').replace(classes[+show], classes[+!show]));
    };

    var clearSymbolTimeout = function clearSymbolTimeout() {
        clearTimeout(symbols_timeout);
    };

    /*
     * Function to call when underlying has changed
     */
    var processMarketUnderlying = function processMarketUnderlying() {
        var underlying = $('#underlying').attr('value');
        MBDefaults.set('underlying', underlying);

        commonTrading.showFormOverlay();

        // forget the old tick id i.e. close the old tick stream
        processForgetTicks().then(function () {
            // get ticks for current underlying
            MBTick.request(underlying);
            MBTick.clean();
        });

        BinarySocket.clearTimeouts();

        getContracts(underlying);
    };

    var getContracts = function getContracts(underlying) {
        var req = {
            contracts_for: underlying || MBDefaults.get('underlying'),
            currency: MBContract.getCurrency(),
            product_type: 'multi_barrier'
        };
        BinarySocket.send(req).then(function (response) {
            MBNotifications.hide('CONNECTION_ERROR');
            MBContract.setContractsResponse(response);
            // contracts_for is triggered every 15 seconds to check for expired barriers
            // but we don't want to send proposal in that case
            // so getContracts will be called without underlying param to distinguish these two cases
            processContract(response, underlying);
        });
        if (contract_timeout) clearContractTimeout();
        contract_timeout = setTimeout(getContracts, 15000);
    };

    var clearContractTimeout = function clearContractTimeout() {
        clearTimeout(contract_timeout);
    };

    /*
     * Function to display contract form for current underlying
     */
    var processContract = function processContract(contracts, should_send_proposal) {
        if (getPropertyValue(contracts, 'error')) {
            MBNotifications.show({ text: contracts.error.message, uid: contracts.error.code });
            // Hide trading form but still display the chart
            $('#period').parents('.selection_wrapper').setVisibility(0);
            $('.price-table, ' + (Client.isLoggedIn() ? '#tab_explanation' : '#trade_analysis')).setVisibility(0);
            showChart();
            return;
        }

        State.set('is_chart_allowed', !(contracts.contracts_for && contracts.contracts_for.feed_license && contracts.contracts_for.feed_license === 'chartonly'));

        checkMarketStatus(contracts.contracts_for.close);

        MBContract.populateOptions(should_send_proposal);
        if (should_send_proposal) {
            processPriceRequest();
        } else {
            processExpiredBarriers();
        }
    };

    var checkMarketStatus = function checkMarketStatus(close) {
        var now = window.time.unix();

        // if market is closed, else if market is open
        if (now > close) {
            if (market_status === 'open') {
                handleMarketClosed();
            }
            market_status = 'closed';
        } else {
            if (market_status === 'closed') {
                getSymbols();
                handleMarketOpen();
            }
            market_status = 'open';
        }
    };

    var processPriceRequest = function processPriceRequest() {
        MBPrice.increaseReqId();
        MBPrice.showPriceOverlay();
        var durations = MBDefaults.get('period').split('_');
        var is_crypto = isCryptocurrency(MBDefaults.get('currency'));
        var payout = parseFloat(MBDefaults.get('payout' + (is_crypto ? '_crypto' : '')));

        var req = {
            proposal_array: 1,
            subscribe: 1,
            basis: 'payout',
            amount: Client.isJPClient() ? (parseInt(payout) || 1) * 1000 : payout,
            currency: MBContract.getCurrency(),
            symbol: MBDefaults.get('underlying'),
            passthrough: { req_id: MBPrice.getReqId() },
            date_expiry: durations[1],
            contract_type: [],
            barriers: [],
            product_type: 'multi_barrier',

            trading_period_start: durations[0]
        };

        var available_contracts = MBContract.getCurrentContracts();
        // contract_type
        available_contracts.forEach(function (c) {
            return req.contract_type.push(c.contract_type);
        });

        // barriers
        var all_expired = true;
        var contract = available_contracts[0];
        contract.available_barriers.forEach(function (barrier) {
            var barrier_item = {};
            if (+contract.barriers === 2) {
                barrier_item.barrier = barrier[1];
                barrier_item.barrier2 = barrier[0];
            } else {
                barrier_item.barrier = barrier;
            }
            if (!barrierHasExpired(contract.expired_barriers, barrier_item.barrier, barrier_item.barrier2)) {
                all_expired = false;
                req.barriers.push(barrier_item);
            }
        });

        processForgetProposals().then(function () {
            // send request
            if (req.barriers.length) {
                MBPrice.addPriceObj(req);
                BinarySocket.send(req, { callback: processProposal });
            }
        });

        // all barriers expired
        if (all_expired) {
            MBNotifications.show({ text: localize('All barriers in this trading window are expired') + '.', uid: 'ALL_EXPIRED' });
            MBPrice.hidePriceOverlay();
        } else {
            MBNotifications.hide('ALL_EXPIRED');
        }
    };

    var processProposal = function processProposal(response) {
        var req_id = MBPrice.getReqId();
        if (response.passthrough.req_id === req_id) {
            if (response.error) {
                var error_message = response.error.error ? response.error.error.message : response.error.message;
                MBNotifications.show({ text: error_message, uid: 'PROPOSAL', dismissible: false });
                return;
            }
            MBNotifications.hide('PROPOSAL');
            MBPrice.display(response);
        }
    };

    var processExpiredBarriers = function processExpiredBarriers() {
        var contracts = MBContract.getCurrentContracts();
        var expired_barrier = void 0,
            $expired_barrier_element = void 0;
        contracts.forEach(function (c) {
            var expired_barriers = c.expired_barriers;
            for (var i = 0; i < expired_barriers.length; i++) {
                if (+c.barriers === 2) {
                    expired_barrier = [expired_barriers[i][0], expired_barriers[i][1]].join('_');
                } else {
                    expired_barrier = expired_barriers[i];
                }
                $expired_barrier_element = $('div [data-barrier="' + expired_barrier + '"]');
                if ($expired_barrier_element.length > 0) {
                    processForgetProposal(expired_barrier);
                    $expired_barrier_element.remove();
                }
            }
        });
    };

    var barrierHasExpired = function barrierHasExpired(expired_barriers, barrier, barrier2) {
        if (barrier2) {
            return containsArray(expired_barriers, [[barrier2, barrier]]);
        }
        return expired_barriers.indexOf(barrier.toString()) > -1;
    };

    var processForgetProposal = function processForgetProposal(expired_barrier) {
        var prices = MBPrice.getPrices();
        Object.keys(prices[expired_barrier]).forEach(function (c) {
            if (!getPropertyValue(prices[expired_barrier][c], 'error')) {
                BinarySocket.send({ forget: prices[expired_barrier][c].proposal.id });
            }
        });
    };

    var processForgetProposals = function processForgetProposals() {
        MBPrice.showPriceOverlay();
        var forget_proposal = BinarySocket.send({ forget_all: 'proposal_array' });
        forget_proposal.then(function () {
            MBPrice.cleanup();
        });
        return forget_proposal;
    };

    var processForgetTicks = function processForgetTicks() {
        return BinarySocket.send({ forget_all: 'ticks' });
    };

    var forgetTradingStreams = function forgetTradingStreams() {
        processForgetProposals();
        processForgetTicks();
    };

    var containsArray = function containsArray(array, val) {
        var hash = {};
        for (var i = 0; i < array.length; i++) {
            hash[array[i]] = i;
        }
        return getPropertyValue(hash, val);
    };

    var onUnload = function onUnload() {
        forgetTradingStreams();
        clearSymbolTimeout();
        clearContractTimeout();
        MBSymbols.clearData();
        MBTick.clean();
    };

    return {
        getSymbols: getSymbols,
        getContracts: getContracts,
        processPriceRequest: processPriceRequest,
        processForgetTicks: processForgetTicks,
        onUnload: onUnload
    };
}();

module.exports = MBProcess;

/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ActiveSymbols = __webpack_require__(119);

/*
 * MBSymbols object parses the active_symbols json that we get from socket.send({active_symbols: 'brief'}
 * and outputs in usable form, it gives markets, underlyings
 *
 *
 * Usage:
 *
 * use `MBSymbols.details` to populate this object first
 *
 * then use
 *
 * `MBSymbols.markets` to get markets like Forex
 * `MBSymbols.underlyings` to get underlyings
 *
 */

var MBSymbols = function () {
    var trade_markets = {};
    var trade_markets_list = {};
    var trade_underlyings = {};
    var all_symbols = {};
    var names = {};

    var details = function details(data) {
        ActiveSymbols.clearData();
        var active_symbols = data.active_symbols;
        trade_markets = ActiveSymbols.getMarkets(active_symbols);
        trade_markets_list = ActiveSymbols.getMarketsList(active_symbols);
        trade_underlyings = ActiveSymbols.getTradeUnderlyings(active_symbols);
        all_symbols = ActiveSymbols.getSymbols(all_symbols);
        names = ActiveSymbols.getSymbolNames(active_symbols);
    };

    return {
        details: details,
        markets: function markets(list) {
            return list ? trade_markets_list : trade_markets;
        },
        getName: function getName(symbol) {
            return names[symbol];
        },
        underlyings: function underlyings() {
            return trade_underlyings;
        },
        getAllSymbols: function getAllSymbols() {
            return all_symbols;
        },
        clearData: function clearData() {
            ActiveSymbols.clearData();
        }
    };
}();

module.exports = MBSymbols;

/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Client = __webpack_require__(3);
var State = __webpack_require__(6).State;

/*
 * get the current active tab if its visible i.e allowed for current parameters
 */
var getActiveTab = function getActiveTab(item) {
    var tab = item || 'currentAnalysisTab';
    var default_tab = 'tab_explanation';
    var selected_tab = sessionStorage.getItem(tab) || (State.get('is_mb_trading') ? 'tab_portfolio' : default_tab);
    var selected_element = document.getElementById(selected_tab);
    if (!selected_element) {
        selected_tab = 'tab_explanation';
        selected_element = document.getElementById(selected_tab);
    }

    if (selected_element && selected_element.classList.contains('invisible') && (item || !(selected_tab === 'tab_portfolio' && !!(Client.isLoggedIn() && State.get('is_mb_trading'))))) {
        selected_tab = default_tab;
        sessionStorage.setItem(tab, selected_tab);
    }

    return selected_tab;
};

module.exports = {
    getActiveTab: getActiveTab
};

/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
 * Notifications manages various notification messages
 *
 */

var Notifications = function () {
    /*
     * options: Object {
     *     text       : {string}  message text to display
     *     uid        : {string}  unique id to prevent duplicating the same message and also used to hide the message
     *     dismissible: {boolean} dismissible messages can be hidden by client
     * }
     */
    var showErrorMessage = function showErrorMessage(options) {
        var $note_wrapper = getContainer();
        var $this_uid = $note_wrapper.find('#' + options.uid);

        if (!options.uid || $this_uid.length === 0) {
            $note_wrapper.prepend(generateMessage(options));
        } else if ($this_uid.html() !== options.text) {
            $this_uid.replaceWith(generateMessage(options));
        }

        $.scrollTo($note_wrapper, 500, { offset: -5 });
    };

    var generateMessage = function generateMessage(options) {
        var $message = $('<div class="notice-msg center-text' + (options.dismissible ? ' dismissible' : '') + '"\n            ' + (options.uid ? ' id="' + options.uid + '"' : '') + '>' + options.text + '\n                ' + (options.dismissible ? '<div class="notification-dismiss">x</div>' : '') + '\n            </div>');

        if (options.dismissible) {
            $message.click(function () {
                dismissMessage(this);
            });
        }

        return $message;
    };

    var hideErrorMessage = function hideErrorMessage(uid) {
        if (uid) {
            getContainer().find('#' + uid).remove();
        }
    };

    var dismissMessage = function dismissMessage(obj) {
        $(obj).remove();
    };

    var getContainer = function getContainer() {
        return $('#notifications_wrapper');
    };

    return {
        show: showErrorMessage,
        hide: hideErrorMessage
    };
}();

module.exports = Notifications;

/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var refreshDropdown = __webpack_require__(25).selectDropdown;
var moment = __webpack_require__(9);
var TradingAnalysis = __webpack_require__(88);
var commonTrading = __webpack_require__(31);
var Contract = __webpack_require__(58);
var Defaults = __webpack_require__(23);
var Durations = __webpack_require__(125);
var GetTicks = __webpack_require__(99);
var Lookback = __webpack_require__(59);
var Notifications = __webpack_require__(176);
var Price = __webpack_require__(100);
var Reset = __webpack_require__(78);
var StartDates = __webpack_require__(289).StartDates;
var Symbols = __webpack_require__(79);
var Tick = __webpack_require__(60);
var BinarySocket = __webpack_require__(5);
var getMinPayout = __webpack_require__(7).getMinPayout;
var isCryptocurrency = __webpack_require__(7).isCryptocurrency;
var elementInnerHtml = __webpack_require__(4).elementInnerHtml;
var getElementById = __webpack_require__(4).getElementById;
var getVisibleElement = __webpack_require__(4).getVisibleElement;
var localize = __webpack_require__(2).localize;
var State = __webpack_require__(6).State;
var getPropertyValue = __webpack_require__(1).getPropertyValue;

var Process = function () {
    /*
     * This function process the active symbols to get markets
     * and underlying list
     */
    var processActiveSymbols = function processActiveSymbols() {
        BinarySocket.send({ active_symbols: 'brief' }).then(function (response) {
            // populate the Symbols object
            Symbols.details(response);

            var market = commonTrading.getDefaultMarket();

            // store the market
            Defaults.set('market', market);

            commonTrading.displayMarkets();
            processMarket();
        });
    };

    /*
     * Function to call when market has changed
     */
    var processMarket = function processMarket() {
        // we can get market from sessionStorage as allowed market
        // is already set when this is called
        var market = Defaults.get('market');
        var symbol = Defaults.get('underlying');

        // change to default market if query string contains an invalid market
        if (!market || !Symbols.underlyings()[market]) {
            market = commonTrading.getDefaultMarket();
            Defaults.set('market', market);
        }
        if (!symbol || !Symbols.underlyings()[market][symbol]) {
            symbol = undefined;
        }

        processMarketUnderlying();
    };

    /*
     * Function to call when underlying has changed
     */
    var processMarketUnderlying = function processMarketUnderlying() {
        var underlying_element = document.getElementById('underlying');
        var underlying = underlying_element.value;

        Defaults.set('underlying', underlying);

        commonTrading.showFormOverlay();

        // get ticks for current underlying
        GetTicks.request(underlying);

        Tick.clean();

        commonTrading.updateWarmChart();

        BinarySocket.clearTimeouts();

        getContracts(underlying);

        commonTrading.displayTooltip();
    };

    var getContracts = function getContracts(underlying) {
        BinarySocket.send({ contracts_for: underlying }).then(function (response) {
            Notifications.hide('CONNECTION_ERROR');
            processContract(response);
        });
    };

    /*
     * Function to display contract form for current underlying
     */
    var processContract = function processContract(contracts) {
        if (getPropertyValue(contracts, ['error', 'code']) === 'InvalidSymbol') {
            Price.processForgetProposals();
            getElementById('contract_confirmation_container').style.display = 'block';
            getElementById('contracts_list').style.display = 'none';
            getElementById('confirmation_message').hide();

            var confirmation_error = getElementById('confirmation_error');
            confirmation_error.show();
            elementInnerHtml(confirmation_error, contracts.error.message + ' <a href="javascript:;" onclick="sessionStorage.removeItem(\'underlying\'); window.location.reload();">' + localize('Please reload the page') + '</a>');
            return;
        }

        State.set('is_chart_allowed', !(contracts.contracts_for && contracts.contracts_for.feed_license && contracts.contracts_for.feed_license === 'chartonly'));

        getElementById('trading_socket_container').classList.add('show');

        var init_logo = getElementById('trading_init_progress');
        if (init_logo && init_logo.style.display !== 'none') {
            init_logo.style.display = 'none';
            Defaults.update();
        }

        Contract.setContracts(contracts);

        var contract_categories = Contract.contractForms();
        var formname = void 0;
        if (Defaults.get('formname') && contract_categories && contract_categories[Defaults.get('formname')]) {
            formname = Defaults.get('formname');
        } else {
            var tree = commonTrading.getContractCategoryTree(contract_categories);
            if (tree[0]) {
                if (_typeof(tree[0]) === 'object') {
                    formname = tree[0][1][0];
                } else {
                    formname = tree[0];
                }
            }
        }

        var available_contracts = getPropertyValue(contracts, ['contracts_for', 'available']);

        commonTrading.displayContractForms('contract_form_name_nav', contract_categories, formname);

        processContractForm(available_contracts, formname);

        TradingAnalysis.request();

        commonTrading.hideFormOverlay();
    };

    var processContractForm = function processContractForm() {
        var available_contracts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : State.getResponse('contracts_for.available');
        var formname_to_set = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : getElementById('contract').value || Defaults.get('formname');

        setFormName(formname_to_set);

        // get updated formname
        Contract.details(Defaults.get('formname'));

        StartDates.display();

        displayPrediction();
        refreshDropdown('#prediction');
        displaySelectedTick();
        refreshDropdown('#selected_tick');
        Lookback.display();

        if (!Reset.isReset(Defaults.get('formname'))) {
            Reset.hideResetTime();
        }

        var r1 = void 0;
        if (State.get('is_start_dates_displayed') && Defaults.get('date_start') && Defaults.get('date_start') !== 'now') {
            r1 = Durations.onStartDateChange(Defaults.get('date_start'));
            if (!r1 || Defaults.get('expiry_type') === 'endtime') Durations.display();
        } else {
            Durations.display();
        }

        // needs to be called after durations are populated
        displayEquals();

        var currency = Defaults.get('currency') || getVisibleElement('currency').value;
        var is_crypto = isCryptocurrency(currency);
        var amount = is_crypto ? 'amount_crypto' : 'amount';
        if (Defaults.get(amount)) {
            $('#amount').val(Defaults.get(amount));
        } else {
            var default_value = getMinPayout(currency);
            Defaults.set(amount, default_value);
            getElementById('amount').value = default_value;
        }
        if (Defaults.get('amount_type')) {
            commonTrading.selectOption(Defaults.get('amount_type'), getElementById('amount_type'));
        } else {
            Defaults.set('amount_type', getElementById('amount_type').value);
        }

        if (Contract.form() === 'callputspread') {
            commonTrading.selectOption('payout', getElementById('amount_type'));
            refreshDropdown('#amount_type');
            // hide stake option
            getElementById('stake_option').setVisibility(0);
            $('[data-value="stake"]').hide();
        } else {
            getElementById('stake_option').setVisibility(1);
            refreshDropdown('#amount_type');
        }

        if (Defaults.get('currency')) {
            commonTrading.selectOption(Defaults.get('currency'), getVisibleElement('currency'));
        }

        var expiry_type = Defaults.get('expiry_type') || 'duration';
        var make_price_request = onExpiryTypeChange(expiry_type);

        if (make_price_request >= 0) {
            Price.processPriceRequest();
        }
    };

    var displayPrediction = function displayPrediction() {
        var prediction_row = getElementById('prediction_row');
        if (Contract.form() === 'digits' && sessionStorage.getItem('formname') !== 'evenodd') {
            prediction_row.show();
            var prediction = getElementById('prediction');
            if (Defaults.get('prediction')) {
                commonTrading.selectOption(Defaults.get('prediction'), prediction);
            } else {
                Defaults.set('prediction', prediction.value);
            }
        } else {
            prediction_row.hide();
            Defaults.remove('prediction');
        }
    };

    var displaySelectedTick = function displaySelectedTick() {
        var selected_tick_row = getElementById('selected_tick_row');
        var highlowticks_expiry_row = getElementById('highlowticks_expiry_row');
        if (sessionStorage.getItem('formname') === 'highlowticks') {
            selected_tick_row.show();
            highlowticks_expiry_row.show();
            var selected_tick = getElementById('selected_tick');
            if (Defaults.get('selected_tick')) {
                commonTrading.selectOption(Defaults.get('selected_tick'), selected_tick);
            } else {
                Defaults.set('selected_tick', selected_tick.value);
            }
        } else {
            selected_tick_row.hide();
            highlowticks_expiry_row.hide();
            Defaults.remove('selected_tick');
        }
    };

    var hasCallPutEqual = function hasCallPutEqual() {
        var contracts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getPropertyValue(Contract.contracts(), ['contracts_for', 'available']) || [];
        return contracts.find(function (contract) {
            return contract.contract_category === 'callputequal';
        });
    };

    var displayEquals = function displayEquals() {
        var formname = Defaults.get('formname');
        var el_equals = document.getElementById('callputequal');
        var durations = getPropertyValue(Contract.durations(), [commonTrading.durationType(Defaults.get('duration_units'))]) || [];
        if (/^(callputequal|risefall)$/.test(formname) && 'callputequal' in durations && hasCallPutEqual()) {
            if (+Defaults.get('is_equal')) {
                el_equals.checked = true;
            }
            el_equals.parentElement.setVisibility(1);
        } else {
            el_equals.parentElement.setVisibility(0);
        }
    };

    var setFormName = function setFormName(formname) {
        var formname_to_set = formname;
        var has_callputequal = hasCallPutEqual();
        if (/^(callputequal)$/.test(formname_to_set) && (!has_callputequal || !+Defaults.get('is_equal'))) {
            formname_to_set = 'risefall';
        } else if (/^(risefall)$/.test(formname_to_set) && has_callputequal && +Defaults.get('is_equal')) {
            formname_to_set = 'callputequal';
        }
        Defaults.set('formname', formname_to_set);
        getElementById('contract').setAttribute('value', formname_to_set);
    };

    var forgetTradingStreams = function forgetTradingStreams() {
        Price.processForgetProposals();
        Price.processForgetProposalOpenContract();
        processForgetTicks();
    };

    /*
     * cancel the current tick stream
     * this need to be invoked before makin
     */
    var processForgetTicks = function processForgetTicks() {
        BinarySocket.send({ forget_all: 'ticks' });
    };

    var onExpiryTypeChange = function onExpiryTypeChange(value) {
        var $expiry_type = $('#expiry_type');
        var validated_value = value && $expiry_type.find('option[value=' + value + ']').length ? value : 'duration';
        $expiry_type.val(validated_value);

        var make_price_request = 0;
        if (validated_value === 'endtime') {
            Durations.displayEndTime();
            if (Defaults.get('expiry_date')) {
                // if time changed, proposal will be sent there if not we should send it here
                make_price_request = Durations.selectEndDate(moment(Defaults.get('expiry_date'))) ? -1 : 1;
            }
            Defaults.remove('duration_units', 'duration_amount');
        } else {
            StartDates.enable();
            Durations.display();
            if (Defaults.get('duration_units')) {
                onDurationUnitChange(Defaults.get('duration_units'));
            }
            var duration_amount = Defaults.get('duration_amount');
            if (duration_amount && duration_amount > $('#duration_minimum').text()) {
                $('#duration_amount').val(duration_amount);
            }
            make_price_request = 1;
            Defaults.remove('expiry_date', 'expiry_time', 'end_date');
            Durations.validateMinDurationAmount();
        }

        return make_price_request;
    };

    var onDurationUnitChange = function onDurationUnitChange(value) {
        var $duration_units = $('#duration_units');
        if (!value || !$duration_units.find('option[value=' + value + ']').length) {
            return 0;
        }

        $duration_units.val(value);
        Defaults.set('duration_units', value);

        Durations.selectUnit(value);
        Durations.populate();

        return 1;
    };

    return {
        processActiveSymbols: processActiveSymbols,
        processMarket: processMarket,
        processContract: processContract,
        processContractForm: processContractForm,
        forgetTradingStreams: forgetTradingStreams,
        onExpiryTypeChange: onExpiryTypeChange,
        onDurationUnitChange: onDurationUnitChange
    };
}();

module.exports = Process;

/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Contract = __webpack_require__(58);
var getLookBackFormula = __webpack_require__(59).getFormula;
var isLookback = __webpack_require__(59).isLookback;
var isCallputspread = __webpack_require__(98).isCallputspread;
var Symbols = __webpack_require__(79);
var Tick = __webpack_require__(60);
var TickDisplay = __webpack_require__(126);
var updateValues = __webpack_require__(127);
var Client = __webpack_require__(3);
var BinarySocket = __webpack_require__(5);
var formatMoney = __webpack_require__(7).formatMoney;
var CommonFunctions = __webpack_require__(4);
var localize = __webpack_require__(2).localize;
var padLeft = __webpack_require__(17).padLeft;
var urlFor = __webpack_require__(8).urlFor;
var createElement = __webpack_require__(1).createElement;
var getPropertyValue = __webpack_require__(1).getPropertyValue;

/*
 * Purchase object that handles all the functions related to
 * contract purchase response
 */

var Purchase = function () {
    var purchase_data = {};
    var tick_config = {};

    var payout_value = void 0,
        cost_value = void 0,
        status = void 0;

    var display = function display(details) {
        purchase_data = details;
        status = '';

        var receipt = details.buy;
        var passthrough = details.echo_req.passthrough;
        var container = CommonFunctions.getElementById('contract_confirmation_container');
        var message_container = CommonFunctions.getElementById('confirmation_message');
        var heading = CommonFunctions.getElementById('contract_purchase_heading');
        var descr = CommonFunctions.getElementById('contract_purchase_descr');
        var barrier_element = CommonFunctions.getElementById('contract_purchase_barrier');
        var reference = CommonFunctions.getElementById('contract_purchase_reference');
        var chart = CommonFunctions.getElementById('trade_tick_chart');
        var payout = CommonFunctions.getElementById('contract_purchase_payout');
        var cost = CommonFunctions.getElementById('contract_purchase_cost');
        var profit = CommonFunctions.getElementById('contract_purchase_profit');
        var spots = CommonFunctions.getElementById('contract_purchase_spots');
        var confirmation_error = CommonFunctions.getElementById('confirmation_error');
        var contracts_list = CommonFunctions.getElementById('contracts_list');
        var button = CommonFunctions.getElementById('contract_purchase_button');

        var error = details.error;
        var has_chart = !/^(digits|highlowticks)$/.test(Contract.form());
        var show_chart = !error && passthrough.duration <= 10 && passthrough.duration_unit === 't';

        contracts_list.style.display = 'none';

        if (error) {
            container.style.display = 'block';
            message_container.hide();
            confirmation_error.show();
            var message = error.message;
            if (/RestrictedCountry/.test(error.code)) {
                var additional_message = '';
                if (/FinancialBinaries/.test(error.code)) {
                    additional_message = localize('Try our [_1]Volatility Indices[_2].', ['<a href="' + urlFor('get-started/volidx-markets') + '" >', '</a>']);
                } else if (/Random/.test(error.code)) {
                    additional_message = localize('Try our other markets.');
                }
                message = error.message + '. ' + additional_message;
            }
            CommonFunctions.elementInnerHtml(confirmation_error, message);
        } else {
            CommonFunctions.getElementById('guideBtn').style.display = 'none';
            container.style.display = 'table-row';
            message_container.show();
            confirmation_error.hide();

            CommonFunctions.elementTextContent(heading, localize('Contract Confirmation'));
            CommonFunctions.elementTextContent(descr, receipt.longcode);
            CommonFunctions.elementTextContent(barrier_element, '');
            CommonFunctions.elementTextContent(reference, localize('Your transaction reference is') + ' ' + receipt.transaction_id);

            var currency = Client.get('currency');
            var formula = void 0,
                multiplier = void 0;
            var contract_type = passthrough.contract_type;

            if (isLookback(contract_type)) {
                multiplier = formatMoney(currency, passthrough.amount, false, 3, 2);
                formula = getLookBackFormula(contract_type, multiplier);
            }

            payout_value = +receipt.payout;
            cost_value = receipt.buy_price;

            var profit_value = payout_value ? formatMoney(currency, payout_value - cost_value) : undefined;

            CommonFunctions.elementInnerHtml(cost, localize('Total Cost') + ' <p>' + formatMoney(currency, cost_value) + '</p>');
            if (isLookback(contract_type)) {
                CommonFunctions.elementInnerHtml(payout, localize('Potential Payout') + ' <p>' + formula + '</p>');
                profit.setVisibility(0);
            } else if (isCallputspread(contract_type)) {
                profit.setVisibility(1);
                CommonFunctions.elementInnerHtml(payout, localize('Maximum Payout') + ' <p>' + formatMoney(currency, payout_value) + '</p>');
                CommonFunctions.elementInnerHtml(profit, localize('Maximum Profit') + ' <p>' + profit_value + '</p>');
            } else {
                profit.setVisibility(1);
                CommonFunctions.elementInnerHtml(payout, localize('Potential Payout') + ' <p>' + formatMoney(currency, payout_value) + '</p>');
                CommonFunctions.elementInnerHtml(profit, localize('Potential Profit') + ' <p>' + profit_value + '</p>');
            }

            updateValues.updateContractBalance(receipt.balance_after);

            if (show_chart && has_chart) {
                chart.show();
            } else {
                chart.hide();
            }

            CommonFunctions.elementTextContent(CommonFunctions.getElementById('contract_highlowtick'), '');
            if (has_chart) {
                spots.hide();
            } else {
                CommonFunctions.elementTextContent(spots, '');
                spots.className = '';
                spots.show();

                var arr_shortcode = purchase_data.buy.shortcode.split('_');
                tick_config = {
                    is_tick_high: /^tickhigh$/i.test(contract_type),
                    is_tick_low: /^ticklow$/i.test(contract_type),
                    selected_tick_number: arr_shortcode[arr_shortcode.length - 1],
                    winning_tick_quote: '',
                    winning_tick_number: ''
                };
            }

            if (has_chart && !show_chart) {
                CommonFunctions.elementTextContent(button, localize('View'));
                button.setAttribute('contract_id', receipt.contract_id);
                button.show();
                $('#confirmation_message_container .open_contract_details').attr('contract_id', receipt.contract_id).setVisibility(1);
            } else {
                button.hide();
                $('#confirmation_message_container .open_contract_details').setVisibility(0);
            }
        }

        if (show_chart && has_chart) {
            // calculate number of decimals needed to display tick-chart according to the spot
            // value of the underlying
            var decimal_points = 2;
            var tick_spots = Tick.spots();
            var tick_spot_epochs = Object.keys(tick_spots);
            if (tick_spot_epochs.length > 0) {
                var last_quote = tick_spots[tick_spot_epochs[0]].toString();

                if (last_quote.indexOf('.') !== -1) {
                    decimal_points = last_quote.split('.')[1].length;
                }
            }

            var category = sessionStorage.getItem('formname');
            if (/^(risefall|higherlower)$/.test(category)) {
                category = 'callput';
            }

            TickDisplay.init({
                symbol: passthrough.symbol,
                barrier: /^(higherlower|touchnotouch)$/.test(sessionStorage.getItem('formname')) ? passthrough.barrier : undefined,
                number_of_ticks: passthrough.duration,
                previous_tick_epoch: receipt.start_time,
                contract_category: category,
                display_symbol: Symbols.getName(passthrough.symbol),
                contract_start: receipt.start_time,
                display_decimals: decimal_points,
                price: passthrough['ask-price'],
                payout: receipt.payout,
                show_contract_result: 1,
                width: $('#confirmation_message').width(),
                id_render: 'trade_tick_chart'
            });
            TickDisplay.resetSpots();
        }

        if (show_chart) {
            var request = {
                proposal_open_contract: 1,
                contract_id: receipt.contract_id,
                subscribe: 1
            };
            BinarySocket.send(request, { callback: function callback(response) {
                    var contract = response.proposal_open_contract;
                    if (contract) {
                        status = contract.status;
                        TickDisplay.setStatus(contract);
                        if (contract.sell_spot_time && +contract.sell_spot_time < contract.date_expiry) {
                            TickDisplay.updateChart({ is_sold: true }, contract);
                        }
                        // force to sell the expired contract, in order to get the final status
                        if (+contract.is_settleable === 1 && !contract.is_sold) {
                            BinarySocket.send({ sell_expired: 1 });
                        }
                    }
                } });
        }
    };

    var makeBold = function makeBold(d) {
        return '<strong>' + d + '</strong>';
    };

    var updateSpotList = function updateSpotList() {
        var $spots = $('#contract_purchase_spots');
        if (!$spots.length || $spots.is(':hidden')) {
            return;
        }

        var spots = CommonFunctions.getElementById('contract_purchase_spots');
        if (status && status !== 'open') {
            if (!new RegExp(status).test(spots.classList)) {
                spots.className = status;
                if (status === 'won') {
                    updateValues.updatePurchaseStatus(payout_value, cost_value, localize('This contract won'));
                } else if (status === 'lost') {
                    updateValues.updatePurchaseStatus(0, -cost_value, localize('This contract lost'));
                }
                if (tick_config.is_tick_high || tick_config.is_tick_low) {
                    var is_won = +tick_config.selected_tick_number === +tick_config.winning_tick_number;
                    CommonFunctions.elementTextContent(CommonFunctions.getElementById('contract_highlowtick'), localize('Tick [_1] is ' + (is_won ? '' : 'not') + ' the ' + (tick_config.is_tick_high ? 'highest' : 'lowest') + ' tick', [tick_config.selected_tick_number]));
                }
            }
        }

        var duration = +getPropertyValue(purchase_data, ['echo_req', 'passthrough', 'duration']);
        if (!duration) {
            return;
        }

        var spots2 = Tick.spots();
        var epoches = Object.keys(spots2).sort(function (a, b) {
            return a - b;
        });
        CommonFunctions.elementTextContent(spots, '');

        for (var s = 0; s < epoches.length; s++) {
            var tick_d = {
                epoch: epoches[s],
                quote: spots2[epoches[s]]
            };

            if (CommonFunctions.isVisible(spots) && tick_d.epoch && tick_d.epoch > purchase_data.buy.start_time) {
                var current_tick_count = spots.getElementsByClassName('row').length + 1;

                var is_winning_tick = false;
                if (tick_config.is_tick_high || tick_config.is_tick_low) {
                    var $winning_row = $spots.find('.winning-tick-row');
                    if (!tick_config.winning_tick_quote || tick_config.winning_tick_quote === tick_d.quote && !$winning_row.length || tick_config.is_tick_high && +tick_d.quote > tick_config.winning_tick_quote || tick_config.is_tick_low && +tick_d.quote < tick_config.winning_tick_quote) {
                        is_winning_tick = true;
                        tick_config.winning_tick_quote = tick_d.quote;
                        tick_config.winning_tick_number = current_tick_count;
                        $winning_row.removeClass('winning-tick-row');
                    }
                }

                var fragment = createElement('div', { class: 'row' + (is_winning_tick ? ' winning-tick-row' : '') });

                var el1 = createElement('div', { class: 'col', text: localize('Tick') + ' ' + current_tick_count });
                fragment.appendChild(el1);

                var el2 = createElement('div', { class: 'col' });
                var date = new Date(tick_d.epoch * 1000);
                var hours = padLeft(date.getUTCHours(), 2, '0');
                var minutes = padLeft(date.getUTCMinutes(), 2, '0');
                var seconds = padLeft(date.getUTCSeconds(), 2, '0');
                CommonFunctions.elementTextContent(el2, [hours, minutes, seconds].join(':'));
                fragment.appendChild(el2);

                var tick = tick_config.is_tick_high || tick_config.is_tick_low ? tick_d.quote : tick_d.quote.replace(/\d$/, makeBold);
                var el3 = createElement('div', { class: 'col' });
                CommonFunctions.elementInnerHtml(el3, tick);
                fragment.appendChild(el3);

                spots.appendChild(fragment);
                spots.scrollTop = spots.scrollHeight;

                duration--;

                if (tick_config.is_tick_high || tick_config.is_tick_low) {
                    var lost_on_selected_tick = !is_winning_tick && current_tick_count === +tick_config.selected_tick_number;
                    var lost_after_selected_tick = is_winning_tick && current_tick_count > +tick_config.selected_tick_number;
                    if (lost_on_selected_tick || lost_after_selected_tick) {
                        duration = 0; // no need to keep drawing ticks
                    }
                }

                if (!duration) {
                    purchase_data.echo_req.passthrough.duration = 0;
                }
            }
        }
    };

    return {
        display: display,
        updateSpotList: updateSpotList
    };
}();

module.exports = Purchase;

/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BinaryPjax = __webpack_require__(12);
var BinarySocket = __webpack_require__(5);
var FormManager = __webpack_require__(18);
var localize = __webpack_require__(2).localize;

var CashierPassword = function () {
    var form_id = '#frm_cashier_password';

    var should_redirect = false;

    var $form = void 0;

    var onLoad = function onLoad() {
        $form = $(form_id);

        BinarySocket.wait('authorize').then(function () {
            BinarySocket.send({ cashier_password: 1 }).then(function (response) {
                return init(response);
            });
        });
    };

    var updatePage = function updatePage(config) {
        $('legend').text(localize(config.legend));
        $('#lockInfo').text(localize(config.info));
        $form.find('button').html(localize(config.button));
    };

    var init = function init(response) {
        var locked = response.cashier_password;
        if (response.error) {
            $('#form_message').addClass('notice-msg center-text').text(response.error.code === 'RateLimit' ? localize('You have reached the rate limit of requests per second. Please try later.') : response.error.message);
            return;
        } else if (locked) {
            updatePage({
                legend: 'Unlock Cashier',
                info: 'Your cashier is locked as per your request - to unlock it, please enter the password.',
                button: 'Unlock Cashier'
            });
            $('#repeat_password_row').setVisibility(0);
        } else {
            updatePage({
                legend: 'Lock Cashier',
                info: 'An additional password can be used to restrict access to the cashier.',
                button: 'Update'
            });
            $('#repeat_password_row').setVisibility(1);
        }
        $form.setVisibility(1);
        FormManager.init(form_id, [{ selector: '#cashier_password', validations: ['req', locked ? ['length', { min: 6, max: 25 }] : 'password'], request_field: locked ? 'unlock_password' : 'lock_password', re_check_field: locked ? null : '#repeat_cashier_password' }, { selector: '#repeat_cashier_password', validations: ['req', ['compare', { to: '#cashier_password' }]], exclude_request: 1 }, { request_field: 'cashier_password', value: 1 }]);
        FormManager.handleSubmit({
            form_selector: form_id,
            fnc_response_handler: handleResponse
        });
    };

    var handleResponse = function handleResponse(response) {
        var $form_error = $('#form_error');
        var $form_message = $('#form_message');
        $form_message.removeClass('notice-msg center-text').text('');
        $form_error.setVisibility(0);
        if (response.error) {
            if (response.error.code === 'RateLimit') {
                $form.setVisibility(0);
                $form_message.addClass('notice-msg center-text').text(localize('You have reached the rate limit of requests per second. Please try later.'));
            } else {
                var message = response.error.message;
                if (response.error.code === 'InputValidationFailed') {
                    message = 'Sorry, you have entered an incorrect cashier password';
                }
                $form_error.text(localize(message)).setVisibility(1);
            }
        } else {
            $form.setVisibility(0);
            $form_message.text(localize('Your settings have been updated successfully.'));
            setTimeout(redirect, 2000);
        }
    };

    var redirect = function redirect() {
        if (should_redirect) {
            should_redirect = false;
            BinaryPjax.loadPreviousUrl();
        }
    };

    return {
        onLoad: onLoad,

        setShouldRedirect: function setShouldRedirect(bool) {
            should_redirect = bool;
        }
    };
}();

module.exports = CashierPassword;

/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var SelectMatcher = __webpack_require__(25).select2Matcher;
var moment = __webpack_require__(9);
var BinaryPjax = __webpack_require__(12);
var Client = __webpack_require__(3);
var Header = __webpack_require__(27);
var BinarySocket = __webpack_require__(5);
var formatMoney = __webpack_require__(7).formatMoney;
var FormManager = __webpack_require__(18);
var Geocoder = __webpack_require__(162);
var CommonFunctions = __webpack_require__(4);
var localize = __webpack_require__(2).localize;
var State = __webpack_require__(6).State;
var getPropertyValue = __webpack_require__(1).getPropertyValue;

var PersonalDetails = function () {
    var form_id = '#frmPersonalDetails';
    var real_acc_elements = '.RealAcc';

    var is_for_new_account = false;

    var editable_fields = void 0,
        is_jp_client = void 0,
        is_virtual = void 0,
        residence = void 0,
        get_settings_data = void 0,
        currency = void 0;

    var init = function init() {
        editable_fields = {};
        get_settings_data = {};
        is_virtual = Client.get('is_virtual');
        residence = Client.get('residence');
        is_jp_client = residence === 'jp'; // we need to check with residence so we know which fields will be present in get_settings response
        if (is_jp_client && !is_virtual) {
            showHideTaxMessage();
        }
    };

    var showHideTaxMessage = function showHideTaxMessage() {
        var $tax_info_declaration = $('#tax_information_declaration');
        var $tax_information_info = $('#tax_information_info');

        if (Client.shouldCompleteTax()) {
            $('#tax_information_note_toggle').off('click').on('click', function (e) {
                e.stopPropagation();
                $('#tax_information_note_toggle').toggleClass('open');
                $('#tax_information_note').slideToggle();
            });
        } else {
            $tax_information_info.setVisibility(0); // hide tax info
            $tax_info_declaration.setVisibility(0); // hide tax info declaration
        }
    };

    var showHideLabel = function showHideLabel(get_settings) {
        if (!is_jp_client) {
            ['place_of_birth', 'account_opening_reason'].forEach(function (id) {
                if (Object.prototype.hasOwnProperty.call(get_settings, id)) {
                    if (get_settings[id]) {
                        // we have to show text here instead of relying on displayGetSettingsData()
                        // since it prioritizes showing data instead of label
                        var $label = $('#lbl_' + id);
                        $label.text(get_settings[id]);
                        $('#row_' + id).setVisibility(0);
                        $('#row_lbl_' + id).setVisibility(1);
                    } else {
                        $('#row_lbl_' + id).setVisibility(0);
                        $('#row_' + id).setVisibility(1);
                    }
                }
            });
        }
    };

    var showHideMissingDetails = function showHideMissingDetails() {
        var validations = getValidations();
        var has_missing_field = validations.find(function (validation) {
            return (/req/.test(validation.validations) && $(validation.selector).val() === ''
            );
        });
        $('#missing_details_notice').setVisibility(!!has_missing_field);
    };

    var getDetailsResponse = function getDetailsResponse(data) {
        var residence_list = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : State.getResponse('residence_list');

        var get_settings = $.extend({}, data);
        get_settings.date_of_birth = 'date_of_birth' in get_settings ? moment.utc(new Date(get_settings.date_of_birth * 1000)).format('YYYY-MM-DD') : '';
        var accounts = Client.getAllLoginids();
        // for subaccounts, back-end sends loginid of the master account as name
        var hide_name = accounts.some(function (loginid) {
            return new RegExp(loginid, 'i').test(get_settings.first_name);
        }) || is_virtual;
        if (!hide_name) {
            get_settings.name = is_jp_client ? get_settings.last_name : (get_settings.salutation || '') + ' ' + (get_settings.first_name || '') + ' ' + (get_settings.last_name || '');
        }

        if (get_settings.place_of_birth) {
            get_settings.place_of_birth = (residence_list.find(function (obj) {
                return obj.value === get_settings.place_of_birth;
            }) || {}).text || get_settings.place_of_birth;
        }

        showHideLabel(get_settings);

        displayGetSettingsData(get_settings);

        if (is_virtual) {
            $(real_acc_elements).remove();
        } else if (is_jp_client) {
            var jp_settings = get_settings.jp_settings;
            switch (jp_settings.gender) {
                case 'f':
                    jp_settings.gender = localize('Female');
                    break;
                case 'm':
                    jp_settings.gender = localize('Male');
                    break;
                default:
                    break;
            }
            displayGetSettingsData(jp_settings);
            if (jp_settings.hedge_asset !== null && jp_settings.hedge_asset_amount !== null) {
                $('.hedge').setVisibility(1);
            }
            $('.JpAcc').setVisibility(1);
        } else {
            $(real_acc_elements).setVisibility(1);
            showHideTaxMessage();
        }
        $(form_id).setVisibility(1);
        $('#loading').remove();
        FormManager.init(form_id, getValidations());
        FormManager.handleSubmit({
            form_selector: form_id,
            obj_request: { set_settings: 1 },
            fnc_response_handler: setDetailsResponse,
            fnc_additional_check: additionalCheck,
            enable_button: true
        });
        if (!is_virtual && !is_jp_client) {
            Geocoder.validate(form_id);
        }
        showHideMissingDetails();
    };

    var displayGetSettingsData = function displayGetSettingsData(data) {
        var populate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

        var el_key = void 0,
            el_lbl_key = void 0,
            data_key = void 0;
        Object.keys(data).forEach(function (key) {
            el_key = document.getElementById(key);
            el_lbl_key = document.getElementById('lbl_' + key);
            // prioritise labels for japan account
            el_key = is_jp_client ? el_lbl_key || el_key : el_key || el_lbl_key;
            if (el_key) {
                data_key = /format_money/.test(el_key.className) && data[key] !== null ? formatMoney(currency, data[key]) : data[key] || '';
                editable_fields[key] = data_key;
                if (populate) {
                    if (el_key.type === 'checkbox') {
                        el_key.checked = !!data_key;
                    } else if (/select|text/i.test(el_key.type)) {
                        $(el_key).val(data_key.split(',')).trigger('change');
                    } else if (key !== 'country') {
                        CommonFunctions.elementInnerHtml(el_key, data_key ? localize(data_key) : '-');
                    }
                }
            }
        });
        if (data.country) {
            $('#residence').replaceWith($('<label/>').append($('<strong/>', { id: 'lbl_country' })));
            $('#lbl_country').text(data.country);
        }
    };

    var additionalCheck = function additionalCheck(data) {
        if (!isChanged(data) && (!data.jp_settings || !isChanged(data.jp_settings))) {
            showFormMessage('You did not change anything.', false);
            return false;
        }
        return true;
    };

    var isChanged = function isChanged(data) {
        var compare_data = $.extend({}, data);
        return Object.keys(compare_data).some(function (key) {
            return key !== 'set_settings' && key !== 'jp_settings' && editable_fields[key] !== compare_data[key];
        });
    };

    var getValidations = function getValidations() {
        var validations = void 0;
        var data = get_settings_data;
        if (is_jp_client) {
            validations = [{ request_field: 'address_line_1', value: data.address_line_1 }, { request_field: 'address_line_2', value: data.address_line_2 }, { request_field: 'address_city', value: data.address_city }, { request_field: 'address_state', value: data.address_state }, { request_field: 'address_postcode', value: data.address_postcode }, { request_field: 'phone', value: data.phone }, { selector: '#email_consent' }, { selector: '#hedge_asset_amount', validations: ['req', 'number'], parent_node: 'jp_settings' }, { selector: '#hedge_asset', validations: ['req'], parent_node: 'jp_settings' }, { selector: '#motivation_circumstances', validations: ['req'], parent_node: 'jp_settings' }, { selector: '#account_opening_reason', validations: ['req'] }];
            $(form_id).find('select').each(function () {
                validations.push({ selector: '#' + $(this).attr('id'), validations: ['req'], parent_node: 'jp_settings' });
            });
        } else if (is_virtual) {
            validations = [{ selector: '#email_consent' }, { selector: '#residence', validations: ['req'] }];
        } else {
            validations = [{ selector: '#address_line_1', validations: ['req', 'address'] }, { selector: '#address_line_2', validations: ['address'] }, { selector: '#address_city', validations: ['req', 'letter_symbol'] }, { selector: '#address_state', validations: $('#address_state').prop('nodeName') === 'SELECT' ? '' : ['letter_symbol'] }, { selector: '#address_postcode', validations: [Client.get('residence') === 'gb' ? 'req' : '', 'postcode', ['length', { min: 0, max: 20 }]] }, { selector: '#email_consent' }, { selector: '#phone', validations: ['req', 'phone', ['length', { min: 6, max: 35, value: function value() {
                        return $('#phone').val().replace(/^\+/, '');
                    } }]] }, { selector: '#place_of_birth', validations: ['req'] }, { selector: '#account_opening_reason', validations: ['req'] }, { selector: '#tax_residence', validations: Client.isAccountOfType('financial') ? ['req'] : '' }, { selector: '#chk_tax_id', validations: Client.isAccountOfType('financial') ? [['req', { hide_asterisk: true, message: localize('Please confirm that all the information above is true and complete.') }]] : '', exclude_request: 1 }];
            var tax_id_validation = { selector: '#tax_identification_number', validations: ['tax_id', ['length', { min: 0, max: 20 }]] };
            if (Client.isAccountOfType('financial')) {
                tax_id_validation.validations[1][1].min = 1;
                tax_id_validation.validations.unshift('req');
            }
            validations.push(tax_id_validation);
        }
        return validations;
    };

    var setDetailsResponse = function setDetailsResponse(response) {
        // allow user to resubmit the form on error.
        var is_error = response.set_settings !== 1;
        if (!is_error) {
            // to update tax information message for financial clients
            BinarySocket.send({ get_account_status: 1 }, { forced: true }).then(function () {
                showHideTaxMessage();
                Header.displayAccountStatus();
            });
            // to update the State with latest get_settings data
            BinarySocket.send({ get_settings: 1 }, { forced: true }).then(function (data) {
                if (is_virtual && response.echo_req.residence) {
                    window.location.reload(); // reload page if we are setting residence
                    return;
                }
                // update notification shown for set residence etc
                Header.displayAccountStatus();
                if (is_for_new_account) {
                    is_for_new_account = false;
                    BinaryPjax.loadPreviousUrl();
                    return;
                }
                getDetailsResponse(data.get_settings);
            });
        }
        showFormMessage(is_error ? getPropertyValue(response, ['error', 'message']) || 'Sorry, an error occurred while processing your account.' : 'Your settings have been updated successfully.', !is_error);
    };

    var showFormMessage = function showFormMessage(msg, is_success) {
        $('#formMessage').attr('class', is_success ? 'success-msg' : 'errorfield').html(is_success ? $('<ul/>', { class: 'checked' }).append($('<li/>', { text: localize(msg) })) : localize(msg)).css('display', 'block').delay(5000).fadeOut(1000);
    };

    var populateResidence = function populateResidence(response) {
        return new Promise(function (resolve) {
            var residence_list = response.residence_list;
            if (residence_list.length > 0) {
                var $options = $('<div/>');
                var $options_with_disabled = $('<div/>');
                residence_list.forEach(function (res) {
                    $options.append(CommonFunctions.makeOption({ text: res.text, value: res.value }));
                    $options_with_disabled.append(CommonFunctions.makeOption({
                        text: res.text,
                        value: res.value,
                        is_disabled: res.disabled
                    }));
                });

                if (residence) {
                    var $tax_residence = $('#tax_residence');
                    $tax_residence.html($options_with_disabled.html()).promise().done(function () {
                        setTimeout(function () {
                            $tax_residence.select2().val(get_settings_data.tax_residence ? get_settings_data.tax_residence.split(',') : '').trigger('change').setVisibility(1);
                        }, 500);
                    });

                    if (!get_settings_data.place_of_birth) {
                        $options.prepend($('<option/>', { value: '', text: localize('Please select') }));
                        $('#place_of_birth').html($options.html()).val(residence);
                    }
                } else {
                    $('#lbl_country').parent().replaceWith($('<select/>', { id: 'residence', single: 'single' }));
                    var $residence = $('#residence');
                    $options_with_disabled.prepend($('<option/>', { text: localize('Please select a country'), value: '' }));
                    $residence.html($options_with_disabled.html());
                    $residence.select2({
                        matcher: function matcher(params, data) {
                            return SelectMatcher(params, data);
                        }
                    });
                }
            }
            resolve();
        });
    };

    var populateStates = function populateStates(response) {
        return new Promise(function (resolve) {
            var states = response.states_list;

            if (is_jp_client) {
                var state_text = (states.filter(function (state) {
                    return state.value === get_settings_data.address_state;
                })[0] || {}).text;
                $('#lbl_address_state').text(state_text || get_settings_data.address_state);
            } else {
                var address_state = '#address_state';
                var $field = $(address_state);

                $field.empty();

                if (states && states.length > 0) {
                    $field.append($('<option/>', { value: '', text: localize('Please select') }));
                    states.forEach(function (state) {
                        $field.append($('<option/>', { value: state.value, text: state.text }));
                    });
                } else {
                    $field.replaceWith($('<input/>', { id: address_state.replace('#', ''), name: 'address_state', type: 'text', maxlength: '35', 'data-lpignore': true }));
                    $field = $(address_state);
                }
                $field.val(get_settings_data.address_state);

                if (states && states.length > 0) {
                    $('#address_state').select2({
                        matcher: function matcher(params, data) {
                            return SelectMatcher(params, data);
                        }
                    });
                }
            }

            if (is_jp_client && !is_virtual) {
                // detect hedging needs to be called after FormManager.init
                // or all previously bound event listeners on form elements will be removed
                CommonFunctions.detectHedging($('#trading_purpose'), $('.hedge'));
            }
            resolve();
        });
    };

    var onLoad = function onLoad() {
        currency = Client.get('currency');
        BinarySocket.wait('get_account_status', 'get_settings').then(function () {
            init();
            get_settings_data = State.getResponse('get_settings');

            if (is_virtual) {
                getDetailsResponse(get_settings_data);
            }

            if (!is_virtual || !residence) {
                BinarySocket.send({ residence_list: 1 }).then(function (response) {
                    populateResidence(response).then(function () {
                        if (residence) {
                            BinarySocket.send({ states_list: residence }).then(function (response_state) {
                                populateStates(response_state).then(function () {
                                    getDetailsResponse(get_settings_data, response.residence_list);
                                });
                            });
                        } else {
                            getDetailsResponse(get_settings_data, response.residence_list);
                        }
                        $('#place_of_birth').select2({
                            matcher: function matcher(params, data) {
                                return SelectMatcher(params, data);
                            }
                        });
                    });
                });
            }
        });
    };

    var onUnload = function onUnload() {
        is_for_new_account = false;
    };

    return {
        onLoad: onLoad,
        onUnload: onUnload,

        setIsForNewAccount: function setIsForNewAccount(bool) {
            is_for_new_account = bool;
        }
    };
}();

module.exports = PersonalDetails;

/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BinaryPjax = __webpack_require__(12);
var Client = __webpack_require__(3);
var BinarySocket = __webpack_require__(5);
var localize = __webpack_require__(2).localize;
var State = __webpack_require__(6).State;

var professionalClient = function () {
    var is_in_page = false;

    var onLoad = function onLoad() {
        BinarySocket.wait('get_account_status', 'landing_company').then(function () {
            init(Client.isAccountOfType('financial'), true);
        });
    };

    var init = function init(is_financial, is_page) {
        is_in_page = !!is_page;
        BinarySocket.wait('landing_company').then(function () {
            populateProfessionalClient(is_financial);
        });
    };

    var populateProfessionalClient = function populateProfessionalClient(is_financial) {
        var has_maltainvest = State.getResponse('landing_company.financial_company.shortcode') === 'maltainvest';
        if (!has_maltainvest || !is_financial) {
            // then it's not upgrading to financial
            if (is_in_page) {
                BinaryPjax.loadPreviousUrl();
            }
            return;
        }

        var status = State.getResponse('get_account_status.status') || [];
        if (is_in_page && /professional/.test(status)) {
            $('#loading').remove();
            $('#frm_professional').setVisibility(0);
            $('#' + (/professional_requested/.test(status) ? 'processing' : 'professional')).setVisibility(1);
            return;
        }

        var $container = $('#fs_professional');
        var $chk_professional = $container.find('#chk_professional');
        var $info = $container.find('#professional_info');
        var $popup_contents = $container.find('#popup');
        var $error = $('#form_message');
        var popup_selector = '#professional_popup';

        $container.find('#professional_info_toggle').off('click').on('click', function () {
            $(this).toggleClass('open');
            $info.slideToggle();
            $('#' + (Client.get('residence') === 'gb' ? '' : 'non_') + 'uk').toggleClass('invisible');
        });

        $chk_professional.on('change', function () {
            if ($chk_professional.is(':checked')) {
                $error.text('').setVisibility(0);

                if (!$(popup_selector).length) {
                    $('body').append($('<div/>', { id: 'professional_popup', class: 'lightbox' }).append($popup_contents.clone().setVisibility(1)));

                    var $popup = $(popup_selector);
                    $popup.find('#btn_accept, #btn_decline').off('click').on('click dblclick', function () {
                        if ($(this).attr('data-value') === 'decline') {
                            $chk_professional.prop('checked', false);
                        }
                        $popup.remove();
                    });
                }
            }
        });

        $container.setVisibility(1);

        if (is_in_page) {
            $('#loading').remove();
            $('#frm_professional').off('submit').on('submit', function (e) {
                e.preventDefault();
                if ($chk_professional.is(':checked')) {
                    BinarySocket.wait('get_settings').then(function (res) {
                        BinarySocket.send(populateReq(res.get_settings)).then(function (response) {
                            if (response.error) {
                                $error.text(response.error.message).setVisibility(1);
                            } else {
                                BinarySocket.send({ get_account_status: 1 }).then(function () {
                                    populateProfessionalClient(true);
                                });
                            }
                        });
                    });
                } else {
                    $error.text(localize('This field is required.')).setVisibility(1);
                }
            }).setVisibility(1);
        }

        $(document).on('keydown click', function (e) {
            var $popup = $(popup_selector);
            if ((e.which === 27 || $(e.target).hasClass('lightbox')) && $popup.length) {
                $popup.remove();
                $chk_professional.prop('checked', false);
            }
        });
    };

    var populateReq = function populateReq(get_settings) {
        var req = {
            set_settings: 1,
            request_professional_status: 1
        };

        if (get_settings.tax_identification_number) {
            req.tax_identification_number = get_settings.tax_identification_number;
        }
        if (get_settings.tax_residence) {
            req.tax_residence = get_settings.tax_residence;
        }

        return req;
    };

    return {
        onLoad: onLoad,
        init: init
    };
}();

module.exports = professionalClient;

/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BinaryPjax = __webpack_require__(12);
var Client = __webpack_require__(3);
var BinarySocket = __webpack_require__(5);
var Dialog = __webpack_require__(75);
var Currency = __webpack_require__(7);
var GTM = __webpack_require__(54);
var localize = __webpack_require__(2).localize;
var State = __webpack_require__(6).State;
var urlFor = __webpack_require__(8).urlFor;

var MetaTraderConfig = function () {
    var mt_companies = {
        financial: {
            standard: { mt5_account_type: 'standard', max_leverage: 1000, title: 'Standard' },
            advanced: { mt5_account_type: 'advanced', max_leverage: 300, title: 'Advanced' },
            mamm: { mt5_account_type: 'mamm_advanced', max_leverage: 300, title: 'MAM Advanced', is_real_only: 1 }
        },
        gaming: {
            volatility: { mt5_account_type: '', max_leverage: 500, title: 'Volatility Indices' },
            mamm: { mt5_account_type: 'mamm', max_leverage: 500, title: 'MAM Volatility Indices', is_real_only: 1 }
        }
    };

    var accounts_info = {};

    var $messages = void 0;
    var needsRealMessage = function needsRealMessage() {
        return $messages.find('#msg_' + (Client.hasAccountType('real') ? 'switch' : 'upgrade')).html();
    };

    // currency equivalent to 1 USD
    var getMinMT5TransferValue = function getMinMT5TransferValue(currency) {
        return (+State.getResponse('exchange_rates.rates.' + currency) || 1).toFixed(Currency.getDecimalPlaces(currency));
    };

    // currency equivalent to 20000 USD
    var getMaxMT5TransferValue = function getMaxMT5TransferValue(currency) {
        return (+getMinMT5TransferValue(currency) * 20000).toFixed(Currency.getDecimalPlaces(currency));
    };

    var newAccCheck = function newAccCheck(acc_type, message_selector) {
        return new Promise(function (resolve) {
            if (accounts_info[acc_type].is_demo) {
                resolve();
            } else if (Client.get('is_virtual')) {
                resolve(needsRealMessage());
            } else if (accounts_info[acc_type].account_type === 'financial') {
                BinarySocket.wait('get_account_status').then(function (response_get_account_status) {
                    var $message = $messages.find('#msg_real_financial').clone();
                    var is_ok = true;
                    if (/(financial_assessment|trading_experience)_not_complete/.test(response_get_account_status.get_account_status.status)) {
                        $message.find('.assessment').setVisibility(1).find('a').attr('onclick', 'localStorage.setItem(\'financial_assessment_redirect\', \'' + urlFor('user/metatrader') + '#' + acc_type + '\')');
                        is_ok = false;
                    }
                    if (response_get_account_status.get_account_status.prompt_client_to_authenticate) {
                        $message.find('.authenticate').setVisibility(1);
                        is_ok = false;
                    }
                    if (is_ok) {
                        resolve();
                    } else {
                        $message.find(message_selector).setVisibility(1);
                        resolve($message.html());
                    }
                });
            } else {
                resolve();
            }
        });
    };

    var actions_info = {
        new_account: {
            title: localize('Sign up'),
            login: function login(response) {
                return response.mt5_new_account.login;
            },
            prerequisites: function prerequisites(acc_type) {
                return newAccCheck(acc_type, '#msg_metatrader_account');
            },
            pre_submit: function pre_submit($form, acc_type) {
                return new Promise(function (resolve) {
                    if (!accounts_info[acc_type].is_demo && State.getResponse('landing_company.gaming_company.shortcode') === 'malta') {
                        Dialog.confirm({
                            id: 'confirm_new_account',
                            message: ['Trading Contracts for Difference (CFDs) on Volatility Indices may not be suitable for everyone. Please ensure that you fully understand the risks involved, including the possibility of losing all the funds in your MT5 account. Gambling can be addictive – please play responsibly.', 'Do you wish to continue?']
                        }).then(function (is_ok) {
                            if (!is_ok) {
                                BinaryPjax.load(Client.defaultRedirectUrl());
                            }
                            resolve(is_ok);
                        });
                    } else {
                        resolve(true);
                    }
                });
            },
            onSuccess: function onSuccess(response) {
                GTM.mt5NewAccount(response);
            }
        },
        new_account_mam: {
            title: localize('Sign up'),
            login: function login(response) {
                return response.mt5_new_account.login;
            },
            prerequisites: function prerequisites(acc_type) {
                return newAccCheck(acc_type, '#msg_mam_account');
            },
            onSuccess: function onSuccess(response) {
                GTM.mt5NewAccount(response);
            }
        },
        password_change: {
            title: localize('Change Password'),
            success_msg: function success_msg(response) {
                return localize('The [_1] password of account number [_2] has been changed.', [response.echo_req.password_type, response.echo_req.login]);
            },
            prerequisites: function prerequisites() {
                return new Promise(function (resolve) {
                    return resolve('');
                });
            }
        },
        password_reset: {
            title: localize('Reset Password')
        },
        verify_password_reset: {
            title: localize('Verify Reset Password'),
            success_msg: function success_msg() {
                return localize('Please check your email for further instructions.');
            },
            success_msg_selector: '#frm_verify_password_reset'
        },
        revoke_mam: {
            title: localize('Revoke MAM'),
            success_msg: function success_msg() {
                return localize('Manager successfully revoked');
            },
            prerequisites: function prerequisites() {
                return new Promise(function (resolve) {
                    return resolve('');
                });
            }
        },
        deposit: {
            title: localize('Deposit'),
            success_msg: function success_msg(response) {
                return localize('[_1] deposit from [_2] to account number [_3] is done. Transaction ID: [_4]', [Currency.formatMoney(State.getResponse('authorize.currency'), response.echo_req.amount), response.echo_req.from_binary, response.echo_req.to_mt5, response.binary_transaction_id]);
            },
            prerequisites: function prerequisites() {
                return new Promise(function (resolve) {
                    if (Client.get('is_virtual')) {
                        resolve(needsRealMessage());
                    } else {
                        BinarySocket.send({ cashier_password: 1 }).then(function (response) {
                            if (!response.error && response.cashier_password === 1) {
                                resolve(localize('Your cashier is locked as per your request - to unlock it, please click <a href="[_1]">here</a>.', [urlFor('user/security/cashier_passwordws')]));
                            } else {
                                BinarySocket.send({ get_account_status: 1 }).then(function (response_status) {
                                    if (!response_status.error && /cashier_locked/.test(response_status.get_account_status.status)) {
                                        resolve(localize('Your cashier is locked.')); // Locked from BO
                                    } else {
                                        var limit = State.getResponse('get_limits.remainder');
                                        if (typeof limit !== 'undefined' && +limit < getMinMT5TransferValue(Client.get('currency'))) {
                                            resolve(localize('You have reached the limit.'));
                                        } else {
                                            resolve();
                                        }
                                    }
                                });
                            }
                        });
                    }
                });
            }
        },
        withdrawal: {
            title: localize('Withdraw'),
            success_msg: function success_msg(response, acc_type) {
                return localize('[_1] withdrawal from account number [_2] to [_3] is done. Transaction ID: [_4]', [Currency.formatMoney(getCurrency(acc_type), response.echo_req.amount), response.echo_req.from_mt5, response.echo_req.to_binary, response.binary_transaction_id]);
            },
            prerequisites: function prerequisites(acc_type) {
                return new Promise(function (resolve) {
                    if (Client.get('is_virtual')) {
                        resolve(needsRealMessage());
                    } else if (accounts_info[acc_type].account_type === 'financial') {
                        BinarySocket.send({ get_account_status: 1 }).then(function (response_status) {
                            resolve(!/authenticated/.test(response_status.get_account_status.status) ? $messages.find('#msg_authenticate').html() : '');
                        });
                    } else {
                        resolve();
                    }
                });
            },
            pre_submit: function pre_submit($form, acc_type, displayFormMessage) {
                return BinarySocket.send({
                    mt5_password_check: 1,
                    login: accounts_info[acc_type].info.login,
                    password: $form.find(fields.withdrawal.txt_main_pass.id).val()
                }).then(function (response) {
                    if (+response.mt5_password_check === 1) {
                        return true;
                    } else if (response.error) {
                        displayFormMessage(response.error.message, 'withdrawal');
                    }
                    return false;
                });
            }
        }
    };

    var fields = {
        new_account: {
            txt_name: { id: '#txt_name', request_field: 'name' },
            txt_main_pass: { id: '#txt_main_pass', request_field: 'mainPassword' },
            txt_re_main_pass: { id: '#txt_re_main_pass' },
            txt_investor_pass: { id: '#txt_investor_pass', request_field: 'investPassword' },
            chk_tnc: { id: '#chk_tnc' },
            additional_fields: function additional_fields(acc_type) {
                return $.extend({
                    account_type: accounts_info[acc_type].account_type,
                    email: Client.get('email'),
                    leverage: accounts_info[acc_type].max_leverage
                }, accounts_info[acc_type].mt5_account_type ? {
                    mt5_account_type: accounts_info[acc_type].mt5_account_type
                } : {});
            }
        },
        new_account_mam: {
            txt_name: { id: '#txt_mam_name', request_field: 'name' },
            txt_manager_id: { id: '#txt_manager_id', request_field: 'manager_id' },
            txt_main_pass: { id: '#txt_mam_main_pass', request_field: 'mainPassword' },
            txt_re_main_pass: { id: '#txt_mam_re_main_pass' },
            txt_investor_pass: { id: '#txt_mam_investor_pass', request_field: 'investPassword' },
            chk_tnc: { id: '#chk_tnc' },
            additional_fields: function additional_fields(acc_type) {
                return {
                    account_type: accounts_info[acc_type].account_type,
                    email: Client.get('email'),
                    leverage: accounts_info[acc_type].max_leverage,
                    mt5_account_type: accounts_info[acc_type].mt5_account_type.replace(/mamm(_)*/, '') || 'standard' // for gaming just send standard to distinguish
                };
            }
        },
        password_change: {
            ddl_password_type: { id: '#ddl_password_type', request_field: 'password_type' },
            txt_old_password: { id: '#txt_old_password', request_field: 'old_password' },
            txt_new_password: { id: '#txt_new_password', request_field: 'new_password' },
            txt_re_new_password: { id: '#txt_re_new_password' },
            additional_fields: function additional_fields(acc_type) {
                return {
                    login: accounts_info[acc_type].info.login
                };
            }
        },
        password_reset: {
            ddl_password_type: { id: '#ddl_reset_password_type', request_field: 'password_type' },
            txt_new_password: { id: '#txt_reset_new_password', request_field: 'new_password' },
            txt_re_new_password: { id: '#txt_reset_re_new_password' },
            additional_fields: function additional_fields(acc_type, token) {
                return {
                    login: accounts_info[acc_type].info.login,
                    verification_code: token
                };
            }
        },
        verify_password_reset: {
            additional_fields: function additional_fields() {
                return {
                    verify_email: Client.get('email'),
                    type: 'mt5_password_reset'
                };
            }
        },
        revoke_mam: {
            additional_fields: function additional_fields(acc_type) {
                return {
                    mt5_mamm: 1,
                    login: accounts_info[acc_type].info.login,
                    action: 'revoke'
                };
            }
        },
        deposit: {
            txt_amount: { id: '#txt_amount_deposit', request_field: 'amount' },
            additional_fields: function additional_fields(acc_type) {
                return {
                    from_binary: Client.get('loginid'),
                    to_mt5: accounts_info[acc_type].info.login
                };
            }
        },
        withdrawal: {
            txt_amount: { id: '#txt_amount_withdrawal', request_field: 'amount' },
            txt_main_pass: { id: '#txt_main_pass_wd' },
            additional_fields: function additional_fields(acc_type) {
                return {
                    from_mt5: accounts_info[acc_type].info.login,
                    to_binary: Client.get('loginid')
                };
            }
        }
    };

    var validations = function validations() {
        return {
            new_account: [{ selector: fields.new_account.txt_name.id, validations: ['req', 'letter_symbol', ['length', { min: 2, max: 30 }]] }, { selector: fields.new_account.txt_main_pass.id, validations: ['req', ['password', 'mt']] }, { selector: fields.new_account.txt_re_main_pass.id, validations: ['req', ['compare', { to: fields.new_account.txt_main_pass.id }]] }, { selector: fields.new_account.txt_investor_pass.id, validations: ['req', ['password', 'mt'], ['not_equal', { to: fields.new_account.txt_main_pass.id, name1: 'Main password', name2: 'Investor password' }]] }],
            new_account_mam: [{ selector: fields.new_account_mam.txt_name.id, validations: ['req', 'letter_symbol', ['length', { min: 2, max: 30 }]] }, { selector: fields.new_account_mam.txt_manager_id.id, validations: ['req', ['length', { min: 0, max: 15 }]] }, { selector: fields.new_account_mam.txt_main_pass.id, validations: ['req', ['password', 'mt']] }, { selector: fields.new_account_mam.txt_re_main_pass.id, validations: ['req', ['compare', { to: fields.new_account_mam.txt_main_pass.id }]] }, { selector: fields.new_account_mam.txt_investor_pass.id, validations: ['req', ['password', 'mt'], ['not_equal', { to: fields.new_account_mam.txt_main_pass.id, name1: 'Main password', name2: 'Investor password' }]] }, { selector: fields.new_account_mam.chk_tnc.id, validations: ['req'] }],
            password_change: [{ selector: fields.password_change.ddl_password_type.id, validations: ['req'] }, { selector: fields.password_change.txt_old_password.id, validations: ['req'] }, { selector: fields.password_change.txt_new_password.id, validations: ['req', ['password', 'mt'], ['not_equal', { to: fields.password_change.txt_old_password.id, name1: 'Current password', name2: 'New password' }]], re_check_field: fields.password_change.txt_re_new_password.id }, { selector: fields.password_change.txt_re_new_password.id, validations: ['req', ['compare', { to: fields.password_change.txt_new_password.id }]] }],
            password_reset: [{ selector: fields.password_reset.ddl_password_type.id, validations: ['req'] }, { selector: fields.password_reset.txt_new_password.id, validations: ['req', ['password', 'mt']], re_check_field: fields.password_reset.txt_re_new_password.id }, { selector: fields.password_reset.txt_re_new_password.id, validations: ['req', ['compare', { to: fields.password_reset.txt_new_password.id }]] }],
            deposit: [{ selector: fields.deposit.txt_amount.id, validations: [['req', { hide_asterisk: true }], ['number', { type: 'float', min: function min() {
                        return getMinMT5TransferValue(Client.get('currency'));
                    }, max: Math.min(State.getResponse('get_limits.remainder') || getMaxMT5TransferValue(Client.get('currency')), getMaxMT5TransferValue(Client.get('currency'))).toFixed(Currency.getDecimalPlaces(Client.get('currency'))), decimals: Currency.getDecimalPlaces(Client.get('currency')) }], ['custom', { func: function func() {
                        return Client.get('balance') && +Client.get('balance') >= +$(fields.deposit.txt_amount.id).val();
                    }, message: localize('You have insufficient funds in your Binary account, please <a href="[_1]">add funds</a>.', [urlFor('cashier')]) }]] }],
            withdrawal: [{ selector: fields.withdrawal.txt_main_pass.id, validations: [['req', { hide_asterisk: true }]] }, { selector: fields.withdrawal.txt_amount.id, validations: [['req', { hide_asterisk: true }], ['number', { type: 'float', min: function min() {
                        return getMinMT5TransferValue(getCurrency(Client.get('mt5_account')));
                    }, max: function max() {
                        return getMaxMT5TransferValue(getCurrency(Client.get('mt5_account')));
                    }, decimals: 2 }]] }]
        };
    };

    var hasAccount = function hasAccount(acc_type) {
        return (accounts_info[acc_type] || {}).info;
    };

    var getCurrency = function getCurrency(acc_type) {
        return accounts_info[acc_type].info.currency;
    };

    return {
        mt_companies: mt_companies,
        accounts_info: accounts_info,
        actions_info: actions_info,
        fields: fields,
        validations: validations,
        needsRealMessage: needsRealMessage,
        hasAccount: hasAccount,
        getCurrency: getCurrency,
        setMessages: function setMessages($msg) {
            $messages = $msg;
        },
        getAllAccounts: function getAllAccounts() {
            return Object.keys(accounts_info).filter(function (acc_type) {
                return hasAccount(acc_type);
            }).sort(function (acc_type) {
                return accounts_info[acc_type].is_demo ? 1 : -1;
            }) // real first
            ;
        }
    };
}();

module.exports = MetaTraderConfig;

/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BinaryPjax = __webpack_require__(12);
var Client = __webpack_require__(3);
var Header = __webpack_require__(27);
var BinarySocket = __webpack_require__(5);
var State = __webpack_require__(6).State;
var urlFor = __webpack_require__(8).urlFor;
var template = __webpack_require__(1).template;

var TNCApproval = function () {
    var onLoad = function onLoad() {
        requiresTNCApproval($('#btn_accept'), display, null, true);
    };

    var display = function display() {
        var landing_company = State.getResponse('authorize.landing_company_fullname');
        if (!landing_company) return;

        var $container = $('#tnc_container');
        var $tnc_msg = $container.find('#tnc_message');
        $tnc_msg.html(template($tnc_msg.html(), [landing_company, urlFor(Client.get('residence') === 'jp' ? 'terms-and-conditions-jp' : 'terms-and-conditions')]));
        $container.find('#tnc_loading').remove();
        $container.find('#tnc_approval').setVisibility(1);
    };

    var requiresTNCApproval = function requiresTNCApproval($btn, funcDisplay, onSuccess, redirect_anyway) {
        BinarySocket.wait('website_status', 'get_settings').then(function () {
            if (!Client.shouldAcceptTnc()) {
                redirectBack(redirect_anyway);
                return;
            }

            funcDisplay();

            $btn.click(function (e) {
                e.preventDefault();
                e.stopPropagation();
                BinarySocket.send({ tnc_approval: '1' }, { forced: true }).then(function (response) {
                    if (response.error) {
                        $('#err_message').html(response.error.message).setVisibility(1);
                    } else {
                        BinarySocket.send({ get_settings: 1 }, { forced: true }).then(function () {
                            Header.displayAccountStatus();
                        });
                        redirectBack(redirect_anyway);
                        if (typeof onSuccess === 'function') {
                            onSuccess();
                        }
                    }
                });
            });
        });
    };

    var redirectBack = function redirectBack(redirect_anyway) {
        if (redirect_anyway) {
            setTimeout(function () {
                BinaryPjax.loadPreviousUrl();
            }, 500);
        }
    };

    return {
        onLoad: onLoad,
        requiresTNCApproval: requiresTNCApproval
    };
}();

module.exports = TNCApproval;

/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var urlFor = __webpack_require__(8).urlFor;
var Client = __webpack_require__(3);
var BinarySocket = __webpack_require__(5);

var AffiliatePopup = function () {
    var container_id = 'affiliate_disclaimer_popup';

    var show = function show() {
        if (Client.isLoggedIn() || $('#' + container_id).length) return;
        BinarySocket.wait('website_status').then(function (response) {
            if (Client.isJPClient() || response.website_status.clients_country === 'jp') {
                $.ajax({
                    url: urlFor('affiliate_disclaimer'),
                    dataType: 'html',
                    method: 'GET',
                    success: function success(contents) {
                        if ($('#' + container_id).length) return;
                        $('body').append($('<div/>', { id: container_id, class: 'lightbox' }).append($('<div/>').append($(contents))));
                        $('#btn_affiliate_proceed').off('click').on('click', close);
                    }
                });
            }
        });
    };

    var close = function close() {
        $('#' + container_id).remove();
    };

    return {
        show: show
    };
}();

module.exports = AffiliatePopup;

/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Login = __webpack_require__(55);
var localize = __webpack_require__(2).localize;
var TabSelector = __webpack_require__(95);
var BinarySocket = __webpack_require__(5);
var FormManager = __webpack_require__(18);

var Home = function () {
    var clients_country = void 0;

    var onLoad = function onLoad() {
        TabSelector.onLoad();

        BinarySocket.wait('website_status').then(function (response) {
            clients_country = response.website_status.clients_country;

            // we need to initiate selector after it becoming visible
            TabSelector.repositionSelector();

            var form_id = '#frm_verify_email';
            FormManager.init(form_id, [{ selector: '#email', validations: ['req', 'email'], request_field: 'verify_email' }, { request_field: 'type', value: 'account_opening' }]);
            FormManager.handleSubmit({
                form_selector: form_id,
                fnc_response_handler: handler,
                fnc_additional_check: checkCountry
            });
            socialLogin();
        });
    };

    var socialLogin = function socialLogin() {
        $('#google-signup').off('click').on('click', function (e) {
            e.preventDefault();
            window.location.href = Login.socialLoginUrl('google');
        });
    };

    var checkCountry = function checkCountry(req) {
        if (clients_country !== 'my' || /@binary\.com$/.test(req.verify_email)) {
            return true;
        }
        $('#frm_verify_email').find('div').html($('<p/>', { class: 'notice-msg center-text', html: localize('Sorry, account signup is not available in your country.') }));
        return false;
    };

    var handler = function handler(response) {
        var error = response.error;
        if (!error) {
            $('.signup-box div').replaceWith($('<p/>', { text: localize('Thank you for signing up! Please check your email to complete the registration process.'), class: 'gr-10 gr-centered center-text' }));
        } else {
            $('#signup_error').setVisibility(1).text(error.message);
        }
    };

    var onUnload = function onUnload() {
        TabSelector.onUnload();
    };

    return {
        onLoad: onLoad,
        onUnload: onUnload
    };
}();

module.exports = Home;

/***/ }),
/* 186 */,
/* 187 */,
/* 188 */,
/* 189 */,
/* 190 */,
/* 191 */,
/* 192 */,
/* 193 */,
/* 194 */,
/* 195 */,
/* 196 */,
/* 197 */,
/* 198 */,
/* 199 */,
/* 200 */,
/* 201 */,
/* 202 */,
/* 203 */,
/* 204 */,
/* 205 */,
/* 206 */,
/* 207 */,
/* 208 */,
/* 209 */,
/* 210 */,
/* 211 */,
/* 212 */,
/* 213 */,
/* 214 */,
/* 215 */,
/* 216 */,
/* 217 */,
/* 218 */,
/* 219 */,
/* 220 */,
/* 221 */,
/* 222 */,
/* 223 */,
/* 224 */,
/* 225 */,
/* 226 */,
/* 227 */,
/* 228 */,
/* 229 */,
/* 230 */,
/* 231 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var moment = __webpack_require__(9);
var urlForStatic = __webpack_require__(8).urlForStatic;
var getStaticHash = __webpack_require__(1).getStaticHash;

// only reload if it's more than 10 minutes since the last reload
var shouldForceReload = function shouldForceReload(last_reload) {
    return !last_reload || +last_reload + 10 * 60 * 1000 < moment().valueOf();
};

// calling this method is handled by GTM tags
var checkNewRelease = function checkNewRelease() {
    var last_reload = localStorage.getItem('new_release_reload_time');
    if (!shouldForceReload(last_reload)) return false;
    localStorage.setItem('new_release_reload_time', moment().valueOf());

    var current_hash = getStaticHash();
    var xhttp = new XMLHttpRequest();

    xhttp.onreadystatechange = function () {
        if (+xhttp.readyState === 4 && +xhttp.status === 200) {
            var latest_hash = xhttp.responseText;
            if (latest_hash && current_hash && latest_hash !== current_hash) {
                window.location.reload(true);
            }
        }
    };
    xhttp.open('GET', urlForStatic('version?' + Math.random().toString(36).slice(2)), true);
    xhttp.send();

    return true;
};

module.exports = {
    shouldForceReload: shouldForceReload,
    checkNewRelease: checkNewRelease
};

/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
*
* jquery.sparkline.js
*
* v@VERSION@
* (c) Splunk, Inc
* Contact: Gareth Watts (gareth@splunk.com)
* http://omnipotent.net/jquery.sparkline/
*
* Generates inline sparkline charts from data supplied either to the method
* or inline in HTML
*
* Compatible with Internet Explorer 6.0+ and modern browsers equipped with the canvas tag
* (Firefox 2.0+, Safari, Opera, etc)
*
* License: New BSD License
*
* Copyright (c) 2012, Splunk Inc.
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without modification,
* are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright notice,
*       this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright notice,
*       this list of conditions and the following disclaimer in the documentation
*       and/or other materials provided with the distribution.
*     * Neither the name of Splunk Inc nor the names of its contributors may
*       be used to endorse or promote products derived from this software without
*       specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
* SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
* SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
* OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
* OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*
*
* Usage:
*  $(selector).sparkline(values, options)
*
* If values is undefined or set to 'html' then the data values are read from the specified tag:
*   <p>Sparkline: <span class="sparkline">1,4,6,6,8,5,3,5</span></p>
*   $('.sparkline').sparkline();
* There must be no spaces in the enclosed data set
*
* Otherwise values must be an array of numbers or null values
*    <p>Sparkline: <span id="sparkline1">This text replaced if the browser is compatible</span></p>
*    $('#sparkline1').sparkline([1,4,6,6,8,5,3,5])
*    $('#sparkline2').sparkline([1,4,6,null,null,5,3,5])
*
* Values can also be specified in an HTML comment, or as a values attribute:
*    <p>Sparkline: <span class="sparkline"><!--1,4,6,6,8,5,3,5 --></span></p>
*    <p>Sparkline: <span class="sparkline" values="1,4,6,6,8,5,3,5"></span></p>
*    $('.sparkline').sparkline();
*
* For line charts, x values can also be specified:
*   <p>Sparkline: <span class="sparkline">1:1,2.7:4,3.4:6,5:6,6:8,8.7:5,9:3,10:5</span></p>
*    $('#sparkline1').sparkline([ [1,1], [2.7,4], [3.4,6], [5,6], [6,8], [8.7,5], [9,3], [10,5] ])
*
* By default, options should be passed in as the second argument to the sparkline function:
*   $('.sparkline').sparkline([1,2,3,4], {type: 'bar'})
*
* Options can also be set by passing them on the tag itself.  This feature is disabled by default though
* as there's a slight performance overhead:
*   $('.sparkline').sparkline([1,2,3,4], {enableTagOptions: true})
*   <p>Sparkline: <span class="sparkline" sparkType="bar" sparkBarColor="red">loading</span></p>
* Prefix all options supplied as tag attribute with "spark" (configurable by setting tagOptionsPrefix)
*
* Supported options:
*   lineColor - Color of the line used for the chart
*   fillColor - Color used to fill in the chart - Set to '' or false for a transparent chart
*   width - Width of the chart - Defaults to 3 times the number of values in pixels
*   height - Height of the chart - Defaults to the height of the containing element
*   chartRangeMin - Specify the minimum value to use for the Y range of the chart - Defaults to the minimum value supplied
*   chartRangeMax - Specify the maximum value to use for the Y range of the chart - Defaults to the maximum value supplied
*   chartRangeClip - Clip out of range values to the max/min specified by chartRangeMin and chartRangeMax
*   chartRangeMinX - Specify the minimum value to use for the X range of the chart - Defaults to the minimum value supplied
*   chartRangeMaxX - Specify the maximum value to use for the X range of the chart - Defaults to the maximum value supplied
*   composite - If true then don't erase any existing chart attached to the tag, but draw
*           another chart over the top - Note that width and height are ignored if an
*           existing chart is detected.
*   tagValuesAttribute - Name of tag attribute to check for data values - Defaults to 'values'
*   enableTagOptions - Whether to check tags for sparkline options
*   tagOptionsPrefix - Prefix used for options supplied as tag attributes - Defaults to 'spark'
*   disableHiddenCheck - If set to true, then the plugin will assume that charts will never be drawn into a
*           hidden dom element, avoding a browser reflow
*   disableInteraction - If set to true then all mouseover/click interaction behaviour will be disabled,
*       making the plugin perform much like it did in 1.x
*   disableTooltips - If set to true then tooltips will be disabled - Defaults to false (tooltips enabled)
*   disableHighlight - If set to true then highlighting of selected chart elements on mouseover will be disabled
*       defaults to false (highlights enabled)
*   highlightLighten - Factor to lighten/darken highlighted chart values by - Defaults to 1.4 for a 40% increase
*   tooltipContainer - Specify which DOM element the tooltip should be rendered into - defaults to document.body
*   tooltipClassname - Optional CSS classname to apply to tooltips - If not specified then a default style will be applied
*   tooltipOffsetX - How many pixels away from the mouse pointer to render the tooltip on the X axis
*   tooltipOffsetY - How many pixels away from the mouse pointer to render the tooltip on the r axis
*   tooltipFormatter  - Optional callback that allows you to override the HTML displayed in the tooltip
*       callback is given arguments of (sparkline, options, fields)
*   tooltipChartTitle - If specified then the tooltip uses the string specified by this setting as a title
*   tooltipFormat - A format string or SPFormat object  (or an array thereof for multiple entries)
*       to control the format of the tooltip
*   tooltipPrefix - A string to prepend to each field displayed in a tooltip
*   tooltipSuffix - A string to append to each field displayed in a tooltip
*   tooltipSkipNull - If true then null values will not have a tooltip displayed (defaults to true)
*   tooltipValueLookups - An object or range map to map field values to tooltip strings
*       (eg. to map -1 to "Lost", 0 to "Draw", and 1 to "Win")
*   numberFormatter - Optional callback for formatting numbers in tooltips
*   numberDigitGroupSep - Character to use for group separator in numbers "1,234" - Defaults to ","
*   numberDecimalMark - Character to use for the decimal point when formatting numbers - Defaults to "."
*   numberDigitGroupCount - Number of digits between group separator - Defaults to 3
*
* There are 7 types of sparkline, selected by supplying a "type" option of 'line' (default),
* 'bar', 'tristate', 'bullet', 'discrete', 'pie' or 'box'
*    line - Line chart.  Options:
*       spotColor - Set to '' to not end each line in a circular spot
*       minSpotColor - If set, color of spot at minimum value
*       maxSpotColor - If set, color of spot at maximum value
*       spotRadius - Radius in pixels
*       lineWidth - Width of line in pixels
*       normalRangeMin
*       normalRangeMax - If set draws a filled horizontal bar between these two values marking the "normal"
*                      or expected range of values
*       normalRangeColor - Color to use for the above bar
*       drawNormalOnTop - Draw the normal range above the chart fill color if true
*       defaultPixelsPerValue - Defaults to 3 pixels of width for each value in the chart
*       highlightSpotColor - The color to use for drawing a highlight spot on mouseover - Set to null to disable
*       highlightLineColor - The color to use for drawing a highlight line on mouseover - Set to null to disable
*       valueSpots - Specify which points to draw spots on, and in which color.  Accepts a range map
*
*   bar - Bar chart.  Options:
*       barColor - Color of bars for postive values
*       negBarColor - Color of bars for negative values
*       zeroColor - Color of bars with zero values
*       nullColor - Color of bars with null values - Defaults to omitting the bar entirely
*       barWidth - Width of bars in pixels
*       colorMap - Optional mappnig of values to colors to override the *BarColor values above
*                  can be an Array of values to control the color of individual bars or a range map
*                  to specify colors for individual ranges of values
*       barSpacing - Gap between bars in pixels
*       zeroAxis - Centers the y-axis around zero if true
*
*   tristate - Charts values of win (>0), lose (<0) or draw (=0)
*       posBarColor - Color of win values
*       negBarColor - Color of lose values
*       zeroBarColor - Color of draw values
*       barWidth - Width of bars in pixels
*       barSpacing - Gap between bars in pixels
*       colorMap - Optional mappnig of values to colors to override the *BarColor values above
*                  can be an Array of values to control the color of individual bars or a range map
*                  to specify colors for individual ranges of values
*
*   discrete - Options:
*       lineHeight - Height of each line in pixels - Defaults to 30% of the graph height
*       thesholdValue - Values less than this value will be drawn using thresholdColor instead of lineColor
*       thresholdColor
*
*   bullet - Values for bullet graphs msut be in the order: target, performance, range1, range2, range3, ...
*       options:
*       targetColor - The color of the vertical target marker
*       targetWidth - The width of the target marker in pixels
*       performanceColor - The color of the performance measure horizontal bar
*       rangeColors - Colors to use for each qualitative range background color
*
*   pie - Pie chart. Options:
*       sliceColors - An array of colors to use for pie slices
*       offset - Angle in degrees to offset the first slice - Try -90 or +90
*       borderWidth - Width of border to draw around the pie chart, in pixels - Defaults to 0 (no border)
*       borderColor - Color to use for the pie chart border - Defaults to #000
*
*   box - Box plot. Options:
*       raw - Set to true to supply pre-computed plot points as values
*             values should be: low_outlier, low_whisker, q1, median, q3, high_whisker, high_outlier
*             When set to false you can supply any number of values and the box plot will
*             be computed for you.  Default is false.
*       showOutliers - Set to true (default) to display outliers as circles
*       outlierIQR - Interquartile range used to determine outliers.  Default 1.5
*       boxLineColor - Outline color of the box
*       boxFillColor - Fill color for the box
*       whiskerColor - Line color used for whiskers
*       outlierLineColor - Outline color of outlier circles
*       outlierFillColor - Fill color of the outlier circles
*       spotRadius - Radius of outlier circles
*       medianColor - Line color of the median line
*       target - Draw a target cross hair at the supplied value (default undefined)
*
*
*
*   Examples:
*   $('#sparkline1').sparkline(myvalues, { lineColor: '#f00', fillColor: false });
*   $('.barsparks').sparkline('html', { type:'bar', height:'40px', barWidth:5 });
*   $('#tristate').sparkline([1,1,-1,1,0,0,-1], { type:'tristate' }):
*   $('#discrete').sparkline([1,3,4,5,5,3,4,5], { type:'discrete' });
*   $('#bullet').sparkline([10,12,12,9,7], { type:'bullet' });
*   $('#pie').sparkline([1,1,2], { type:'pie' });
*/

/*jslint regexp: true, browser: true, jquery: true, white: true, nomen: false, plusplus: false, maxerr: 500, indent: 4 */

(function (document, Math, undefined) {
    // performance/minified-size optimization
    (function (factory) {
        if (true) {
            !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(72)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
        } else if (jQuery && !jQuery.fn.sparkline) {
            factory(jQuery);
        }
    })(function ($) {
        'use strict';

        var UNSET_OPTION = {},
            getDefaults,
            createClass,
            SPFormat,
            clipval,
            quartile,
            normalizeValue,
            normalizeValues,
            remove,
            isNumber,
            all,
            sum,
            addCSS,
            ensureArray,
            formatNumber,
            RangeMap,
            MouseHandler,
            Tooltip,
            barHighlightMixin,
            line,
            bar,
            tristate,
            discrete,
            bullet,
            pie,
            box,
            defaultStyles,
            initStyles,
            VShape,
            VCanvas_base,
            VCanvas_canvas,
            VCanvas_vml,
            pending,
            shapeCount = 0;

        /**
         * Default configuration settings
         */
        getDefaults = function getDefaults() {
            return {
                // Settings common to most/all chart types
                common: {
                    type: 'line',
                    lineColor: '#00f',
                    fillColor: '#cdf',
                    defaultPixelsPerValue: 3,
                    width: 'auto',
                    height: 'auto',
                    composite: false,
                    tagValuesAttribute: 'values',
                    tagOptionsPrefix: 'spark',
                    enableTagOptions: false,
                    enableHighlight: true,
                    highlightLighten: 1.4,
                    tooltipSkipNull: true,
                    tooltipPrefix: '',
                    tooltipSuffix: '',
                    disableHiddenCheck: false,
                    numberFormatter: false,
                    numberDigitGroupCount: 3,
                    numberDigitGroupSep: ',',
                    numberDecimalMark: '.',
                    disableTooltips: false,
                    disableInteraction: false
                },
                // Defaults for line charts
                line: {
                    spotColor: '#f80',
                    highlightSpotColor: '#5f5',
                    highlightLineColor: '#f22',
                    spotRadius: 1.5,
                    minSpotColor: '#f80',
                    maxSpotColor: '#f80',
                    lineWidth: 1,
                    normalRangeMin: undefined,
                    normalRangeMax: undefined,
                    normalRangeColor: '#ccc',
                    drawNormalOnTop: false,
                    chartRangeMin: undefined,
                    chartRangeMax: undefined,
                    chartRangeMinX: undefined,
                    chartRangeMaxX: undefined,
                    tooltipFormat: new SPFormat('<span style="color: {{color}}">&#9679;</span> {{prefix}}{{y}}{{suffix}}')
                },
                // Defaults for bar charts
                bar: {
                    barColor: '#3366cc',
                    negBarColor: '#f44',
                    stackedBarColor: ['#3366cc', '#dc3912', '#ff9900', '#109618', '#66aa00', '#dd4477', '#0099c6', '#990099'],
                    zeroColor: undefined,
                    nullColor: undefined,
                    zeroAxis: true,
                    barWidth: 4,
                    barSpacing: 1,
                    chartRangeMax: undefined,
                    chartRangeMin: undefined,
                    chartRangeClip: false,
                    colorMap: undefined,
                    tooltipFormat: new SPFormat('<span style="color: {{color}}">&#9679;</span> {{prefix}}{{value}}{{suffix}}')
                },
                // Defaults for tristate charts
                tristate: {
                    barWidth: 4,
                    barSpacing: 1,
                    posBarColor: '#6f6',
                    negBarColor: '#f44',
                    zeroBarColor: '#999',
                    colorMap: {},
                    tooltipFormat: new SPFormat('<span style="color: {{color}}">&#9679;</span> {{value:map}}'),
                    tooltipValueLookups: { map: { '-1': 'Loss', '0': 'Draw', '1': 'Win' } }
                },
                // Defaults for discrete charts
                discrete: {
                    lineHeight: 'auto',
                    thresholdColor: undefined,
                    thresholdValue: 0,
                    chartRangeMax: undefined,
                    chartRangeMin: undefined,
                    chartRangeClip: false,
                    tooltipFormat: new SPFormat('{{prefix}}{{value}}{{suffix}}')
                },
                // Defaults for bullet charts
                bullet: {
                    targetColor: '#f33',
                    targetWidth: 3, // width of the target bar in pixels
                    performanceColor: '#33f',
                    rangeColors: ['#d3dafe', '#a8b6ff', '#7f94ff'],
                    base: undefined, // set this to a number to change the base start number
                    tooltipFormat: new SPFormat('{{fieldkey:fields}} - {{value}}'),
                    tooltipValueLookups: { fields: { r: 'Range', p: 'Performance', t: 'Target' } }
                },
                // Defaults for pie charts
                pie: {
                    offset: 0,
                    sliceColors: ['#3366cc', '#dc3912', '#ff9900', '#109618', '#66aa00', '#dd4477', '#0099c6', '#990099'],
                    borderWidth: 0,
                    borderColor: '#000',
                    tooltipFormat: new SPFormat('<span style="color: {{color}}">&#9679;</span> {{value}} ({{percent.1}}%)')
                },
                // Defaults for box plots
                box: {
                    raw: false,
                    boxLineColor: '#000',
                    boxFillColor: '#cdf',
                    whiskerColor: '#000',
                    outlierLineColor: '#333',
                    outlierFillColor: '#fff',
                    medianColor: '#f00',
                    showOutliers: true,
                    outlierIQR: 1.5,
                    spotRadius: 1.5,
                    target: undefined,
                    targetColor: '#4a2',
                    chartRangeMax: undefined,
                    chartRangeMin: undefined,
                    tooltipFormat: new SPFormat('{{field:fields}}: {{value}}'),
                    tooltipFormatFieldlistKey: 'field',
                    tooltipValueLookups: { fields: { lq: 'Lower Quartile', med: 'Median',
                            uq: 'Upper Quartile', lo: 'Left Outlier', ro: 'Right Outlier',
                            lw: 'Left Whisker', rw: 'Right Whisker' } }
                }
            };
        };

        // You can have tooltips use a css class other than jqstooltip by specifying tooltipClassname
        defaultStyles = '.jqstooltip { ' + 'position: absolute;' + 'left: 0;' + 'top: 0;' + 'visibility: hidden;' + 'background: rgb(0, 0, 0) transparent;' + 'background-color: rgba(0,0,0,0.6);' + 'filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=#99000000, endColorstr=#99000000);' + '-ms-filter: "progid:DXImageTransform.Microsoft.gradient(startColorstr=#99000000, endColorstr=#99000000)";' + 'color: white;' + 'font: 10px arial, san serif;' + 'text-align: left;' + 'white-space: nowrap;' + 'padding: 5px;' + 'border: 1px solid white;' + 'box-sizing: content-box;' + 'z-index: 10000;' + '}' + '.jqsfield { ' + 'color: white;' + 'font: 10px arial, san serif;' + 'text-align: left;' + '}';

        /**
         * Utilities
         */

        createClass = function createClass() /* [baseclass, [mixin, ...]], definition */{
            var Class, args;
            Class = function Class() {
                this.init.apply(this, arguments);
            };
            if (arguments.length > 1) {
                if (arguments[0]) {
                    Class.prototype = $.extend(new arguments[0](), arguments[arguments.length - 1]);
                    Class._super = arguments[0].prototype;
                } else {
                    Class.prototype = arguments[arguments.length - 1];
                }
                if (arguments.length > 2) {
                    args = Array.prototype.slice.call(arguments, 1, -1);
                    args.unshift(Class.prototype);
                    $.extend.apply($, args);
                }
            } else {
                Class.prototype = arguments[0];
            }
            Class.prototype.cls = Class;
            return Class;
        };

        /**
         * Wraps a format string for tooltips
         * {{x}}
         * {{x.2}
         * {{x:months}}
         */
        $.SPFormatClass = SPFormat = createClass({
            fre: /\{\{([\w.]+?)(:(.+?))?\}\}/g,
            precre: /(\w+)\.(\d+)/,

            init: function init(format, fclass) {
                this.format = format;
                this.fclass = fclass;
            },

            render: function render(fieldset, lookups, options) {
                var self = this,
                    fields = fieldset,
                    match,
                    token,
                    lookupkey,
                    fieldvalue,
                    prec;
                return this.format.replace(this.fre, function () {
                    var lookup;
                    token = arguments[1];
                    lookupkey = arguments[3];
                    match = self.precre.exec(token);
                    if (match) {
                        prec = match[2];
                        token = match[1];
                    } else {
                        prec = false;
                    }
                    fieldvalue = fields[token];
                    if (fieldvalue === undefined) {
                        return '';
                    }
                    if (lookupkey && lookups && lookups[lookupkey]) {
                        lookup = lookups[lookupkey];
                        if (lookup.get) {
                            // RangeMap
                            return lookups[lookupkey].get(fieldvalue) || fieldvalue;
                        } else {
                            return lookups[lookupkey][fieldvalue] || fieldvalue;
                        }
                    }
                    if (isNumber(fieldvalue)) {
                        if (options.get('numberFormatter')) {
                            fieldvalue = options.get('numberFormatter')(fieldvalue);
                        } else {
                            fieldvalue = formatNumber(fieldvalue, prec, options.get('numberDigitGroupCount'), options.get('numberDigitGroupSep'), options.get('numberDecimalMark'));
                        }
                    }
                    return fieldvalue;
                });
            }
        });

        // convience method to avoid needing the new operator
        $.spformat = function (format, fclass) {
            return new SPFormat(format, fclass);
        };

        clipval = function clipval(val, min, max) {
            if (val < min) {
                return min;
            }
            if (val > max) {
                return max;
            }
            return val;
        };

        quartile = function quartile(values, q) {
            var vl;
            if (q === 2) {
                vl = Math.floor(values.length / 2);
                return values.length % 2 ? values[vl] : (values[vl - 1] + values[vl]) / 2;
            } else {
                if (values.length % 2) {
                    // odd
                    vl = (values.length * q + q) / 4;
                    return vl % 1 ? (values[Math.floor(vl)] + values[Math.floor(vl) - 1]) / 2 : values[vl - 1];
                } else {
                    //even
                    vl = (values.length * q + 2) / 4;
                    return vl % 1 ? (values[Math.floor(vl)] + values[Math.floor(vl) - 1]) / 2 : values[vl - 1];
                }
            }
        };

        normalizeValue = function normalizeValue(val) {
            var nf;
            switch (val) {
                case 'undefined':
                    val = undefined;
                    break;
                case 'null':
                    val = null;
                    break;
                case 'true':
                    val = true;
                    break;
                case 'false':
                    val = false;
                    break;
                default:
                    nf = parseFloat(val);
                    if (val == nf) {
                        val = nf;
                    }
            }
            return val;
        };

        normalizeValues = function normalizeValues(vals) {
            var i,
                result = [];
            for (i = vals.length; i--;) {
                result[i] = normalizeValue(vals[i]);
            }
            return result;
        };

        remove = function remove(vals, filter) {
            var i,
                vl,
                result = [];
            for (i = 0, vl = vals.length; i < vl; i++) {
                if (vals[i] !== filter) {
                    result.push(vals[i]);
                }
            }
            return result;
        };

        isNumber = function isNumber(num) {
            return !isNaN(parseFloat(num)) && isFinite(num);
        };

        formatNumber = function formatNumber(num, prec, groupsize, groupsep, decsep) {
            var p, i;
            num = (prec === false ? parseFloat(num).toString() : num.toFixed(prec)).split('');
            p = (p = $.inArray('.', num)) < 0 ? num.length : p;
            if (p < num.length) {
                num[p] = decsep;
            }
            for (i = p - groupsize; i > 0; i -= groupsize) {
                num.splice(i, 0, groupsep);
            }
            return num.join('');
        };

        // determine if all values of an array match a value
        // returns true if the array is empty
        all = function all(val, arr, ignoreNull) {
            var i;
            for (i = arr.length; i--;) {
                if (ignoreNull && arr[i] === null) continue;
                if (arr[i] !== val) {
                    return false;
                }
            }
            return true;
        };

        // sums the numeric values in an array, ignoring other values
        sum = function sum(vals) {
            var total = 0,
                i;
            for (i = vals.length; i--;) {
                total += typeof vals[i] === 'number' ? vals[i] : 0;
            }
            return total;
        };

        ensureArray = function ensureArray(val) {
            return $.isArray(val) ? val : [val];
        };

        // http://paulirish.com/2008/bookmarklet-inject-new-css-rules/
        addCSS = function addCSS(css) {
            var tag, iefail;
            if (document.createStyleSheet) {
                try {
                    document.createStyleSheet().cssText = css;
                    return;
                } catch (e) {
                    // IE <= 9 maxes out at 31 stylesheets; inject into page instead.
                    iefail = true;
                }
            }
            tag = document.createElement('style');
            tag.type = 'text/css';
            document.getElementsByTagName('head')[0].appendChild(tag);
            if (iefail) {
                document.styleSheets[document.styleSheets.length - 1].cssText = css;
            } else {
                tag[typeof document.body.style.WebkitAppearance == 'string' ? /* webkit only */'innerText' : 'innerHTML'] = css;
            }
        };

        // Provide a cross-browser interface to a few simple drawing primitives
        $.fn.simpledraw = function (width, height, useExisting, interact) {
            var target, mhandler;
            if (useExisting && (target = this.data('_jqs_vcanvas'))) {
                return target;
            }

            if ($.fn.sparkline.canvas === false) {
                // We've already determined that neither Canvas nor VML are available
                return false;
            } else if ($.fn.sparkline.canvas === undefined) {
                // No function defined yet -- need to see if we support Canvas or VML
                var el = document.createElement('canvas');
                if (!!(el.getContext && el.getContext('2d'))) {
                    // Canvas is available
                    $.fn.sparkline.canvas = function (width, height, target, interact) {
                        return new VCanvas_canvas(width, height, target, interact);
                    };
                } else if (document.namespaces && !document.namespaces.v) {
                    // VML is available
                    document.namespaces.add('v', 'urn:schemas-microsoft-com:vml', '#default#VML');
                    $.fn.sparkline.canvas = function (width, height, target, interact) {
                        return new VCanvas_vml(width, height, target);
                    };
                } else {
                    // Neither Canvas nor VML are available
                    $.fn.sparkline.canvas = false;
                    return false;
                }
            }

            if (width === undefined) {
                width = $(this).innerWidth();
            }
            if (height === undefined) {
                height = $(this).innerHeight();
            }

            target = $.fn.sparkline.canvas(width, height, this, interact);

            mhandler = $(this).data('_jqs_mhandler');
            if (mhandler) {
                mhandler.registerCanvas(target);
            }
            return target;
        };

        $.fn.cleardraw = function () {
            var target = this.data('_jqs_vcanvas');
            if (target) {
                target.reset();
            }
        };

        $.RangeMapClass = RangeMap = createClass({
            init: function init(map) {
                var key,
                    range,
                    rangelist = [];
                for (key in map) {
                    if (map.hasOwnProperty(key) && typeof key === 'string' && key.indexOf(':') > -1) {
                        range = key.split(':');
                        range[0] = range[0].length === 0 ? -Infinity : parseFloat(range[0]);
                        range[1] = range[1].length === 0 ? Infinity : parseFloat(range[1]);
                        range[2] = map[key];
                        rangelist.push(range);
                    }
                }
                this.map = map;
                this.rangelist = rangelist || false;
            },

            get: function get(value) {
                var rangelist = this.rangelist,
                    i,
                    range,
                    result;
                if ((result = this.map[value]) !== undefined) {
                    return result;
                }
                if (rangelist) {
                    for (i = rangelist.length; i--;) {
                        range = rangelist[i];
                        if (range[0] <= value && range[1] >= value) {
                            return range[2];
                        }
                    }
                }
                return undefined;
            }
        });

        // Convenience function
        $.range_map = function (map) {
            return new RangeMap(map);
        };

        MouseHandler = createClass({
            init: function init(el, options) {
                var $el = $(el);
                this.$el = $el;
                this.options = options;
                this.currentPageX = 0;
                this.currentPageY = 0;
                this.el = el;
                this.splist = [];
                this.tooltip = null;
                this.over = false;
                this.displayTooltips = !options.get('disableTooltips');
                this.highlightEnabled = !options.get('disableHighlight');
            },

            registerSparkline: function registerSparkline(sp) {
                this.splist.push(sp);
                if (this.over) {
                    this.updateDisplay();
                }
            },

            registerCanvas: function registerCanvas(canvas) {
                var $canvas = $(canvas.canvas);
                this.canvas = canvas;
                this.$canvas = $canvas;
                $canvas.mouseenter($.proxy(this.mouseenter, this));
                $canvas.mouseleave($.proxy(this.mouseleave, this));
                $canvas.click($.proxy(this.mouseclick, this));
            },

            reset: function reset(removeTooltip) {
                this.splist = [];
                if (this.tooltip && removeTooltip) {
                    this.tooltip.remove();
                    this.tooltip = undefined;
                }
            },

            mouseclick: function mouseclick(e) {
                var clickEvent = $.Event('sparklineClick');
                clickEvent.originalEvent = e;
                clickEvent.sparklines = this.splist;
                this.$el.trigger(clickEvent);
            },

            mouseenter: function mouseenter(e) {
                $(document.body).unbind('mousemove.jqs');
                $(document.body).bind('mousemove.jqs', $.proxy(this.mousemove, this));
                this.over = true;
                this.currentPageX = e.pageX;
                this.currentPageY = e.pageY;
                this.currentEl = e.target;
                if (!this.tooltip && this.displayTooltips) {
                    this.tooltip = new Tooltip(this.options);
                    this.tooltip.updatePosition(e.pageX, e.pageY);
                }
                this.updateDisplay();
            },

            mouseleave: function mouseleave() {
                $(document.body).unbind('mousemove.jqs');
                var splist = this.splist,
                    spcount = splist.length,
                    needsRefresh = false,
                    sp,
                    i;
                this.over = false;
                this.currentEl = null;

                if (this.tooltip) {
                    this.tooltip.remove();
                    this.tooltip = null;
                }

                for (i = 0; i < spcount; i++) {
                    sp = splist[i];
                    if (sp.clearRegionHighlight()) {
                        needsRefresh = true;
                    }
                }

                if (needsRefresh) {
                    this.canvas.render();
                }
            },

            mousemove: function mousemove(e) {
                this.currentPageX = e.pageX;
                this.currentPageY = e.pageY;
                this.currentEl = e.target;
                if (this.tooltip) {
                    this.tooltip.updatePosition(e.pageX, e.pageY);
                }
                this.updateDisplay();
            },

            updateDisplay: function updateDisplay() {
                var splist = this.splist,
                    spcount = splist.length,
                    needsRefresh = false,
                    offset = this.$canvas.offset(),
                    localX = this.currentPageX - offset.left,
                    localY = this.currentPageY - offset.top,
                    tooltiphtml,
                    sp,
                    i,
                    result,
                    changeEvent;
                if (!this.over) {
                    return;
                }
                for (i = 0; i < spcount; i++) {
                    sp = splist[i];
                    result = sp.setRegionHighlight(this.currentEl, localX, localY);
                    if (result) {
                        needsRefresh = true;
                    }
                }
                if (needsRefresh) {
                    changeEvent = $.Event('sparklineRegionChange');
                    changeEvent.sparklines = this.splist;
                    this.$el.trigger(changeEvent);
                    if (this.tooltip) {
                        tooltiphtml = '';
                        for (i = 0; i < spcount; i++) {
                            sp = splist[i];
                            tooltiphtml += sp.getCurrentRegionTooltip();
                        }
                        this.tooltip.setContent(tooltiphtml);
                    }
                    if (!this.disableHighlight) {
                        this.canvas.render();
                    }
                }
                if (result === null) {
                    this.mouseleave();
                }
            }
        });

        Tooltip = createClass({
            sizeStyle: 'position: static !important;' + 'display: block !important;' + 'visibility: hidden !important;' + 'float: left !important;',

            init: function init(options) {
                var tooltipClassname = options.get('tooltipClassname', 'jqstooltip'),
                    sizetipStyle = this.sizeStyle,
                    offset;
                this.container = options.get('tooltipContainer') || document.body;
                this.tooltipOffsetX = options.get('tooltipOffsetX', 10);
                this.tooltipOffsetY = options.get('tooltipOffsetY', 12);
                // remove any previous lingering tooltip
                $('#jqssizetip').remove();
                $('#jqstooltip').remove();
                this.sizetip = $('<div/>', {
                    id: 'jqssizetip',
                    style: sizetipStyle,
                    'class': tooltipClassname
                });
                this.tooltip = $('<div/>', {
                    id: 'jqstooltip',
                    'class': tooltipClassname
                }).appendTo(this.container);
                // account for the container's location
                offset = this.tooltip.offset();
                this.offsetLeft = offset.left;
                this.offsetTop = offset.top;
                this.hidden = true;
                $(window).unbind('resize.jqs scroll.jqs');
                $(window).bind('resize.jqs scroll.jqs', $.proxy(this.updateWindowDims, this));
                this.updateWindowDims();
            },

            updateWindowDims: function updateWindowDims() {
                this.scrollTop = $(window).scrollTop();
                this.scrollLeft = $(window).scrollLeft();
                this.scrollRight = this.scrollLeft + $(window).width();
                this.updatePosition();
            },

            getSize: function getSize(content) {
                this.sizetip.html(content).appendTo(this.container);
                this.width = this.sizetip.width() + 1;
                this.height = this.sizetip.height();
                this.sizetip.remove();
            },

            setContent: function setContent(content) {
                if (!content) {
                    this.tooltip.css('visibility', 'hidden');
                    this.hidden = true;
                    return;
                }
                this.getSize(content);
                this.tooltip.html(content).css({
                    'width': this.width,
                    'height': this.height,
                    'visibility': 'visible'
                });
                if (this.hidden) {
                    this.hidden = false;
                    this.updatePosition();
                }
            },

            updatePosition: function updatePosition(x, y) {
                if (x === undefined) {
                    if (this.mousex === undefined) {
                        return;
                    }
                    x = this.mousex - this.offsetLeft;
                    y = this.mousey - this.offsetTop;
                } else {
                    this.mousex = x = x - this.offsetLeft;
                    this.mousey = y = y - this.offsetTop;
                }
                if (!this.height || !this.width || this.hidden) {
                    return;
                }

                y -= this.height + this.tooltipOffsetY;
                x += this.tooltipOffsetX;

                if (y < this.scrollTop) {
                    y = this.scrollTop;
                }
                if (x < this.scrollLeft) {
                    x = this.scrollLeft;
                } else if (x + this.width > this.scrollRight) {
                    x = this.scrollRight - this.width;
                }

                this.tooltip.css({
                    'left': x,
                    'top': y
                });
            },

            remove: function remove() {
                this.tooltip.remove();
                this.sizetip.remove();
                this.sizetip = this.tooltip = undefined;
                $(window).unbind('resize.jqs scroll.jqs');
            }
        });

        initStyles = function initStyles() {
            addCSS(defaultStyles);
        };

        $(initStyles);

        pending = [];
        $.fn.sparkline = function (userValues, userOptions) {
            return this.each(function () {
                var options = new $.fn.sparkline.options(this, userOptions),
                    $this = $(this),
                    render,
                    i;
                render = function render() {
                    var values, width, height, tmp, mhandler, sp, vals;
                    if (userValues === 'html' || userValues === undefined) {
                        vals = this.getAttribute(options.get('tagValuesAttribute'));
                        if (vals === undefined || vals === null) {
                            vals = $this.html();
                        }
                        values = vals.replace(/(^\s*<!--)|(-->\s*$)|\s+/g, '').split(',');
                    } else {
                        values = userValues;
                    }

                    width = options.get('width') === 'auto' ? values.length * options.get('defaultPixelsPerValue') : options.get('width');
                    if (options.get('height') === 'auto') {
                        if (!options.get('composite') || !$.data(this, '_jqs_vcanvas')) {
                            // must be a better way to get the line height
                            tmp = document.createElement('span');
                            tmp.innerHTML = 'a';
                            $this.html(tmp);
                            height = $(tmp).innerHeight() || $(tmp).height();
                            $(tmp).remove();
                            tmp = null;
                        }
                    } else {
                        height = options.get('height');
                    }

                    if (!options.get('disableInteraction')) {
                        mhandler = $.data(this, '_jqs_mhandler');
                        if (!mhandler) {
                            mhandler = new MouseHandler(this, options);
                            $.data(this, '_jqs_mhandler', mhandler);
                        } else if (!options.get('composite')) {
                            mhandler.reset();
                        }
                    } else {
                        mhandler = false;
                    }

                    if (options.get('composite') && !$.data(this, '_jqs_vcanvas')) {
                        if (!$.data(this, '_jqs_errnotify')) {
                            window.alert('Attempted to attach a composite sparkline to an element with no existing sparkline');
                            $.data(this, '_jqs_errnotify', true);
                        }
                        return;
                    }

                    sp = new $.fn.sparkline[options.get('type')](this, values, options, width, height);

                    sp.render();

                    if (mhandler) {
                        mhandler.registerSparkline(sp);
                    }
                };
                if ($(this).html() && !options.get('disableHiddenCheck') && $(this).is(':hidden') || !$(this).parents('body').length) {
                    if (!options.get('composite') && $.data(this, '_jqs_pending')) {
                        // remove any existing references to the element
                        for (i = pending.length; i; i--) {
                            if (pending[i - 1][0] == this) {
                                pending.splice(i - 1, 1);
                            }
                        }
                    }
                    pending.push([this, render]);
                    $.data(this, '_jqs_pending', true);
                } else {
                    render.call(this);
                }
            });
        };

        $.fn.sparkline.defaults = getDefaults();

        $.sparkline_display_visible = function () {
            var el, i, pl;
            var done = [];
            for (i = 0, pl = pending.length; i < pl; i++) {
                el = pending[i][0];
                if ($(el).is(':visible') && !$(el).parents().is(':hidden')) {
                    pending[i][1].call(el);
                    $.data(pending[i][0], '_jqs_pending', false);
                    done.push(i);
                } else if (!$(el).closest('html').length && !$.data(el, '_jqs_pending')) {
                    // element has been inserted and removed from the DOM
                    // If it was not yet inserted into the dom then the .data request
                    // will return true.
                    // removing from the dom causes the data to be removed.
                    $.data(pending[i][0], '_jqs_pending', false);
                    done.push(i);
                }
            }
            for (i = done.length; i; i--) {
                pending.splice(done[i - 1], 1);
            }
        };

        /**
         * User option handler
         */
        $.fn.sparkline.options = createClass({
            init: function init(tag, userOptions) {
                var extendedOptions, defaults, base, tagOptionType;
                this.userOptions = userOptions = userOptions || {};
                this.tag = tag;
                this.tagValCache = {};
                defaults = $.fn.sparkline.defaults;
                base = defaults.common;
                this.tagOptionsPrefix = userOptions.enableTagOptions && (userOptions.tagOptionsPrefix || base.tagOptionsPrefix);

                tagOptionType = this.getTagSetting('type');
                if (tagOptionType === UNSET_OPTION) {
                    extendedOptions = defaults[userOptions.type || base.type];
                } else {
                    extendedOptions = defaults[tagOptionType];
                }
                this.mergedOptions = $.extend({}, base, extendedOptions, userOptions);
            },

            getTagSetting: function getTagSetting(key) {
                var prefix = this.tagOptionsPrefix,
                    val,
                    i,
                    pairs,
                    keyval;
                if (prefix === false || prefix === undefined) {
                    return UNSET_OPTION;
                }
                if (this.tagValCache.hasOwnProperty(key)) {
                    val = this.tagValCache.key;
                } else {
                    val = this.tag.getAttribute(prefix + key);
                    if (val === undefined || val === null) {
                        val = UNSET_OPTION;
                    } else if (val.substr(0, 1) === '[') {
                        val = val.substr(1, val.length - 2).split(',');
                        for (i = val.length; i--;) {
                            val[i] = normalizeValue(val[i].replace(/(^\s*)|(\s*$)/g, ''));
                        }
                    } else if (val.substr(0, 1) === '{') {
                        pairs = val.substr(1, val.length - 2).split(',');
                        val = {};
                        for (i = pairs.length; i--;) {
                            keyval = pairs[i].split(':', 2);
                            val[keyval[0].replace(/(^\s*)|(\s*$)/g, '')] = normalizeValue(keyval[1].replace(/(^\s*)|(\s*$)/g, ''));
                        }
                    } else {
                        val = normalizeValue(val);
                    }
                    this.tagValCache.key = val;
                }
                return val;
            },

            get: function get(key, defaultval) {
                var tagOption = this.getTagSetting(key),
                    result;
                if (tagOption !== UNSET_OPTION) {
                    return tagOption;
                }
                return (result = this.mergedOptions[key]) === undefined ? defaultval : result;
            }
        });

        $.fn.sparkline._base = createClass({
            disabled: false,

            init: function init(el, values, options, width, height) {
                this.el = el;
                this.$el = $(el);
                this.values = values;
                this.options = options;
                this.width = width;
                this.height = height;
                this.currentRegion = undefined;
            },

            /**
             * Setup the canvas
             */
            initTarget: function initTarget() {
                var interactive = !this.options.get('disableInteraction');
                if (!(this.target = this.$el.simpledraw(this.width, this.height, this.options.get('composite'), interactive))) {
                    this.disabled = true;
                } else {
                    this.canvasWidth = this.target.pixelWidth;
                    this.canvasHeight = this.target.pixelHeight;
                }
            },

            /**
             * Actually render the chart to the canvas
             */
            render: function render() {
                if (this.disabled) {
                    this.el.innerHTML = '';
                    return false;
                }
                return true;
            },

            /**
             * Return a region id for a given x/y co-ordinate
             */
            getRegion: function getRegion(x, y) {},

            /**
             * Highlight an item based on the moused-over x,y co-ordinate
             */
            setRegionHighlight: function setRegionHighlight(el, x, y) {
                var currentRegion = this.currentRegion,
                    highlightEnabled = !this.options.get('disableHighlight'),
                    newRegion;
                if (x > this.canvasWidth || y > this.canvasHeight || x < 0 || y < 0) {
                    return null;
                }
                newRegion = this.getRegion(el, x, y);
                if (currentRegion !== newRegion) {
                    if (currentRegion !== undefined && highlightEnabled) {
                        this.removeHighlight();
                    }
                    this.currentRegion = newRegion;
                    if (newRegion !== undefined && highlightEnabled) {
                        this.renderHighlight();
                    }
                    return true;
                }
                return false;
            },

            /**
             * Reset any currently highlighted item
             */
            clearRegionHighlight: function clearRegionHighlight() {
                if (this.currentRegion !== undefined) {
                    this.removeHighlight();
                    this.currentRegion = undefined;
                    return true;
                }
                return false;
            },

            renderHighlight: function renderHighlight() {
                this.changeHighlight(true);
            },

            removeHighlight: function removeHighlight() {
                this.changeHighlight(false);
            },

            changeHighlight: function changeHighlight(highlight) {},

            /**
             * Fetch the HTML to display as a tooltip
             */
            getCurrentRegionTooltip: function getCurrentRegionTooltip() {
                var options = this.options,
                    header = '',
                    entries = [],
                    fields,
                    formats,
                    formatlen,
                    fclass,
                    text,
                    i,
                    showFields,
                    showFieldsKey,
                    newFields,
                    fv,
                    formatter,
                    format,
                    fieldlen,
                    j;
                if (this.currentRegion === undefined) {
                    return '';
                }
                fields = this.getCurrentRegionFields();
                formatter = options.get('tooltipFormatter');
                if (formatter) {
                    return formatter(this, options, fields);
                }
                if (options.get('tooltipChartTitle')) {
                    header += '<div class="jqs jqstitle">' + options.get('tooltipChartTitle') + '</div>\n';
                }
                formats = this.options.get('tooltipFormat');
                if (!formats) {
                    return '';
                }
                if (!$.isArray(formats)) {
                    formats = [formats];
                }
                if (!$.isArray(fields)) {
                    fields = [fields];
                }
                showFields = this.options.get('tooltipFormatFieldlist');
                showFieldsKey = this.options.get('tooltipFormatFieldlistKey');
                if (showFields && showFieldsKey) {
                    // user-selected ordering of fields
                    newFields = [];
                    for (i = fields.length; i--;) {
                        fv = fields[i][showFieldsKey];
                        if ((j = $.inArray(fv, showFields)) != -1) {
                            newFields[j] = fields[i];
                        }
                    }
                    fields = newFields;
                }
                formatlen = formats.length;
                fieldlen = fields.length;
                for (i = 0; i < formatlen; i++) {
                    format = formats[i];
                    if (typeof format === 'string') {
                        format = new SPFormat(format);
                    }
                    fclass = format.fclass || 'jqsfield';
                    for (j = 0; j < fieldlen; j++) {
                        if (!fields[j].isNull || !options.get('tooltipSkipNull')) {
                            $.extend(fields[j], {
                                prefix: options.get('tooltipPrefix'),
                                suffix: options.get('tooltipSuffix')
                            });
                            text = format.render(fields[j], options.get('tooltipValueLookups'), options);
                            entries.push('<div class="' + fclass + '">' + text + '</div>');
                        }
                    }
                }
                if (entries.length) {
                    return header + entries.join('\n');
                }
                return '';
            },

            getCurrentRegionFields: function getCurrentRegionFields() {},

            calcHighlightColor: function calcHighlightColor(color, options) {
                var highlightColor = options.get('highlightColor'),
                    lighten = options.get('highlightLighten'),
                    parse,
                    mult,
                    rgbnew,
                    i;
                if (highlightColor) {
                    return highlightColor;
                }
                if (lighten) {
                    // extract RGB values
                    parse = /^#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec(color) || /^#([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/i.exec(color);
                    if (parse) {
                        rgbnew = [];
                        mult = color.length === 4 ? 16 : 1;
                        for (i = 0; i < 3; i++) {
                            rgbnew[i] = clipval(Math.round(parseInt(parse[i + 1], 16) * mult * lighten), 0, 255);
                        }
                        return 'rgb(' + rgbnew.join(',') + ')';
                    }
                }
                return color;
            }

        });

        barHighlightMixin = {
            changeHighlight: function changeHighlight(highlight) {
                var currentRegion = this.currentRegion,
                    target = this.target,
                    shapeids = this.regionShapes[currentRegion],
                    newShapes;
                // will be null if the region value was null
                if (shapeids) {
                    newShapes = this.renderRegion(currentRegion, highlight);
                    if ($.isArray(newShapes) || $.isArray(shapeids)) {
                        target.replaceWithShapes(shapeids, newShapes);
                        this.regionShapes[currentRegion] = $.map(newShapes, function (newShape) {
                            return newShape.id;
                        });
                    } else {
                        target.replaceWithShape(shapeids, newShapes);
                        this.regionShapes[currentRegion] = newShapes.id;
                    }
                }
            },

            render: function render() {
                var values = this.values,
                    target = this.target,
                    regionShapes = this.regionShapes,
                    shapes,
                    ids,
                    i,
                    j;

                if (!this.cls._super.render.call(this)) {
                    return;
                }
                for (i = values.length; i--;) {
                    shapes = this.renderRegion(i);
                    if (shapes) {
                        if ($.isArray(shapes)) {
                            ids = [];
                            for (j = shapes.length; j--;) {
                                shapes[j].append();
                                ids.push(shapes[j].id);
                            }
                            regionShapes[i] = ids;
                        } else {
                            shapes.append();
                            regionShapes[i] = shapes.id; // store just the shapeid
                        }
                    } else {
                        // null value
                        regionShapes[i] = null;
                    }
                }
                target.render();
            }
        };

        /**
         * Line charts
         */
        $.fn.sparkline.line = line = createClass($.fn.sparkline._base, {
            type: 'line',

            init: function init(el, values, options, width, height) {
                line._super.init.call(this, el, values, options, width, height);
                this.vertices = [];
                this.regionMap = [];
                this.xvalues = [];
                this.yvalues = [];
                this.yminmax = [];
                this.hightlightSpotId = null;
                this.lastShapeId = null;
                this.initTarget();
            },

            getRegion: function getRegion(el, x, y) {
                var i,
                    regionMap = this.regionMap; // maps regions to value positions
                for (i = regionMap.length; i--;) {
                    if (regionMap[i] !== null && x >= regionMap[i][0] && x <= regionMap[i][1]) {
                        return regionMap[i][2];
                    }
                }
                return undefined;
            },

            getCurrentRegionFields: function getCurrentRegionFields() {
                var currentRegion = this.currentRegion;
                return {
                    isNull: this.yvalues[currentRegion] === null,
                    x: this.xvalues[currentRegion],
                    y: this.yvalues[currentRegion],
                    color: this.options.get('lineColor'),
                    fillColor: this.options.get('fillColor'),
                    offset: currentRegion
                };
            },

            renderHighlight: function renderHighlight() {
                var currentRegion = this.currentRegion,
                    target = this.target,
                    vertex = this.vertices[currentRegion],
                    options = this.options,
                    spotRadius = options.get('spotRadius'),
                    highlightSpotColor = options.get('highlightSpotColor'),
                    highlightLineColor = options.get('highlightLineColor'),
                    highlightSpot,
                    highlightLine;

                if (!vertex) {
                    return;
                }
                if (spotRadius && highlightSpotColor) {
                    highlightSpot = target.drawCircle(vertex[0], vertex[1], spotRadius, undefined, highlightSpotColor);
                    this.highlightSpotId = highlightSpot.id;
                    target.insertAfterShape(this.lastShapeId, highlightSpot);
                }
                if (highlightLineColor) {
                    highlightLine = target.drawLine(vertex[0], this.canvasTop, vertex[0], this.canvasTop + this.canvasHeight, highlightLineColor);
                    this.highlightLineId = highlightLine.id;
                    target.insertAfterShape(this.lastShapeId, highlightLine);
                }
            },

            removeHighlight: function removeHighlight() {
                var target = this.target;
                if (this.highlightSpotId) {
                    target.removeShapeId(this.highlightSpotId);
                    this.highlightSpotId = null;
                }
                if (this.highlightLineId) {
                    target.removeShapeId(this.highlightLineId);
                    this.highlightLineId = null;
                }
            },

            scanValues: function scanValues() {
                var values = this.values,
                    valcount = values.length,
                    xvalues = this.xvalues,
                    yvalues = this.yvalues,
                    yminmax = this.yminmax,
                    i,
                    val,
                    isStr,
                    isArray,
                    sp;
                for (i = 0; i < valcount; i++) {
                    val = values[i];
                    isStr = typeof values[i] === 'string';
                    isArray = _typeof(values[i]) === 'object' && values[i] instanceof Array;
                    sp = isStr && values[i].split(':');
                    if (isStr && sp.length === 2) {
                        // x:y
                        xvalues.push(Number(sp[0]));
                        yvalues.push(Number(sp[1]));
                        yminmax.push(Number(sp[1]));
                    } else if (isArray) {
                        xvalues.push(val[0]);
                        yvalues.push(val[1]);
                        yminmax.push(val[1]);
                    } else {
                        xvalues.push(i);
                        if (values[i] === null || values[i] === 'null') {
                            yvalues.push(null);
                        } else {
                            yvalues.push(Number(val));
                            yminmax.push(Number(val));
                        }
                    }
                }
                if (this.options.get('xvalues')) {
                    xvalues = this.options.get('xvalues');
                }

                this.maxy = this.maxyorg = Math.max.apply(Math, yminmax);
                this.miny = this.minyorg = Math.min.apply(Math, yminmax);

                this.maxx = Math.max.apply(Math, xvalues);
                this.minx = Math.min.apply(Math, xvalues);

                this.xvalues = xvalues;
                this.yvalues = yvalues;
                this.yminmax = yminmax;
            },

            processRangeOptions: function processRangeOptions() {
                var options = this.options,
                    normalRangeMin = options.get('normalRangeMin'),
                    normalRangeMax = options.get('normalRangeMax');

                if (normalRangeMin !== undefined) {
                    if (normalRangeMin < this.miny) {
                        this.miny = normalRangeMin;
                    }
                    if (normalRangeMax > this.maxy) {
                        this.maxy = normalRangeMax;
                    }
                }
                if (options.get('chartRangeMin') !== undefined && (options.get('chartRangeClip') || options.get('chartRangeMin') < this.miny)) {
                    this.miny = options.get('chartRangeMin');
                }
                if (options.get('chartRangeMax') !== undefined && (options.get('chartRangeClip') || options.get('chartRangeMax') > this.maxy)) {
                    this.maxy = options.get('chartRangeMax');
                }
                if (options.get('chartRangeMinX') !== undefined && (options.get('chartRangeClipX') || options.get('chartRangeMinX') < this.minx)) {
                    this.minx = options.get('chartRangeMinX');
                }
                if (options.get('chartRangeMaxX') !== undefined && (options.get('chartRangeClipX') || options.get('chartRangeMaxX') > this.maxx)) {
                    this.maxx = options.get('chartRangeMaxX');
                }
            },

            drawNormalRange: function drawNormalRange(canvasLeft, canvasTop, canvasHeight, canvasWidth, rangey) {
                var normalRangeMin = this.options.get('normalRangeMin'),
                    normalRangeMax = this.options.get('normalRangeMax'),
                    ytop = canvasTop + Math.round(canvasHeight - canvasHeight * ((normalRangeMax - this.miny) / rangey)),
                    height = Math.round(canvasHeight * (normalRangeMax - normalRangeMin) / rangey);
                this.target.drawRect(canvasLeft, ytop, canvasWidth, height, undefined, this.options.get('normalRangeColor')).append();
            },

            render: function render() {
                var options = this.options,
                    target = this.target,
                    canvasWidth = this.canvasWidth,
                    canvasHeight = this.canvasHeight,
                    vertices = this.vertices,
                    spotRadius = options.get('spotRadius'),
                    regionMap = this.regionMap,
                    rangex,
                    rangey,
                    yvallast,
                    canvasTop,
                    canvasLeft,
                    vertex,
                    path,
                    paths,
                    x,
                    y,
                    xnext,
                    xpos,
                    xposnext,
                    last,
                    next,
                    yvalcount,
                    lineShapes,
                    fillShapes,
                    plen,
                    valueSpots,
                    hlSpotsEnabled,
                    color,
                    xvalues,
                    yvalues,
                    i;

                if (!line._super.render.call(this)) {
                    return;
                }

                this.scanValues();
                this.processRangeOptions();

                xvalues = this.xvalues;
                yvalues = this.yvalues;

                if (!this.yminmax.length || this.yvalues.length < 2) {
                    // empty or all null valuess
                    return;
                }

                canvasTop = canvasLeft = 0;

                rangex = this.maxx - this.minx === 0 ? 1 : this.maxx - this.minx;
                rangey = this.maxy - this.miny === 0 ? 1 : this.maxy - this.miny;
                yvallast = this.yvalues.length - 1;

                if (spotRadius && (canvasWidth < spotRadius * 4 || canvasHeight < spotRadius * 4)) {
                    spotRadius = 0;
                }
                if (spotRadius) {
                    // adjust the canvas size as required so that spots will fit
                    hlSpotsEnabled = options.get('highlightSpotColor') && !options.get('disableInteraction');
                    if (hlSpotsEnabled || options.get('minSpotColor') || options.get('spotColor') && yvalues[yvallast] === this.miny) {
                        canvasHeight -= Math.ceil(spotRadius);
                    }
                    if (hlSpotsEnabled || options.get('maxSpotColor') || options.get('spotColor') && yvalues[yvallast] === this.maxy) {
                        canvasHeight -= Math.ceil(spotRadius);
                        canvasTop += Math.ceil(spotRadius);
                    }
                    if (hlSpotsEnabled || (options.get('minSpotColor') || options.get('maxSpotColor')) && (yvalues[0] === this.miny || yvalues[0] === this.maxy)) {
                        canvasLeft += Math.ceil(spotRadius);
                        canvasWidth -= Math.ceil(spotRadius);
                    }
                    if (hlSpotsEnabled || options.get('spotColor') || options.get('minSpotColor') || options.get('maxSpotColor') && (yvalues[yvallast] === this.miny || yvalues[yvallast] === this.maxy)) {
                        canvasWidth -= Math.ceil(spotRadius);
                    }
                }

                canvasHeight--;

                if (options.get('normalRangeMin') !== undefined && !options.get('drawNormalOnTop')) {
                    this.drawNormalRange(canvasLeft, canvasTop, canvasHeight, canvasWidth, rangey);
                }

                path = [];
                paths = [path];
                last = next = null;
                yvalcount = yvalues.length;
                for (i = 0; i < yvalcount; i++) {
                    x = xvalues[i];
                    xnext = xvalues[i + 1];
                    y = yvalues[i];
                    xpos = canvasLeft + Math.round((x - this.minx) * (canvasWidth / rangex));
                    xposnext = i < yvalcount - 1 ? canvasLeft + Math.round((xnext - this.minx) * (canvasWidth / rangex)) : canvasWidth;
                    next = xpos + (xposnext - xpos) / 2;
                    regionMap[i] = [last || 0, next, i];
                    last = next;
                    if (y === null) {
                        if (i) {
                            if (yvalues[i - 1] !== null) {
                                path = [];
                                paths.push(path);
                            }
                            vertices.push(null);
                        }
                    } else {
                        if (y < this.miny) {
                            y = this.miny;
                        }
                        if (y > this.maxy) {
                            y = this.maxy;
                        }
                        if (!path.length) {
                            // previous value was null
                            path.push([xpos, canvasTop + canvasHeight]);
                        }
                        vertex = [xpos, canvasTop + Math.round(canvasHeight - canvasHeight * ((y - this.miny) / rangey))];
                        path.push(vertex);
                        vertices.push(vertex);
                    }
                }

                lineShapes = [];
                fillShapes = [];
                plen = paths.length;
                for (i = 0; i < plen; i++) {
                    path = paths[i];
                    if (path.length) {
                        if (options.get('fillColor')) {
                            path.push([path[path.length - 1][0], canvasTop + canvasHeight]);
                            fillShapes.push(path.slice(0));
                            path.pop();
                        }
                        // if there's only a single point in this path, then we want to display it
                        // as a vertical line which means we keep path[0]  as is
                        if (path.length > 2) {
                            // else we want the first value
                            path[0] = [path[0][0], path[1][1]];
                        }
                        lineShapes.push(path);
                    }
                }

                // draw the fill first, then optionally the normal range, then the line on top of that
                plen = fillShapes.length;
                for (i = 0; i < plen; i++) {
                    target.drawShape(fillShapes[i], options.get('fillColor'), options.get('fillColor')).append();
                }

                if (options.get('normalRangeMin') !== undefined && options.get('drawNormalOnTop')) {
                    this.drawNormalRange(canvasLeft, canvasTop, canvasHeight, canvasWidth, rangey);
                }

                plen = lineShapes.length;
                for (i = 0; i < plen; i++) {
                    target.drawShape(lineShapes[i], options.get('lineColor'), undefined, options.get('lineWidth')).append();
                }

                if (spotRadius && options.get('valueSpots')) {
                    valueSpots = options.get('valueSpots');
                    if (valueSpots.get === undefined) {
                        valueSpots = new RangeMap(valueSpots);
                    }
                    for (i = 0; i < yvalcount; i++) {
                        color = valueSpots.get(yvalues[i]);
                        if (color) {
                            target.drawCircle(canvasLeft + Math.round((xvalues[i] - this.minx) * (canvasWidth / rangex)), canvasTop + Math.round(canvasHeight - canvasHeight * ((yvalues[i] - this.miny) / rangey)), spotRadius, undefined, color).append();
                        }
                    }
                }
                if (spotRadius && options.get('spotColor') && yvalues[yvallast] !== null) {
                    target.drawCircle(canvasLeft + Math.round((xvalues[xvalues.length - 1] - this.minx) * (canvasWidth / rangex)), canvasTop + Math.round(canvasHeight - canvasHeight * ((yvalues[yvallast] - this.miny) / rangey)), spotRadius, undefined, options.get('spotColor')).append();
                }
                if (this.maxy !== this.minyorg) {
                    if (spotRadius && options.get('minSpotColor')) {
                        x = xvalues[$.inArray(this.minyorg, yvalues)];
                        target.drawCircle(canvasLeft + Math.round((x - this.minx) * (canvasWidth / rangex)), canvasTop + Math.round(canvasHeight - canvasHeight * ((this.minyorg - this.miny) / rangey)), spotRadius, undefined, options.get('minSpotColor')).append();
                    }
                    if (spotRadius && options.get('maxSpotColor')) {
                        x = xvalues[$.inArray(this.maxyorg, yvalues)];
                        target.drawCircle(canvasLeft + Math.round((x - this.minx) * (canvasWidth / rangex)), canvasTop + Math.round(canvasHeight - canvasHeight * ((this.maxyorg - this.miny) / rangey)), spotRadius, undefined, options.get('maxSpotColor')).append();
                    }
                }

                this.lastShapeId = target.getLastShapeId();
                this.canvasTop = canvasTop;
                target.render();
            }
        });

        /**
         * Bar charts
         */
        $.fn.sparkline.bar = bar = createClass($.fn.sparkline._base, barHighlightMixin, {
            type: 'bar',

            init: function init(el, values, options, width, height) {
                var barWidth = parseInt(options.get('barWidth'), 10),
                    barSpacing = parseInt(options.get('barSpacing'), 10),
                    chartRangeMin = options.get('chartRangeMin'),
                    chartRangeMax = options.get('chartRangeMax'),
                    chartRangeClip = options.get('chartRangeClip'),
                    stackMin = Infinity,
                    stackMax = -Infinity,
                    isStackString,
                    groupMin,
                    groupMax,
                    stackRanges,
                    numValues,
                    i,
                    vlen,
                    range,
                    zeroAxis,
                    xaxisOffset,
                    min,
                    max,
                    clipMin,
                    clipMax,
                    stacked,
                    vlist,
                    j,
                    slen,
                    svals,
                    val,
                    yoffset,
                    yMaxCalc,
                    canvasHeightEf;
                bar._super.init.call(this, el, values, options, width, height);

                // scan values to determine whether to stack bars
                for (i = 0, vlen = values.length; i < vlen; i++) {
                    val = values[i];
                    isStackString = typeof val === 'string' && val.indexOf(':') > -1;
                    if (isStackString || $.isArray(val)) {
                        stacked = true;
                        if (isStackString) {
                            val = values[i] = normalizeValues(val.split(':'));
                        }
                        val = remove(val, null); // min/max will treat null as zero
                        groupMin = Math.min.apply(Math, val);
                        groupMax = Math.max.apply(Math, val);
                        if (groupMin < stackMin) {
                            stackMin = groupMin;
                        }
                        if (groupMax > stackMax) {
                            stackMax = groupMax;
                        }
                    }
                }

                this.stacked = stacked;
                this.regionShapes = {};
                this.barWidth = barWidth;
                this.barSpacing = barSpacing;
                this.totalBarWidth = barWidth + barSpacing;
                this.width = width = values.length * barWidth + (values.length - 1) * barSpacing;

                this.initTarget();

                if (chartRangeClip) {
                    clipMin = chartRangeMin === undefined ? -Infinity : chartRangeMin;
                    clipMax = chartRangeMax === undefined ? Infinity : chartRangeMax;
                }

                numValues = [];
                stackRanges = stacked ? [] : numValues;
                var stackTotals = [];
                var stackRangesNeg = [];
                for (i = 0, vlen = values.length; i < vlen; i++) {
                    if (stacked) {
                        vlist = values[i];
                        values[i] = svals = [];
                        stackTotals[i] = 0;
                        stackRanges[i] = stackRangesNeg[i] = 0;
                        for (j = 0, slen = vlist.length; j < slen; j++) {
                            val = svals[j] = chartRangeClip ? clipval(vlist[j], clipMin, clipMax) : vlist[j];
                            if (val !== null) {
                                if (val > 0) {
                                    stackTotals[i] += val;
                                }
                                if (stackMin < 0 && stackMax > 0) {
                                    if (val < 0) {
                                        stackRangesNeg[i] += Math.abs(val);
                                    } else {
                                        stackRanges[i] += val;
                                    }
                                } else {
                                    stackRanges[i] += Math.abs(val - (val < 0 ? stackMax : stackMin));
                                }
                                numValues.push(val);
                            }
                        }
                    } else {
                        val = chartRangeClip ? clipval(values[i], clipMin, clipMax) : values[i];
                        val = values[i] = normalizeValue(val);
                        if (val !== null) {
                            numValues.push(val);
                        }
                    }
                }
                this.max = max = Math.max.apply(Math, numValues);
                this.min = min = Math.min.apply(Math, numValues);
                this.stackMax = stackMax = stacked ? Math.max.apply(Math, stackTotals) : max;
                this.stackMin = stackMin = stacked ? Math.min.apply(Math, numValues) : min;

                if (options.get('chartRangeMin') !== undefined && (options.get('chartRangeClip') || options.get('chartRangeMin') < min)) {
                    min = options.get('chartRangeMin');
                }
                if (options.get('chartRangeMax') !== undefined && (options.get('chartRangeClip') || options.get('chartRangeMax') > max)) {
                    max = options.get('chartRangeMax');
                }

                this.zeroAxis = zeroAxis = options.get('zeroAxis', true);
                if (min <= 0 && max >= 0 && zeroAxis) {
                    xaxisOffset = 0;
                } else if (zeroAxis == false) {
                    xaxisOffset = min;
                } else if (min > 0) {
                    xaxisOffset = min;
                } else {
                    xaxisOffset = max;
                }
                this.xaxisOffset = xaxisOffset;

                range = stacked ? Math.max.apply(Math, stackRanges) + Math.max.apply(Math, stackRangesNeg) : max - min;

                // as we plot zero/min values a single pixel line, we add a pixel to all other
                // values - Reduce the effective canvas size to suit
                this.canvasHeightEf = zeroAxis && min < 0 ? this.canvasHeight - 2 : this.canvasHeight - 1;

                if (min < xaxisOffset) {
                    yMaxCalc = stacked && max >= 0 ? stackMax : max;
                    yoffset = (yMaxCalc - xaxisOffset) / range * this.canvasHeight;
                    if (yoffset !== Math.ceil(yoffset)) {
                        this.canvasHeightEf -= 2;
                        yoffset = Math.ceil(yoffset);
                    }
                } else {
                    yoffset = this.canvasHeight;
                }
                this.yoffset = yoffset;

                if ($.isArray(options.get('colorMap'))) {
                    this.colorMapByIndex = options.get('colorMap');
                    this.colorMapByValue = null;
                } else {
                    this.colorMapByIndex = null;
                    this.colorMapByValue = options.get('colorMap');
                    if (this.colorMapByValue && this.colorMapByValue.get === undefined) {
                        this.colorMapByValue = new RangeMap(this.colorMapByValue);
                    }
                }

                this.range = range;
            },

            getRegion: function getRegion(el, x, y) {
                var result = Math.floor(x / this.totalBarWidth);
                return result < 0 || result >= this.values.length ? undefined : result;
            },

            getCurrentRegionFields: function getCurrentRegionFields() {
                var currentRegion = this.currentRegion,
                    values = ensureArray(this.values[currentRegion]),
                    result = [],
                    value,
                    i;
                for (i = values.length; i--;) {
                    value = values[i];
                    result.push({
                        isNull: value === null,
                        value: value,
                        color: this.calcColor(i, value, currentRegion),
                        offset: currentRegion
                    });
                }
                return result;
            },

            calcColor: function calcColor(stacknum, value, valuenum) {
                var colorMapByIndex = this.colorMapByIndex,
                    colorMapByValue = this.colorMapByValue,
                    options = this.options,
                    color,
                    newColor;
                if (this.stacked) {
                    color = options.get('stackedBarColor');
                } else {
                    color = value < 0 ? options.get('negBarColor') : options.get('barColor');
                }
                if (value === 0 && options.get('zeroColor') !== undefined) {
                    color = options.get('zeroColor');
                }
                if (colorMapByValue && (newColor = colorMapByValue.get(value))) {
                    color = newColor;
                } else if (colorMapByIndex && colorMapByIndex.length > valuenum) {
                    color = colorMapByIndex[valuenum];
                }
                return $.isArray(color) ? color[stacknum % color.length] : color;
            },

            /**
             * Render bar(s) for a region
             */
            renderRegion: function renderRegion(valuenum, highlight) {
                var vals = this.values[valuenum],
                    options = this.options,
                    xaxisOffset = this.xaxisOffset,
                    result = [],
                    range = this.range,
                    stacked = this.stacked,
                    target = this.target,
                    x = valuenum * this.totalBarWidth,
                    canvasHeightEf = this.canvasHeightEf,
                    yoffset = this.yoffset,
                    y,
                    height,
                    color,
                    isNull,
                    yoffsetNeg,
                    i,
                    valcount,
                    val,
                    minPlotted,
                    allMin;

                vals = $.isArray(vals) ? vals : [vals];
                valcount = vals.length;
                val = vals[0];
                isNull = all(null, vals);
                allMin = all(xaxisOffset, vals, true);

                if (isNull) {
                    if (options.get('nullColor')) {
                        color = highlight ? options.get('nullColor') : this.calcHighlightColor(options.get('nullColor'), options);
                        y = yoffset > 0 ? yoffset - 1 : yoffset;
                        return target.drawRect(x, y, this.barWidth - 1, 0, color, color);
                    } else {
                        return undefined;
                    }
                }
                yoffsetNeg = yoffset;
                for (i = 0; i < valcount; i++) {
                    val = vals[i];

                    if (stacked && val === xaxisOffset) {
                        if (!allMin || minPlotted) {
                            continue;
                        }
                        minPlotted = true;
                    }

                    if (range > 0) {
                        height = Math.floor(canvasHeightEf * (Math.abs(val - xaxisOffset) / range)) + 1;
                    } else {
                        height = 1;
                    }
                    if (val < xaxisOffset || val === xaxisOffset && yoffset === 0) {
                        y = yoffsetNeg;
                        yoffsetNeg += height;
                    } else {
                        y = yoffset - height;
                        yoffset -= height;
                    }
                    color = this.calcColor(i, val, valuenum);
                    if (highlight) {
                        color = this.calcHighlightColor(color, options);
                    }
                    result.push(target.drawRect(x, y, this.barWidth - 1, height - 1, color, color));
                }
                if (result.length === 1) {
                    return result[0];
                }
                return result;
            }
        });

        /**
         * Tristate charts
         */
        $.fn.sparkline.tristate = tristate = createClass($.fn.sparkline._base, barHighlightMixin, {
            type: 'tristate',

            init: function init(el, values, options, width, height) {
                var barWidth = parseInt(options.get('barWidth'), 10),
                    barSpacing = parseInt(options.get('barSpacing'), 10);
                tristate._super.init.call(this, el, values, options, width, height);

                this.regionShapes = {};
                this.barWidth = barWidth;
                this.barSpacing = barSpacing;
                this.totalBarWidth = barWidth + barSpacing;
                this.values = $.map(values, Number);
                this.width = width = values.length * barWidth + (values.length - 1) * barSpacing;

                if ($.isArray(options.get('colorMap'))) {
                    this.colorMapByIndex = options.get('colorMap');
                    this.colorMapByValue = null;
                } else {
                    this.colorMapByIndex = null;
                    this.colorMapByValue = options.get('colorMap');
                    if (this.colorMapByValue && this.colorMapByValue.get === undefined) {
                        this.colorMapByValue = new RangeMap(this.colorMapByValue);
                    }
                }
                this.initTarget();
            },

            getRegion: function getRegion(el, x, y) {
                return Math.floor(x / this.totalBarWidth);
            },

            getCurrentRegionFields: function getCurrentRegionFields() {
                var currentRegion = this.currentRegion;
                return {
                    isNull: this.values[currentRegion] === undefined,
                    value: this.values[currentRegion],
                    color: this.calcColor(this.values[currentRegion], currentRegion),
                    offset: currentRegion
                };
            },

            calcColor: function calcColor(value, valuenum) {
                var values = this.values,
                    options = this.options,
                    colorMapByIndex = this.colorMapByIndex,
                    colorMapByValue = this.colorMapByValue,
                    color,
                    newColor;

                if (colorMapByValue && (newColor = colorMapByValue.get(value))) {
                    color = newColor;
                } else if (colorMapByIndex && colorMapByIndex.length > valuenum) {
                    color = colorMapByIndex[valuenum];
                } else if (values[valuenum] < 0) {
                    color = options.get('negBarColor');
                } else if (values[valuenum] > 0) {
                    color = options.get('posBarColor');
                } else {
                    color = options.get('zeroBarColor');
                }
                return color;
            },

            renderRegion: function renderRegion(valuenum, highlight) {
                var values = this.values,
                    options = this.options,
                    target = this.target,
                    canvasHeight,
                    height,
                    halfHeight,
                    x,
                    y,
                    color;

                canvasHeight = target.pixelHeight;
                halfHeight = Math.round(canvasHeight / 2);

                x = valuenum * this.totalBarWidth;
                if (values[valuenum] < 0) {
                    y = halfHeight;
                    height = halfHeight - 1;
                } else if (values[valuenum] > 0) {
                    y = 0;
                    height = halfHeight - 1;
                } else {
                    y = halfHeight - 1;
                    height = 2;
                }
                color = this.calcColor(values[valuenum], valuenum);
                if (color === null) {
                    return;
                }
                if (highlight) {
                    color = this.calcHighlightColor(color, options);
                }
                return target.drawRect(x, y, this.barWidth - 1, height - 1, color, color);
            }
        });

        /**
         * Discrete charts
         */
        $.fn.sparkline.discrete = discrete = createClass($.fn.sparkline._base, barHighlightMixin, {
            type: 'discrete',

            init: function init(el, values, options, width, height) {
                discrete._super.init.call(this, el, values, options, width, height);

                this.regionShapes = {};
                this.values = values = $.map(values, Number);
                this.min = Math.min.apply(Math, values);
                this.max = Math.max.apply(Math, values);
                this.range = this.max - this.min;
                this.width = width = options.get('width') === 'auto' ? values.length * 2 : this.width;
                this.interval = Math.floor(width / values.length);
                this.itemWidth = width / values.length;
                if (options.get('chartRangeMin') !== undefined && (options.get('chartRangeClip') || options.get('chartRangeMin') < this.min)) {
                    this.min = options.get('chartRangeMin');
                }
                if (options.get('chartRangeMax') !== undefined && (options.get('chartRangeClip') || options.get('chartRangeMax') > this.max)) {
                    this.max = options.get('chartRangeMax');
                }
                this.initTarget();
                if (this.target) {
                    this.lineHeight = options.get('lineHeight') === 'auto' ? Math.round(this.canvasHeight * 0.3) : options.get('lineHeight');
                }
            },

            getRegion: function getRegion(el, x, y) {
                return Math.floor(x / this.itemWidth);
            },

            getCurrentRegionFields: function getCurrentRegionFields() {
                var currentRegion = this.currentRegion;
                return {
                    isNull: this.values[currentRegion] === undefined,
                    value: this.values[currentRegion],
                    offset: currentRegion
                };
            },

            renderRegion: function renderRegion(valuenum, highlight) {
                var values = this.values,
                    options = this.options,
                    min = this.min,
                    max = this.max,
                    range = this.range,
                    interval = this.interval,
                    target = this.target,
                    canvasHeight = this.canvasHeight,
                    lineHeight = this.lineHeight,
                    pheight = canvasHeight - lineHeight,
                    ytop,
                    val,
                    color,
                    x;

                val = clipval(values[valuenum], min, max);
                x = valuenum * interval;
                ytop = Math.round(pheight - pheight * ((val - min) / range));
                color = options.get('thresholdColor') && val < options.get('thresholdValue') ? options.get('thresholdColor') : options.get('lineColor');
                if (highlight) {
                    color = this.calcHighlightColor(color, options);
                }
                return target.drawLine(x, ytop, x, ytop + lineHeight, color);
            }
        });

        /**
         * Bullet charts
         */
        $.fn.sparkline.bullet = bullet = createClass($.fn.sparkline._base, {
            type: 'bullet',

            init: function init(el, values, options, width, height) {
                var min, max, vals;
                bullet._super.init.call(this, el, values, options, width, height);

                // values: target, performance, range1, range2, range3
                this.values = values = normalizeValues(values);
                // target or performance could be null
                vals = values.slice();
                vals[0] = vals[0] === null ? vals[2] : vals[0];
                vals[1] = values[1] === null ? vals[2] : vals[1];
                min = Math.min.apply(Math, values);
                max = Math.max.apply(Math, values);
                if (options.get('base') === undefined) {
                    min = min < 0 ? min : 0;
                } else {
                    min = options.get('base');
                }
                this.min = min;
                this.max = max;
                this.range = max - min;
                this.shapes = {};
                this.valueShapes = {};
                this.regiondata = {};
                this.width = width = options.get('width') === 'auto' ? '4.0em' : width;
                this.target = this.$el.simpledraw(width, height, options.get('composite'));
                if (!values.length) {
                    this.disabled = true;
                }
                this.initTarget();
            },

            getRegion: function getRegion(el, x, y) {
                var shapeid = this.target.getShapeAt(el, x, y);
                return shapeid !== undefined && this.shapes[shapeid] !== undefined ? this.shapes[shapeid] : undefined;
            },

            getCurrentRegionFields: function getCurrentRegionFields() {
                var currentRegion = this.currentRegion;
                return {
                    fieldkey: currentRegion.substr(0, 1),
                    value: this.values[currentRegion.substr(1)],
                    region: currentRegion
                };
            },

            changeHighlight: function changeHighlight(highlight) {
                var currentRegion = this.currentRegion,
                    shapeid = this.valueShapes[currentRegion],
                    shape;
                delete this.shapes[shapeid];
                switch (currentRegion.substr(0, 1)) {
                    case 'r':
                        shape = this.renderRange(currentRegion.substr(1), highlight);
                        break;
                    case 'p':
                        shape = this.renderPerformance(highlight);
                        break;
                    case 't':
                        shape = this.renderTarget(highlight);
                        break;
                }
                this.valueShapes[currentRegion] = shape.id;
                this.shapes[shape.id] = currentRegion;
                this.target.replaceWithShape(shapeid, shape);
            },

            renderRange: function renderRange(rn, highlight) {
                var rangeval = this.values[rn],
                    rangewidth = Math.round(this.canvasWidth * ((rangeval - this.min) / this.range)),
                    color = this.options.get('rangeColors')[rn - 2];
                if (highlight) {
                    color = this.calcHighlightColor(color, this.options);
                }
                return this.target.drawRect(0, 0, rangewidth - 1, this.canvasHeight - 1, color, color);
            },

            renderPerformance: function renderPerformance(highlight) {
                var perfval = this.values[1],
                    perfwidth = Math.round(this.canvasWidth * ((perfval - this.min) / this.range)),
                    color = this.options.get('performanceColor');
                if (highlight) {
                    color = this.calcHighlightColor(color, this.options);
                }
                return this.target.drawRect(0, Math.round(this.canvasHeight * 0.3), perfwidth - 1, Math.round(this.canvasHeight * 0.4) - 1, color, color);
            },

            renderTarget: function renderTarget(highlight) {
                var targetval = this.values[0],
                    x = Math.round(this.canvasWidth * ((targetval - this.min) / this.range) - this.options.get('targetWidth') / 2),
                    targettop = Math.round(this.canvasHeight * 0.10),
                    targetheight = this.canvasHeight - targettop * 2,
                    color = this.options.get('targetColor');
                if (highlight) {
                    color = this.calcHighlightColor(color, this.options);
                }
                return this.target.drawRect(x, targettop, this.options.get('targetWidth') - 1, targetheight - 1, color, color);
            },

            render: function render() {
                var vlen = this.values.length,
                    target = this.target,
                    i,
                    shape;
                if (!bullet._super.render.call(this)) {
                    return;
                }
                for (i = 2; i < vlen; i++) {
                    shape = this.renderRange(i).append();
                    this.shapes[shape.id] = 'r' + i;
                    this.valueShapes['r' + i] = shape.id;
                }
                if (this.values[1] !== null) {
                    shape = this.renderPerformance().append();
                    this.shapes[shape.id] = 'p1';
                    this.valueShapes.p1 = shape.id;
                }
                if (this.values[0] !== null) {
                    shape = this.renderTarget().append();
                    this.shapes[shape.id] = 't0';
                    this.valueShapes.t0 = shape.id;
                }
                target.render();
            }
        });

        /**
         * Pie charts
         */
        $.fn.sparkline.pie = pie = createClass($.fn.sparkline._base, {
            type: 'pie',

            init: function init(el, values, options, width, height) {
                var total = 0,
                    i;

                pie._super.init.call(this, el, values, options, width, height);

                this.shapes = {}; // map shape ids to value offsets
                this.valueShapes = {}; // maps value offsets to shape ids
                this.values = values = $.map(values, Number);

                if (options.get('width') === 'auto') {
                    this.width = this.height;
                }

                if (values.length > 0) {
                    for (i = values.length; i--;) {
                        total += values[i];
                    }
                }
                this.total = total;
                this.initTarget();
                this.radius = Math.floor(Math.min(this.canvasWidth, this.canvasHeight) / 2);
            },

            getRegion: function getRegion(el, x, y) {
                var shapeid = this.target.getShapeAt(el, x, y);
                return shapeid !== undefined && this.shapes[shapeid] !== undefined ? this.shapes[shapeid] : undefined;
            },

            getCurrentRegionFields: function getCurrentRegionFields() {
                var currentRegion = this.currentRegion;
                return {
                    isNull: this.values[currentRegion] === undefined,
                    value: this.values[currentRegion],
                    percent: this.values[currentRegion] / this.total * 100,
                    color: this.options.get('sliceColors')[currentRegion % this.options.get('sliceColors').length],
                    offset: currentRegion
                };
            },

            changeHighlight: function changeHighlight(highlight) {
                var currentRegion = this.currentRegion,
                    newslice = this.renderSlice(currentRegion, highlight),
                    shapeid = this.valueShapes[currentRegion];
                delete this.shapes[shapeid];
                this.target.replaceWithShape(shapeid, newslice);
                this.valueShapes[currentRegion] = newslice.id;
                this.shapes[newslice.id] = currentRegion;
            },

            renderSlice: function renderSlice(valuenum, highlight) {
                var target = this.target,
                    options = this.options,
                    radius = this.radius,
                    borderWidth = options.get('borderWidth'),
                    offset = options.get('offset'),
                    circle = 2 * Math.PI,
                    values = this.values,
                    total = this.total,
                    next = offset ? 2 * Math.PI * (offset / 360) : 0,
                    start,
                    end,
                    i,
                    vlen,
                    color;

                vlen = values.length;
                for (i = 0; i < vlen; i++) {
                    start = next;
                    end = next;
                    if (total > 0) {
                        // avoid divide by zero
                        end = next + circle * (values[i] / total);
                    }
                    if (valuenum === i) {
                        color = options.get('sliceColors')[i % options.get('sliceColors').length];
                        if (highlight) {
                            color = this.calcHighlightColor(color, options);
                        }

                        return target.drawPieSlice(radius, radius, radius - borderWidth, start, end, undefined, color);
                    }
                    next = end;
                }
            },

            render: function render() {
                var target = this.target,
                    values = this.values,
                    options = this.options,
                    radius = this.radius,
                    borderWidth = options.get('borderWidth'),
                    shape,
                    i;

                if (!pie._super.render.call(this)) {
                    return;
                }
                if (borderWidth) {
                    target.drawCircle(radius, radius, Math.floor(radius - borderWidth / 2), options.get('borderColor'), undefined, borderWidth).append();
                }
                for (i = values.length; i--;) {
                    if (values[i]) {
                        // don't render zero values
                        shape = this.renderSlice(i).append();
                        this.valueShapes[i] = shape.id; // store just the shapeid
                        this.shapes[shape.id] = i;
                    }
                }
                target.render();
            }
        });

        /**
         * Box plots
         */
        $.fn.sparkline.box = box = createClass($.fn.sparkline._base, {
            type: 'box',

            init: function init(el, values, options, width, height) {
                box._super.init.call(this, el, values, options, width, height);
                this.values = $.map(values, Number);
                this.width = options.get('width') === 'auto' ? '4.0em' : width;
                this.initTarget();
                if (!this.values.length) {
                    this.disabled = 1;
                }
            },

            /**
             * Simulate a single region
             */
            getRegion: function getRegion() {
                return 1;
            },

            getCurrentRegionFields: function getCurrentRegionFields() {
                var result = [{ field: 'lq', value: this.quartiles[0] }, { field: 'med', value: this.quartiles[1] }, { field: 'uq', value: this.quartiles[2] }];
                if (this.loutlier !== undefined) {
                    result.push({ field: 'lo', value: this.loutlier });
                }
                if (this.routlier !== undefined) {
                    result.push({ field: 'ro', value: this.routlier });
                }
                if (this.lwhisker !== undefined) {
                    result.push({ field: 'lw', value: this.lwhisker });
                }
                if (this.rwhisker !== undefined) {
                    result.push({ field: 'rw', value: this.rwhisker });
                }
                return result;
            },

            render: function render() {
                var target = this.target,
                    values = this.values,
                    vlen = values.length,
                    options = this.options,
                    canvasWidth = this.canvasWidth,
                    canvasHeight = this.canvasHeight,
                    minValue = options.get('chartRangeMin') === undefined ? Math.min.apply(Math, values) : options.get('chartRangeMin'),
                    maxValue = options.get('chartRangeMax') === undefined ? Math.max.apply(Math, values) : options.get('chartRangeMax'),
                    canvasLeft = 0,
                    lwhisker,
                    loutlier,
                    iqr,
                    q1,
                    q2,
                    q3,
                    rwhisker,
                    routlier,
                    i,
                    size,
                    unitSize;

                if (!box._super.render.call(this)) {
                    return;
                }

                if (options.get('raw')) {
                    if (options.get('showOutliers') && values.length > 5) {
                        loutlier = values[0];
                        lwhisker = values[1];
                        q1 = values[2];
                        q2 = values[3];
                        q3 = values[4];
                        rwhisker = values[5];
                        routlier = values[6];
                    } else {
                        lwhisker = values[0];
                        q1 = values[1];
                        q2 = values[2];
                        q3 = values[3];
                        rwhisker = values[4];
                    }
                } else {
                    values.sort(function (a, b) {
                        return a - b;
                    });
                    q1 = quartile(values, 1);
                    q2 = quartile(values, 2);
                    q3 = quartile(values, 3);
                    iqr = q3 - q1;
                    if (options.get('showOutliers')) {
                        lwhisker = rwhisker = undefined;
                        for (i = 0; i < vlen; i++) {
                            if (lwhisker === undefined && values[i] > q1 - iqr * options.get('outlierIQR')) {
                                lwhisker = values[i];
                            }
                            if (values[i] < q3 + iqr * options.get('outlierIQR')) {
                                rwhisker = values[i];
                            }
                        }
                        loutlier = values[0];
                        routlier = values[vlen - 1];
                    } else {
                        lwhisker = values[0];
                        rwhisker = values[vlen - 1];
                    }
                }
                this.quartiles = [q1, q2, q3];
                this.lwhisker = lwhisker;
                this.rwhisker = rwhisker;
                this.loutlier = loutlier;
                this.routlier = routlier;

                unitSize = canvasWidth / (maxValue - minValue + 1);
                if (options.get('showOutliers')) {
                    canvasLeft = Math.ceil(options.get('spotRadius'));
                    canvasWidth -= 2 * Math.ceil(options.get('spotRadius'));
                    unitSize = canvasWidth / (maxValue - minValue + 1);
                    if (loutlier < lwhisker) {
                        target.drawCircle((loutlier - minValue) * unitSize + canvasLeft, canvasHeight / 2, options.get('spotRadius'), options.get('outlierLineColor'), options.get('outlierFillColor')).append();
                    }
                    if (routlier > rwhisker) {
                        target.drawCircle((routlier - minValue) * unitSize + canvasLeft, canvasHeight / 2, options.get('spotRadius'), options.get('outlierLineColor'), options.get('outlierFillColor')).append();
                    }
                }

                // box
                target.drawRect(Math.round((q1 - minValue) * unitSize + canvasLeft), Math.round(canvasHeight * 0.1), Math.round((q3 - q1) * unitSize), Math.round(canvasHeight * 0.8), options.get('boxLineColor'), options.get('boxFillColor')).append();
                // left whisker
                target.drawLine(Math.round((lwhisker - minValue) * unitSize + canvasLeft), Math.round(canvasHeight / 2), Math.round((q1 - minValue) * unitSize + canvasLeft), Math.round(canvasHeight / 2), options.get('lineColor')).append();
                target.drawLine(Math.round((lwhisker - minValue) * unitSize + canvasLeft), Math.round(canvasHeight / 4), Math.round((lwhisker - minValue) * unitSize + canvasLeft), Math.round(canvasHeight - canvasHeight / 4), options.get('whiskerColor')).append();
                // right whisker
                target.drawLine(Math.round((rwhisker - minValue) * unitSize + canvasLeft), Math.round(canvasHeight / 2), Math.round((q3 - minValue) * unitSize + canvasLeft), Math.round(canvasHeight / 2), options.get('lineColor')).append();
                target.drawLine(Math.round((rwhisker - minValue) * unitSize + canvasLeft), Math.round(canvasHeight / 4), Math.round((rwhisker - minValue) * unitSize + canvasLeft), Math.round(canvasHeight - canvasHeight / 4), options.get('whiskerColor')).append();
                // median line
                target.drawLine(Math.round((q2 - minValue) * unitSize + canvasLeft), Math.round(canvasHeight * 0.1), Math.round((q2 - minValue) * unitSize + canvasLeft), Math.round(canvasHeight * 0.9), options.get('medianColor')).append();
                if (options.get('target')) {
                    size = Math.ceil(options.get('spotRadius'));
                    target.drawLine(Math.round((options.get('target') - minValue) * unitSize + canvasLeft), Math.round(canvasHeight / 2 - size), Math.round((options.get('target') - minValue) * unitSize + canvasLeft), Math.round(canvasHeight / 2 + size), options.get('targetColor')).append();
                    target.drawLine(Math.round((options.get('target') - minValue) * unitSize + canvasLeft - size), Math.round(canvasHeight / 2), Math.round((options.get('target') - minValue) * unitSize + canvasLeft + size), Math.round(canvasHeight / 2), options.get('targetColor')).append();
                }
                target.render();
            }
        });

        // Setup a very simple "virtual canvas" to make drawing the few shapes we need easier
        // This is accessible as $(foo).simpledraw()

        VShape = createClass({
            init: function init(target, id, type, args) {
                this.target = target;
                this.id = id;
                this.type = type;
                this.args = args;
            },
            append: function append() {
                this.target.appendShape(this);
                return this;
            }
        });

        VCanvas_base = createClass({
            _pxregex: /(\d+)(px)?\s*$/i,

            init: function init(width, height, target) {
                if (!width) {
                    return;
                }
                this.width = width;
                this.height = height;
                this.target = target;
                this.lastShapeId = null;
                if (target[0]) {
                    target = target[0];
                }
                $.data(target, '_jqs_vcanvas', this);
            },

            drawLine: function drawLine(x1, y1, x2, y2, lineColor, lineWidth) {
                return this.drawShape([[x1, y1], [x2, y2]], lineColor, lineWidth);
            },

            drawShape: function drawShape(path, lineColor, fillColor, lineWidth) {
                return this._genShape('Shape', [path, lineColor, fillColor, lineWidth]);
            },

            drawCircle: function drawCircle(x, y, radius, lineColor, fillColor, lineWidth) {
                return this._genShape('Circle', [x, y, radius, lineColor, fillColor, lineWidth]);
            },

            drawPieSlice: function drawPieSlice(x, y, radius, startAngle, endAngle, lineColor, fillColor) {
                return this._genShape('PieSlice', [x, y, radius, startAngle, endAngle, lineColor, fillColor]);
            },

            drawRect: function drawRect(x, y, width, height, lineColor, fillColor) {
                return this._genShape('Rect', [x, y, width, height, lineColor, fillColor]);
            },

            getElement: function getElement() {
                return this.canvas;
            },

            /**
             * Return the most recently inserted shape id
             */
            getLastShapeId: function getLastShapeId() {
                return this.lastShapeId;
            },

            /**
             * Clear and reset the canvas
             */
            reset: function reset() {
                window.alert('reset not implemented');
            },

            _insert: function _insert(el, target) {
                $(target).html(el);
            },

            /**
             * Calculate the pixel dimensions of the canvas
             */
            _calculatePixelDims: function _calculatePixelDims(width, height, canvas) {
                // XXX This should probably be a configurable option
                var match;
                match = this._pxregex.exec(height);
                if (match) {
                    this.pixelHeight = match[1];
                } else {
                    this.pixelHeight = $(canvas).height();
                }
                match = this._pxregex.exec(width);
                if (match) {
                    this.pixelWidth = match[1];
                } else {
                    this.pixelWidth = $(canvas).width();
                }
            },

            /**
             * Generate a shape object and id for later rendering
             */
            _genShape: function _genShape(shapetype, shapeargs) {
                var id = shapeCount++;
                shapeargs.unshift(id);
                return new VShape(this, id, shapetype, shapeargs);
            },

            /**
             * Add a shape to the end of the render queue
             */
            appendShape: function appendShape(shape) {
                window.alert('appendShape not implemented');
            },

            /**
             * Replace one shape with another
             */
            replaceWithShape: function replaceWithShape(shapeid, shape) {
                window.alert('replaceWithShape not implemented');
            },

            /**
             * Insert one shape after another in the render queue
             */
            insertAfterShape: function insertAfterShape(shapeid, shape) {
                window.alert('insertAfterShape not implemented');
            },

            /**
             * Remove a shape from the queue
             */
            removeShapeId: function removeShapeId(shapeid) {
                window.alert('removeShapeId not implemented');
            },

            /**
             * Find a shape at the specified x/y co-ordinates
             */
            getShapeAt: function getShapeAt(el, x, y) {
                window.alert('getShapeAt not implemented');
            },

            /**
             * Render all queued shapes onto the canvas
             */
            render: function render() {
                window.alert('render not implemented');
            }
        });

        VCanvas_canvas = createClass(VCanvas_base, {
            init: function init(width, height, target, interact) {
                VCanvas_canvas._super.init.call(this, width, height, target);
                this.canvas = document.createElement('canvas');
                if (target[0]) {
                    target = target[0];
                }
                this.context = this.canvas.getContext('2d');
                var devicePixelRatio = window.devicePixelRatio || 1,
                    backingStoreRatio = this.context.webkitBackingStorePixelRatio || this.context.mozBackingStorePixelRatio || this.context.msBackingStorePixelRatio || this.context.oBackingStorePixelRatio || this.context.backingStorePixelRatio || 1,
                    ratio = devicePixelRatio / backingStoreRatio;
                $.data(target, '_jqs_vcanvas', this);
                $(this.canvas).css({ display: 'inline-block', width: width, height: height, verticalAlign: 'top' });
                this._insert(this.canvas, target);
                this._calculatePixelDims(width, height, this.canvas);
                this.canvas.width = this.pixelWidth * ratio;
                this.canvas.height = this.pixelHeight * ratio;
                this.context.scale(ratio, ratio);
                this.interact = interact;
                this.shapes = {};
                this.shapeseq = [];
                this.currentTargetShapeId = undefined;
                $(this.canvas).css({ width: this.pixelWidth, height: this.pixelHeight });
            },

            _getContext: function _getContext(lineColor, fillColor, lineWidth) {
                var context = this.canvas.getContext('2d');
                if (lineColor !== undefined) {
                    context.strokeStyle = lineColor;
                }
                context.lineWidth = lineWidth === undefined ? 1 : lineWidth;
                if (fillColor !== undefined) {
                    context.fillStyle = fillColor;
                }
                return context;
            },

            reset: function reset() {
                var context = this._getContext();
                context.clearRect(0, 0, this.pixelWidth, this.pixelHeight);
                this.shapes = {};
                this.shapeseq = [];
                this.currentTargetShapeId = undefined;
            },

            _drawShape: function _drawShape(shapeid, path, lineColor, fillColor, lineWidth) {
                var context = this._getContext(lineColor, fillColor, lineWidth),
                    i,
                    plen;
                context.beginPath();
                context.moveTo(path[0][0] + 0.5, path[0][1] + 0.5);
                for (i = 1, plen = path.length; i < plen; i++) {
                    context.lineTo(path[i][0] + 0.5, path[i][1] + 0.5); // the 0.5 offset gives us crisp pixel-width lines
                }
                if (lineColor !== undefined) {
                    context.stroke();
                }
                if (fillColor !== undefined) {
                    context.fill();
                }
                if (this.targetX !== undefined && this.targetY !== undefined && context.isPointInPath(this.targetX, this.targetY)) {
                    this.currentTargetShapeId = shapeid;
                }
            },

            _drawCircle: function _drawCircle(shapeid, x, y, radius, lineColor, fillColor, lineWidth) {
                var context = this._getContext(lineColor, fillColor, lineWidth);
                context.beginPath();
                context.arc(x, y, radius, 0, 2 * Math.PI, false);
                if (this.targetX !== undefined && this.targetY !== undefined && context.isPointInPath(this.targetX, this.targetY)) {
                    this.currentTargetShapeId = shapeid;
                }
                if (lineColor !== undefined) {
                    context.stroke();
                }
                if (fillColor !== undefined) {
                    context.fill();
                }
            },

            _drawPieSlice: function _drawPieSlice(shapeid, x, y, radius, startAngle, endAngle, lineColor, fillColor) {
                var context = this._getContext(lineColor, fillColor);
                context.beginPath();
                context.moveTo(x, y);
                context.arc(x, y, radius, startAngle, endAngle, false);
                context.lineTo(x, y);
                context.closePath();
                if (lineColor !== undefined) {
                    context.stroke();
                }
                if (fillColor) {
                    context.fill();
                }
                if (this.targetX !== undefined && this.targetY !== undefined && context.isPointInPath(this.targetX, this.targetY)) {
                    this.currentTargetShapeId = shapeid;
                }
            },

            _drawRect: function _drawRect(shapeid, x, y, width, height, lineColor, fillColor) {
                return this._drawShape(shapeid, [[x, y], [x + width, y], [x + width, y + height], [x, y + height], [x, y]], lineColor, fillColor);
            },

            appendShape: function appendShape(shape) {
                this.shapes[shape.id] = shape;
                this.shapeseq.push(shape.id);
                this.lastShapeId = shape.id;
                return shape.id;
            },

            replaceWithShape: function replaceWithShape(shapeid, shape) {
                var shapeseq = this.shapeseq,
                    i;
                this.shapes[shape.id] = shape;
                for (i = shapeseq.length; i--;) {
                    if (shapeseq[i] == shapeid) {
                        shapeseq[i] = shape.id;
                    }
                }
                delete this.shapes[shapeid];
            },

            replaceWithShapes: function replaceWithShapes(shapeids, shapes) {
                var shapeseq = this.shapeseq,
                    shapemap = {},
                    sid,
                    i,
                    first;

                for (i = shapeids.length; i--;) {
                    shapemap[shapeids[i]] = true;
                }
                for (i = shapeseq.length; i--;) {
                    sid = shapeseq[i];
                    if (shapemap[sid]) {
                        shapeseq.splice(i, 1);
                        delete this.shapes[sid];
                        first = i;
                    }
                }
                for (i = shapes.length; i--;) {
                    shapeseq.splice(first, 0, shapes[i].id);
                    this.shapes[shapes[i].id] = shapes[i];
                }
            },

            insertAfterShape: function insertAfterShape(shapeid, shape) {
                var shapeseq = this.shapeseq,
                    i;
                for (i = shapeseq.length; i--;) {
                    if (shapeseq[i] === shapeid) {
                        shapeseq.splice(i + 1, 0, shape.id);
                        this.shapes[shape.id] = shape;
                        return;
                    }
                }
            },

            removeShapeId: function removeShapeId(shapeid) {
                var shapeseq = this.shapeseq,
                    i;
                for (i = shapeseq.length; i--;) {
                    if (shapeseq[i] === shapeid) {
                        shapeseq.splice(i, 1);
                        break;
                    }
                }
                delete this.shapes[shapeid];
            },

            getShapeAt: function getShapeAt(el, x, y) {
                this.targetX = x;
                this.targetY = y;
                this.render();
                return this.currentTargetShapeId;
            },

            render: function render() {
                var shapeseq = this.shapeseq,
                    shapes = this.shapes,
                    shapeCount = shapeseq.length,
                    context = this._getContext(),
                    shapeid,
                    shape,
                    i;
                context.clearRect(0, 0, this.pixelWidth, this.pixelHeight);
                for (i = 0; i < shapeCount; i++) {
                    shapeid = shapeseq[i];
                    shape = shapes[shapeid];
                    this['_draw' + shape.type].apply(this, shape.args);
                }
                if (!this.interact) {
                    // not interactive so no need to keep the shapes array
                    this.shapes = {};
                    this.shapeseq = [];
                }
            }

        });

        VCanvas_vml = createClass(VCanvas_base, {
            init: function init(width, height, target) {
                var groupel;
                VCanvas_vml._super.init.call(this, width, height, target);
                if (target[0]) {
                    target = target[0];
                }
                $.data(target, '_jqs_vcanvas', this);
                this.canvas = document.createElement('span');
                $(this.canvas).css({ display: 'inline-block', position: 'relative', overflow: 'hidden', width: width, height: height, margin: '0', padding: '0', verticalAlign: 'top' });
                this._insert(this.canvas, target);
                this._calculatePixelDims(width, height, this.canvas);
                this.canvas.width = this.pixelWidth;
                this.canvas.height = this.pixelHeight;
                groupel = '<v:group coordorigin="0 0" coordsize="' + this.pixelWidth + ' ' + this.pixelHeight + '"' + ' style="position:absolute;top:0;left:0;width:' + this.pixelWidth + 'px;height=' + this.pixelHeight + 'px;"></v:group>';
                this.canvas.insertAdjacentHTML('beforeEnd', groupel);
                this.group = $(this.canvas).children()[0];
                this.rendered = false;
                this.prerender = '';
            },

            _drawShape: function _drawShape(shapeid, path, lineColor, fillColor, lineWidth) {
                var vpath = [],
                    initial,
                    stroke,
                    fill,
                    closed,
                    vel,
                    plen,
                    i;
                for (i = 0, plen = path.length; i < plen; i++) {
                    vpath[i] = '' + path[i][0] + ',' + path[i][1];
                }
                initial = vpath.splice(0, 1);
                lineWidth = lineWidth === undefined ? 1 : lineWidth;
                stroke = lineColor === undefined ? ' stroked="false" ' : ' strokeWeight="' + lineWidth + 'px" strokeColor="' + lineColor + '" ';
                fill = fillColor === undefined ? ' filled="false"' : ' fillColor="' + fillColor + '" filled="true" ';
                closed = vpath[0] === vpath[vpath.length - 1] ? 'x ' : '';
                vel = '<v:shape coordorigin="0 0" coordsize="' + this.pixelWidth + ' ' + this.pixelHeight + '" ' + ' id="jqsshape' + shapeid + '" ' + stroke + fill + ' style="position:absolute;left:0;top:0;height:' + this.pixelHeight + 'px;width:' + this.pixelWidth + 'px;padding:0;margin:0;" ' + ' path="m ' + initial + ' l ' + vpath.join(', ') + ' ' + closed + 'e">' + ' </v:shape>';
                return vel;
            },

            _drawCircle: function _drawCircle(shapeid, x, y, radius, lineColor, fillColor, lineWidth) {
                var stroke, fill, vel;
                x -= radius;
                y -= radius;
                stroke = lineColor === undefined ? ' stroked="false" ' : ' strokeWeight="' + lineWidth + 'px" strokeColor="' + lineColor + '" ';
                fill = fillColor === undefined ? ' filled="false"' : ' fillColor="' + fillColor + '" filled="true" ';
                vel = '<v:oval ' + ' id="jqsshape' + shapeid + '" ' + stroke + fill + ' style="position:absolute;top:' + y + 'px; left:' + x + 'px; width:' + radius * 2 + 'px; height:' + radius * 2 + 'px"></v:oval>';
                return vel;
            },

            _drawPieSlice: function _drawPieSlice(shapeid, x, y, radius, startAngle, endAngle, lineColor, fillColor) {
                var vpath, startx, starty, endx, endy, stroke, fill, vel;
                if (startAngle === endAngle) {
                    return ''; // VML seems to have problem when start angle equals end angle.
                }
                if (endAngle - startAngle === 2 * Math.PI) {
                    startAngle = 0.0; // VML seems to have a problem when drawing a full circle that doesn't start 0
                    endAngle = 2 * Math.PI;
                }

                startx = x + Math.round(Math.cos(startAngle) * radius);
                starty = y + Math.round(Math.sin(startAngle) * radius);
                endx = x + Math.round(Math.cos(endAngle) * radius);
                endy = y + Math.round(Math.sin(endAngle) * radius);

                if (startx === endx && starty === endy) {
                    if (endAngle - startAngle < Math.PI) {
                        // Prevent very small slices from being mistaken as a whole pie
                        return '';
                    }
                    // essentially going to be the entire circle, so ignore startAngle
                    startx = endx = x + radius;
                    starty = endy = y;
                }

                if (startx === endx && starty === endy && endAngle - startAngle < Math.PI) {
                    return '';
                }

                vpath = [x - radius, y - radius, x + radius, y + radius, startx, starty, endx, endy];
                stroke = lineColor === undefined ? ' stroked="false" ' : ' strokeWeight="1px" strokeColor="' + lineColor + '" ';
                fill = fillColor === undefined ? ' filled="false"' : ' fillColor="' + fillColor + '" filled="true" ';
                vel = '<v:shape coordorigin="0 0" coordsize="' + this.pixelWidth + ' ' + this.pixelHeight + '" ' + ' id="jqsshape' + shapeid + '" ' + stroke + fill + ' style="position:absolute;left:0;top:0;height:' + this.pixelHeight + 'px;width:' + this.pixelWidth + 'px;padding:0;margin:0;" ' + ' path="m ' + x + ',' + y + ' wa ' + vpath.join(', ') + ' x e">' + ' </v:shape>';
                return vel;
            },

            _drawRect: function _drawRect(shapeid, x, y, width, height, lineColor, fillColor) {
                return this._drawShape(shapeid, [[x, y], [x, y + height], [x + width, y + height], [x + width, y], [x, y]], lineColor, fillColor);
            },

            reset: function reset() {
                this.group.innerHTML = '';
            },

            appendShape: function appendShape(shape) {
                var vel = this['_draw' + shape.type].apply(this, shape.args);
                if (this.rendered) {
                    this.group.insertAdjacentHTML('beforeEnd', vel);
                } else {
                    this.prerender += vel;
                }
                this.lastShapeId = shape.id;
                return shape.id;
            },

            replaceWithShape: function replaceWithShape(shapeid, shape) {
                var existing = $('#jqsshape' + shapeid),
                    vel = this['_draw' + shape.type].apply(this, shape.args);
                existing[0].outerHTML = vel;
            },

            replaceWithShapes: function replaceWithShapes(shapeids, shapes) {
                // replace the first shapeid with all the new shapes then toast the remaining old shapes
                var existing = $('#jqsshape' + shapeids[0]),
                    replace = '',
                    slen = shapes.length,
                    i;
                for (i = 0; i < slen; i++) {
                    replace += this['_draw' + shapes[i].type].apply(this, shapes[i].args);
                }
                existing[0].outerHTML = replace;
                for (i = 1; i < shapeids.length; i++) {
                    $('#jqsshape' + shapeids[i]).remove();
                }
            },

            insertAfterShape: function insertAfterShape(shapeid, shape) {
                var existing = $('#jqsshape' + shapeid),
                    vel = this['_draw' + shape.type].apply(this, shape.args);
                existing[0].insertAdjacentHTML('afterEnd', vel);
            },

            removeShapeId: function removeShapeId(shapeid) {
                var existing = $('#jqsshape' + shapeid);
                this.group.removeChild(existing[0]);
            },

            getShapeAt: function getShapeAt(el, x, y) {
                var shapeid = el.id.substr(8);
                return shapeid;
            },

            render: function render() {
                if (!this.rendered) {
                    // batch the intial render into a single repaint
                    this.group.innerHTML = this.prerender;
                    this.rendered = true;
                }
            }
        });
    });
})(document, Math);

/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

Element.prototype.hide = function () {
    this.style.display = 'none';
    return this;
};

Element.prototype.show = function () {
    this.style.display = '';
    return this;
};

if (!('remove' in Element.prototype)) {
    Element.prototype.remove = function () {
        if (this.parentNode) {
            this.parentNode.removeChild(this);
        }
        return this;
    };
}

Element.prototype.toggleClass = function (class_name, should_add) {
    if (typeof should_add === 'undefined') {
        // toggle
        should_add = !this.classList.contains(class_name);
    }
    this.classList[should_add ? 'add' : 'remove'](class_name);
    return this;
};

Element.prototype.setVisibility = function (make_visible) {
    this.toggleClass('invisible', !make_visible);
    return this;
};

Element.prototype.insertAfter = function (referenceNode) {
    if (referenceNode && referenceNode.parentNode) {
        referenceNode.parentNode.insertBefore(this, referenceNode.nextSibling);
    }
    return this;
};

Element.prototype.html = function (content) {
    if ((typeof content === 'undefined' ? 'undefined' : _typeof(content)) === 'object') {
        this.innerHTML = '';
        this.appendChild(content);
    } else {
        this.innerHTML = content;
    }
    return this;
};

(function ($) {
    $.fn.setVisibility = function (make_visible) {
        this[(make_visible ? 'remove' : 'add') + 'Class']('invisible');
        return this;
    };
})(jQuery);

/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (window.NodeList && !NodeList.prototype.forEach) {
    NodeList.prototype.forEach = function (callback, thisArg) {
        thisArg = thisArg || window;
        for (var i = 0; i < this.length; i++) {
            callback.call(thisArg, this[i], i, this);
        }
    };
}

/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BinaryPjax = __webpack_require__(12);
var pages_config = __webpack_require__(252);
var Client = __webpack_require__(3);
var Header = __webpack_require__(27);
var NetworkMonitor = __webpack_require__(257);
var Page = __webpack_require__(258);
var BinarySocket = __webpack_require__(5);
var ContentVisibility = __webpack_require__(262);
var GTM = __webpack_require__(54);
var Login = __webpack_require__(55);
var getElementById = __webpack_require__(4).getElementById;
var localize = __webpack_require__(2).localize;
var ScrollToAnchor = __webpack_require__(250);
var isStorageSupported = __webpack_require__(6).isStorageSupported;
var ThirdPartyLinks = __webpack_require__(251);
var urlFor = __webpack_require__(8).urlFor;
var createElement = __webpack_require__(1).createElement;

var BinaryLoader = function () {
    var container = void 0;
    var active_script = null;

    var init = function init() {
        if (!/\.html$/i.test(window.location.pathname)) {
            window.location.pathname += '.html';
            return;
        }

        if (!isStorageSupported(localStorage) || !isStorageSupported(sessionStorage)) {
            Header.displayNotification(localize('[_1] requires your browser\'s web storage to be enabled in order to function properly. Please enable it or exit private browsing mode.', ['Binary.com']), true, 'STORAGE_NOT_SUPPORTED');
            getElementById('btn_login').classList.add('button-disabled');
        }

        Page.showNotificationOutdatedBrowser();

        Client.init();
        NetworkMonitor.init();

        container = getElementById('content-holder');
        container.addEventListener('binarypjax:before', beforeContentChange);
        container.addEventListener('binarypjax:after', afterContentChange);

        if (Login.isLoginPages()) {
            BinaryPjax.init(container, '#content');
        } else if (!Client.isLoggedIn()) {
            Client.setJPFlag();
            BinaryPjax.init(container, '#content');
        } else {
            // client is logged in
            // we need to set top-nav-menu class so binary-style can add event listener
            // if we wait for socket.init before doing this binary-style will not initiate the drop-down menu
            getElementById('menu-top').classList.add('smaller-font', 'top-nav-menu');
            // wait for socket to be initialized and authorize response before loading the page. handled in the onOpen function
        }

        ThirdPartyLinks.init();
    };

    var beforeContentChange = function beforeContentChange() {
        if (active_script) {
            BinarySocket.removeOnDisconnect();
            if (typeof active_script.onUnload === 'function') {
                active_script.onUnload();
            }
            active_script = null;
        }
        ScrollToAnchor.cleanup();
    };

    var afterContentChange = function afterContentChange(e) {
        Page.onLoad();
        GTM.pushDataLayer();

        var this_page = e.detail.getAttribute('data-page');
        if (this_page in pages_config) {
            loadHandler(pages_config[this_page]);
        } else if (/\/get-started\//i.test(window.location.pathname)) {
            loadHandler(pages_config['get-started']);
        }

        ContentVisibility.init();
        ScrollToAnchor.init();
    };

    var error_messages = {
        login: function login() {
            return localize('Please [_1]log in[_2] or [_3]sign up[_2] to view this page.', ['<a href="' + 'javascript:;' + '">', '</a>', '<a href="' + urlFor() + '">']);
        },
        only_virtual: 'Sorry, this feature is available to virtual accounts only.',
        only_real: 'This feature is not relevant to virtual-money accounts.'
    };

    var loadHandler = function loadHandler(config) {
        active_script = config.module;
        if (config.is_authenticated) {
            if (!Client.isLoggedIn()) {
                displayMessage(error_messages.login());
            } else {
                BinarySocket.wait('authorize').then(function (response) {
                    if (response.error) {
                        displayMessage(error_messages.login());
                    } else if (config.only_virtual && !Client.get('is_virtual')) {
                        displayMessage(error_messages.only_virtual);
                    } else if (config.only_real && Client.get('is_virtual')) {
                        displayMessage(error_messages.only_real);
                    } else {
                        loadActiveScript(config);
                    }
                });
            }
        } else if (config.not_authenticated && Client.isLoggedIn()) {
            BinaryPjax.load(Client.defaultRedirectUrl(), true);
        } else {
            loadActiveScript(config);
        }
        BinarySocket.setOnDisconnect(active_script.onDisconnect);
    };

    var loadActiveScript = function loadActiveScript(config) {
        if (active_script && typeof active_script.onLoad === 'function') {
            // only pages that call formatMoney should wait for website_status
            if (config.needs_currency) {
                BinarySocket.wait('website_status').then(function () {
                    active_script.onLoad();
                });
            } else {
                active_script.onLoad();
            }
        }
    };

    var displayMessage = function displayMessage(message) {
        var content = container.querySelector('#content .container');
        if (!content) {
            return;
        }

        var div_container = createElement('div', { class: 'logged_out_title_container', html: content.getElementsByTagName('h1')[0] });
        var div_notice = createElement('p', { class: 'center-text notice-msg', html: localize(message) });

        div_container.appendChild(div_notice);

        content.html(div_container);

        var link = content.getElementsByTagName('a')[0];
        if (link) {
            link.addEventListener('click', function () {
                Login.redirectToLogin();
            });
        }
    };

    return {
        init: init
    };
}();

module.exports = BinaryLoader;

/***/ }),
/* 236 */,
/* 237 */,
/* 238 */,
/* 239 */,
/* 240 */,
/* 241 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var BinarySocket = __webpack_require__(86);

/*
 * Monitors the network status and initialises the WebSocket connection
 * 1. online : check the WS status (init/send: blink after timeout, open/message: online)
 * 2. offline: it is offline
 */
var NetworkMonitorBase = function () {
    var _pending_timeouts;

    var status_config = {
        online: { class: 'online', tooltip: 'Online' },
        offline: { class: 'offline', tooltip: 'Offline' },
        blinking: { class: 'blinker', tooltip: 'Connecting to server' }
    };
    var pendings = {};
    var pending_keys = {
        ws_init: 'ws_init',
        ws_request: 'ws_request'
    };
    var pending_timeouts = (_pending_timeouts = {}, _defineProperty(_pending_timeouts, pending_keys.ws_init, 5000), _defineProperty(_pending_timeouts, pending_keys.ws_request, 10000), _pending_timeouts);

    var ws_config = void 0,
        network_status = void 0,
        updateUI = void 0;

    var init = function init(socket_general_functions, fncUpdateUI) {
        updateUI = fncUpdateUI;
        ws_config = Object.assign({ wsEvent: wsEvent, isOnline: isOnline }, socket_general_functions);

        if ('onLine' in navigator) {
            window.addEventListener('online', setStatus);
            window.addEventListener('offline', setStatus);
        } else {
            // if not supported, default to online and fallback to WS checks
            navigator.onLine = true;
        }

        if (isOnline()) {
            BinarySocket.init(ws_config);
        }

        setStatus(isOnline() ? 'online' : 'offline');
    };

    var isOnline = function isOnline() {
        return navigator.onLine;
    };

    var wsReconnect = function wsReconnect() {
        if (isOnline() && BinarySocket.hasReadyState(2, 3)) {
            // CLOSING or CLOSED
            BinarySocket.init(ws_config);
        } else {
            BinarySocket.send({ ping: 1 }); // trigger a request to get stable status sooner
        }
    };

    var setStatus = function setStatus(status) {
        if (!isOnline()) {
            network_status = 'offline';
        } else if (pending_keys[status] || network_status === 'offline') {
            network_status = 'blinking';
            wsReconnect();
        } else {
            network_status = 'online';
        }

        if (typeof updateUI === 'function') {
            updateUI(status_config[network_status], isOnline());
        }
    };

    var ws_events_map = {
        init: function init() {
            return setPending(pending_keys.ws_init);
        },
        open: function open() {
            return clearPendings(pending_keys.ws_init);
        },
        send: function send() {
            return setPending(pending_keys.ws_request);
        },
        message: function message() {
            return clearPendings();
        },
        close: function close() {
            return setPending(pending_keys.ws_init);
        }
    };

    var wsEvent = function wsEvent(event) {
        if (typeof ws_events_map[event] === 'function') {
            ws_events_map[event]();
        }
    };

    var setPending = function setPending(key) {
        if (!pendings[key]) {
            pendings[key] = setTimeout(function () {
                pendings[key] = undefined;
                setStatus(key);
            }, pending_timeouts[key]);
        }
    };

    var clearPendings = function clearPendings(key) {
        var clear = function clear(k) {
            clearTimeout(pendings[k]);
            pendings[k] = undefined;
            if (k === pending_keys.ws_request) {
                setStatus('online');
            }
        };

        if (key) {
            clear(key);
        } else {
            Object.keys(pendings).forEach(clear);
        }
    };

    return {
        init: init,
        wsEvent: wsEvent
    };
}();

module.exports = NetworkMonitorBase;

/***/ }),
/* 242 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var moment = __webpack_require__(9);
var BinarySocket = __webpack_require__(86);

var ServerTime = function () {
    var clock_started = false;
    var server_time = void 0,
        client_time = void 0,
        get_time_interval = void 0,
        update_time_interval = void 0,
        onTimeUpdated = void 0;

    var init = function init(fncTimeUpdated) {
        if (!clock_started) {
            onTimeUpdated = fncTimeUpdated;
            requestTime();
            clearInterval(get_time_interval);
            get_time_interval = setInterval(requestTime, 30000);
            clock_started = true;
        }
    };

    var requestTime = function requestTime() {
        client_time = moment().valueOf();
        BinarySocket.send({ time: 1 }).then(timeCounter);
    };

    var timeCounter = function timeCounter(response) {
        if (response.error) return;

        if (!clock_started) {
            init();
            return;
        }

        clearInterval(update_time_interval);

        var start_timestamp = response.time;
        var client_time_at_response = moment().valueOf();
        var server_time_at_response = start_timestamp * 1000 + (client_time_at_response - client_time);

        var updateTime = function updateTime() {
            server_time = moment(server_time_at_response + moment().valueOf() - client_time_at_response).utc();

            if (typeof onTimeUpdated === 'function') {
                onTimeUpdated();
            }
        };
        updateTime();
        update_time_interval = setInterval(updateTime, 1000);
    };

    var get = function get() {
        return server_time ? server_time.clone() : undefined;
    };

    return {
        init: init,
        get: get
    };
}();

module.exports = ServerTime;

/***/ }),
/* 243 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Mellt = __webpack_require__(244);
var localize = __webpack_require__(2).localize;

var checkPassword = function checkPassword(password_selector) {
    var el_password = document.querySelector(password_selector);
    if (!el_password) {
        return;
    }

    var div = el_password.parentNode.querySelector('.days_to_crack') || document.createElement('div');

    var daysToCrack = Mellt.checkPassword(el_password.value.trim());
    if (daysToCrack < 0) {
        div.textContent = localize('The password you entered is one of the world\'s most commonly used passwords. You should not be using this password.');
    } else {
        var years = void 0;
        if (daysToCrack > 365) {
            years = Math.round(daysToCrack / 365 * 10) / 10;
            if (years > 1000000) {
                years = Math.round(years / 1000000 * 10) / 10 + ' ' + localize('million');
            } else if (years > 1000) {
                years = Math.round(years / 1000) + ' ' + localize('thousand');
            }
        }
        div.textContent = localize('Hint: it would take approximately [_1][_2] to crack this password.', [daysToCrack === 1000000000 ? '>' : '', years ? years + ' ' + localize('years') : daysToCrack + ' ' + localize('days')]);
    }
    div.className = 'days_to_crack fill-bg-color hint ' + (daysToCrack < 30 ? 'red' : 'green');
    el_password.parentNode.appendChild(div);
};

var removeCheck = function removeCheck(password_selector) {
    var el_message = document.querySelector(password_selector).parentNode.querySelector('.days_to_crack');
    if (el_message) {
        el_message.remove();
    }
};

module.exports = {
    removeCheck: removeCheck,
    checkPassword: checkPassword
};

/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var CommonPasswords = __webpack_require__(245);

/**
 * Mellt
 *
 * Tests the strength of a password by calculating how long it would take to
 * brute force it.
 *
 * @version 0.1.0
 * @link http://mel.lt/ The homepage for this script.
 * @link http://www.hammerofgod.com/passwordcheck.aspx Much of this is based
 * on the description of Thor's Godly Privacy password strength checker,
 * however the actual code below is all my own.
 * @link http://xato.net/passwords/more-top-worst-passwords/ The included
 * common passwords list is from Mark Burnett's password collection (which
 * is excellent). You can of course use your own password file instead.
 */
var Mellt = function () {

    // We're making some guesses here about human nature (again much of this is
    // based on the TGP password strength checker, and Timothy "Thor" Mullen
    // deserves the credit for the thinking behind this). Basically we're combining
    // what we know about users (SHIFT+numbers are more common than other
    // punctuation for example) combined with how an attacker will attack a
    // password (most common letters first, expanding outwards).
    //
    // If you want to support passwords that use non-english characters, and
    // your attacker knows this (for example, a Russian site would be expected
    // to contain passwords in Russian characters) add your characters to one of
    // the sets below, or create new sets and insert them in the right places.
    var character_sets = ["0123456789", "abcdefghijklmnopqrstuvwxyz", "abcdefghijklmnopqrstuvwxyz0123456789", "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ", "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789", "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()-=_+", "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()-=_+[]\"{}|;':,./<>?`~"];

    /**
     * Tests password strength by simulating how long it would take a cracker to
     * brute force your password.
     *
     * Also optionally tests against a list of common passwords (contained in an
     * external file) to weed out things like "password", which from a pure brute
     * force perspective would be harder to break if it wasn't so common.
     *
     * The character sets being used in this checker assume English (ASCII)
     * characters (no umlauts for example). If you run a non-english site, and you
     * suspect the crackers will realize this, you may want to modify the
     * character set to include the characters in your language.
     *
     * @param password string, The password to test the strength of
     * @return number Returns a number specifying how many days it would take
     * to brute force the password (at 1 billion checks a second) or -1 to
     * indicate the password was found in the common passwords file. Obviously if
     * they don't have direct access to the hashed passwords this time would be
     * longer, and even then most computers (at the time of this writing) won't be
     * able to test 1 billion hashes a second, but this function measures worst
     * case scenario, so... I would recommend you require at least 30 days to brute
     * force a password, obviously more if you're a bank or other secure system.
     * @throws Exception If an error is encountered.
     */
    var checkPassword = function checkPassword(password) {

        // First check passwords in the common password file if available.
        // We do this because "password" takes 129 seconds, but is the first
        // thing an attacker will try.
        if (CommonPasswords.find(function (pass) {
            return pass === password.toLowerCase();
        })) {
            // If their password exists in the common file, then it's
            // zero time to crack this terrible password.
            return -1;
        }

        // Figure out which character set the password is using (based on the most "complex" character in it).
        var base = '';
        var base_key = null;
        var found_char = void 0;

        var _loop = function _loop(i) {
            found_char = false;
            character_sets.some(function (character_set, idx) {
                if (base_key <= idx && character_set.indexOf(password[i]) > -1) {
                    base_key = idx;
                    base = character_set;
                    found_char = true;
                    return true;
                }
                return false;
            });
            // If the character we were looking for wasn't anywhere in any of the
            // character sets, assign the largest (last) character set as default.
            if (!found_char) {
                base = character_sets[character_sets.length - 1];
                return "break";
            }
        };

        for (var i = 0; i < password.length; i++) {
            var _ret = _loop(i);

            if (_ret === "break") break;
        }

        // Starting at the first character, figure out it's position in the character set
        // and how many attempts will take to get there. For example, say your password
        // was an integer (a bank card PIN number for example):
        // 0 (or 0000 if you prefer) would be the very first password they attempted by the attacker.
        // 9999 would be the last password they attempted (assuming 4 characters).
        // Thus a password/PIN of 6529 would take 6529 attempts until the attacker found
        // the proper combination. The same logic words for alphanumeric passwords, just
        // with a larger number of possibilities for each position in the password. The
        // key thing to note is the attacker doesn't need to test the entire range (every
        // possible combination of all characters) they just need to get to the point in
        // the list of possibilities that is your password. They can (in this example)
        // ignore anything between 6530 and 9999. Using this logic, 'aaa' would be a worse
        // password than 'zzz', because the attacker would encounter 'aaa' first.
        var attempts = 0;
        for (var i = 0; i < password.length; i++) {
            // We power up to the reverse position in the string. For example, if we're trying
            // to hack the 4 character PING code in the example above:
            // First number * (number of characters possible in the charset ^ length of password)
            // ie: 6 * (10^4) = 6000
            // then add that same equation for the second number:
            // 5 * (10^3) = 500
            // then the third numbers
            // 2 * (10^2) = 20
            // and add on the last number
            // 9
            // Totals: 6000 + 500 + 20 + 9 = 6529 attempts before we encounter the correct password.
            var power_of = password.length - i - 1;
            // Character position within the base set. We add one on because strpos is base
            // 0, we want base 1.
            var char_at_position = base.indexOf(password[i]) + 1;
            // If we're at the last character, simply add it's position in the character set
            // this would be the "9" in the pin code example above.
            if (power_of === 0) {
                attempts += char_at_position;
            }
            // Otherwise we need to iterate through all the other characters positions to
            // get here. For example, to find the 5 in 25 we can't just guess 2 and then 5
            // (even though Hollywood seems to insist this is possible), we need to try 0,1,
            // 2,3...15,16,17...23,24,25 (got it).
            else {
                    // This means we have to try every combination of values up to this point for
                    // all previous characters. Which means we need to iterate through the entire
                    // character set, X times, where X is our position -1. Then we need to multiply
                    // that by this character's position.

                    // Multiplier is the (10^4) or (10^3), etc in the pin code example above.
                    // New attempts is the number of attempts we're adding for this position.
                    // Add that on to our existing number of attempts.
                    attempts += char_at_position * Math.pow(base.length, power_of);
                }
        }

        // We can (worst case) try a billion passwords a second. Calculate how many days it
        // will take us to get to the password.
        // This allows us to calculate a number of days to crack. We use days because anything
        // that can be cracked in less than a day is basically useless, so there's no point in
        // having a smaller granularity (hours for example).
        var days = attempts / (1000000000 * 60 * 60 * 24);

        // If it's going to take more than a billion days to crack, just return a billion. This
        // helps when code outside this function isn't using bcmath. Besides, if the password
        // can survive 2.7 million years it's probably ok.
        return days > 1000000000 ? 1000000000 : Math.round(days);
    };

    return {
        checkPassword: checkPassword
    };
}();

module.exports = Mellt;

/***/ }),
/* 245 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var CommonPasswords = ["password", "123456", "12345678", "1234", "qwerty", "12345", "dragon", "pussy", "baseball", "football", "letmein", "monkey", "696969", "abc123", "mustang", "michael", "shadow", "master", "jennifer", "111111", "2000", "jordan", "superman", "harley", "1234567", "fuckme", "hunter", "fuckyou", "trustno1", "ranger", "buster", "thomas", "tigger", "robert", "soccer", "fuck", "batman", "test", "pass", "killer", "hockey", "george", "charlie", "andrew", "michelle", "love", "sunshine", "jessica", "asshole", "6969", "pepper", "daniel", "access", "123456789", "654321", "joshua", "maggie", "starwars", "silver", "william", "dallas", "yankees", "123123", "ashley", "666666", "hello", "amanda", "orange", "biteme", "freedom", "computer", "sexy", "thunder", "nicole", "ginger", "heather", "hammer", "summer", "corvette", "taylor", "fucker", "austin", "1111", "merlin", "matthew", "121212", "golfer", "cheese", "princess", "martin", "chelsea", "patrick", "richard", "diamond", "yellow", "bigdog", "secret", "asdfgh", "sparky", "cowboy", "camaro", "anthony", "matrix", "falcon", "iloveyou", "bailey", "guitar", "jackson", "purple", "scooter", "phoenix", "aaaaaa", "morgan", "tigers", "porsche", "mickey", "maverick", "cookie", "nascar", "peanut", "justin", "131313", "money", "horny", "samantha", "panties", "steelers", "joseph", "snoopy", "boomer", "whatever", "iceman", "smokey", "gateway", "dakota", "cowboys", "eagles", "chicken", "dick", "black", "zxcvbn", "please", "andrea", "ferrari", "knight", "hardcore", "melissa", "compaq", "coffee", "booboo", "bitch", "johnny", "bulldog", "xxxxxx", "welcome", "james", "player", "ncc1701", "wizard", "scooby", "charles", "junior", "internet", "bigdick", "mike", "brandy", "tennis", "blowjob", "banana", "monster", "spider", "lakers", "miller", "rabbit", "enter", "mercedes", "brandon", "steven", "fender", "john", "yamaha", "diablo", "chris", "boston", "tiger", "marine", "chicago", "rangers", "gandalf", "winter", "bigtits", "barney", "edward", "raiders", "porn", "badboy", "blowme", "spanky", "bigdaddy", "johnson", "chester", "london", "midnight", "blue", "fishing", "000000", "hannah", "slayer", "11111111", "rachel", "sexsex", "redsox", "thx1138", "asdf", "marlboro", "panther", "zxcvbnm", "arsenal", "oliver", "qazwsx", "mother", "victoria", "7777777", "jasper", "angel", "david", "winner", "crystal", "golden", "butthead", "viking", "jack", "iwantu", "shannon", "murphy", "angels", "prince", "cameron", "girls", "madison", "wilson", "carlos", "hooters", "willie", "startrek", "captain", "maddog", "jasmine", "butter", "booger", "angela", "golf", "lauren", "rocket", "tiffany", "theman", "dennis", "liverpoo", "flower", "forever", "green", "jackie", "muffin", "turtle", "sophie", "danielle", "redskins", "toyota", "jason", "sierra", "winston", "debbie", "giants", "packers", "newyork", "jeremy", "casper", "bubba", "112233", "sandra", "lovers", "mountain", "united", "cooper", "driver", "tucker", "helpme", "fucking", "pookie", "lucky", "maxwell", "8675309", "bear", "suckit", "gators", "5150", "222222", "shithead", "fuckoff", "jaguar", "monica", "fred", "happy", "hotdog", "tits", "gemini", "lover", "xxxxxxxx", "777777", "canada", "nathan", "victor", "florida", "88888888", "nicholas", "rosebud", "metallic", "doctor", "trouble", "success", "stupid", "tomcat", "warrior", "peaches", "apples", "fish", "qwertyui", "magic", "buddy", "dolphins", "rainbow", "gunner", "987654", "freddy", "alexis", "braves", "cock", "2112", "1212", "cocacola", "xavier", "dolphin", "testing", "bond007", "member", "calvin", "voodoo", "7777", "samson", "alex", "apollo", "fire", "tester", "walter", "beavis", "voyager", "peter", "porno", "bonnie", "rush2112", "beer", "apple", "scorpio", "jonathan", "skippy", "sydney", "scott", "red123", "power", "gordon", "travis", "beaver", "star", "jackass", "flyers", "boobs", "232323", "zzzzzz", "steve", "rebecca", "scorpion", "doggie", "legend", "ou812", "yankee", "blazer", "bill", "runner", "birdie", "bitches", "555555", "parker", "topgun", "asdfasdf", "heaven", "viper", "animal", "2222", "bigboy", "4444", "arthur", "baby", "private", "godzilla", "donald", "williams", "lifehack", "phantom", "dave", "rock", "august", "sammy", "cool", "brian", "platinum", "jake", "bronco", "paul", "mark", "frank", "heka6w2", "copper", "billy", "cumshot", "garfield", "willow", "cunt", "little", "carter", "slut", "albert", "69696969", "kitten", "super", "jordan23", "eagle1", "shelby", "america", "11111", "jessie", "house", "free", "123321", "chevy", "bullshit", "white", "broncos", "horney", "surfer", "nissan", "999999", "saturn", "airborne", "elephant", "marvin", "shit", "action", "adidas", "qwert", "kevin", "1313", "explorer", "walker", "police", "christin", "december", "benjamin", "wolf", "sweet", "therock", "king", "online", "dickhead", "brooklyn", "teresa", "cricket", "sharon", "dexter", "racing", "penis", "gregory", "0000", "teens", "redwings", "dreams", "michigan", "hentai", "magnum", "87654321", "nothing", "donkey", "trinity", "digital", "333333", "stella", "cartman", "guinness", "123abc", "speedy", "buffalo", "kitty", "pimpin", "eagle", "einstein", "kelly", "nelson", "nirvana", "vampire", "xxxx", "playboy", "louise", "pumpkin", "snowball", "test123", "girl", "sucker", "mexico", "beatles", "fantasy", "ford", "gibson", "celtic", "marcus", "cherry", "cassie", "888888", "natasha", "sniper", "chance", "genesis", "hotrod", "reddog", "alexande", "college", "jester", "passw0rd", "bigcock", "smith", "lasvegas", "carmen", "slipknot", "3333", "death", "kimberly", "1q2w3e", "eclipse", "1q2w3e4r", "stanley", "samuel", "drummer", "homer", "montana", "music", "aaaa", "spencer", "jimmy", "carolina", "colorado", "creative", "hello1", "rocky", "goober", "friday", "bollocks", "scotty", "abcdef", "bubbles", "hawaii", "fluffy", "mine", "stephen", "horses", "thumper", "5555", "pussies", "darkness", "asdfghjk", "pamela", "boobies", "buddha", "vanessa", "sandman", "naughty", "douglas", "honda", "matt", "azerty", "6666", "shorty", "money1", "beach", "loveme", "4321", "simple", "poohbear", "444444", "badass", "destiny", "sarah", "denise", "vikings", "lizard", "melanie", "assman", "sabrina", "nintendo", "water", "good", "howard", "time", "123qwe", "november", "xxxxx", "october", "leather", "bastard", "young", "101010", "extreme", "hard", "password1", "vincent", "pussy1", "lacrosse", "hotmail", "spooky", "amateur", "alaska", "badger", "paradise", "maryjane", "poop", "crazy", "mozart", "video", "russell", "vagina", "spitfire", "anderson", "norman", "eric", "cherokee", "cougar", "barbara", "long", "420420", "family", "horse", "enigma", "allison", "raider", "brazil", "blonde", "jones", "55555", "dude", "drowssap", "jeff", "school", "marshall", "lovely", "1qaz2wsx", "jeffrey", "caroline", "franklin", "booty", "molly", "snickers", "leslie", "nipples", "courtney", "diesel", "rocks", "eminem", "westside", "suzuki", "daddy", "passion", "hummer", "ladies", "zachary", "frankie", "elvis", "reggie", "alpha", "suckme", "simpson", "patricia", "147147", "pirate", "tommy", "semperfi", "jupiter", "redrum", "freeuser", "wanker", "stinky", "ducati", "paris", "natalie", "babygirl", "bishop", "windows", "spirit", "pantera", "monday", "patches", "brutus", "houston", "smooth", "penguin", "marley", "forest", "cream", "212121", "flash", "maximus", "nipple", "bobby", "bradley", "vision", "pokemon", "champion", "fireman", "indian", "softball", "picard", "system", "clinton", "cobra", "enjoy", "lucky1", "claire", "claudia", "boogie", "timothy", "marines", "security", "dirty", "admin", "wildcats", "pimp", "dancer", "hardon", "veronica", "fucked", "abcd1234", "abcdefg", "ironman", "wolverin", "remember", "great", "freepass", "bigred", "squirt", "justice", "francis", "hobbes", "kermit", "pearljam", "mercury", "domino", "9999", "denver", "brooke", "rascal", "hitman", "mistress", "simon", "tony", "bbbbbb", "friend", "peekaboo", "naked", "budlight", "electric", "sluts", "stargate", "saints", "bondage", "brittany", "bigman", "zombie", "swimming", "duke", "qwerty1", "babes", "scotland", "disney", "rooster", "brenda", "mookie", "swordfis", "candy", "duncan", "olivia", "hunting", "blink182", "alicia", "8888", "samsung", "bubba1", "whore", "virginia", "general", "passport", "aaaaaaaa", "erotic", "liberty", "arizona", "jesus", "abcd", "newport", "skipper", "rolltide", "balls", "happy1", "galore", "christ", "weasel", "242424", "wombat", "digger", "classic", "bulldogs", "poopoo", "accord", "popcorn", "turkey", "jenny", "amber", "bunny", "mouse", "007007", "titanic", "liverpool", "dreamer", "everton", "friends", "chevelle", "carrie", "gabriel", "psycho", "nemesis", "burton", "pontiac", "connor", "eatme", "lickme", "roland", "cumming", "mitchell", "ireland", "lincoln", "arnold", "spiderma", "patriots", "goblue", "devils", "eugene", "empire", "asdfg", "cardinal", "brown", "shaggy", "froggy", "qwer", "kawasaki", "kodiak", "people", "phpbb", "light", "54321", "kramer", "chopper", "hooker", "honey", "whynot", "lesbian", "lisa", "baxter", "adam", "snake", "teen", "ncc1701d", "qqqqqq", "airplane", "britney", "avalon", "sandy", "sugar", "sublime", "stewart", "wildcat", "raven", "scarface", "elizabet", "123654", "trucks", "wolfpack", "pervert", "lawrence", "raymond", "redhead", "american", "alyssa", "bambam", "movie", "woody", "shaved", "snowman", "tiger1", "chicks", "raptor", "1969", "stingray", "shooter", "france", "stars", "madmax", "kristen", "sports", "jerry", "789456", "garcia", "simpsons", "lights", "ryan", "looking", "chronic", "alison", "hahaha", "packard", "hendrix", "perfect", "service", "spring", "srinivas", "spike", "katie", "252525", "oscar", "brother", "bigmac", "suck", "single", "cannon", "georgia", "popeye", "tattoo", "texas", "party", "bullet", "taurus", "sailor", "wolves", "panthers", "japan", "strike", "flowers", "pussycat", "chris1", "loverboy", "berlin", "sticky", "marina", "tarheels", "fisher", "russia", "connie", "wolfgang", "testtest", "mature", "bass", "catch22", "juice", "michael1", "nigger", "159753", "women", "alpha1", "trooper", "hawkeye", "head", "freaky", "dodgers", "pakistan", "machine", "pyramid", "vegeta", "katana", "moose", "tinker", "coyote", "infinity", "inside", "pepsi", "letmein1", "bang", "control", "hercules", "morris", "james1", "tickle", "outlaw", "browns", "billybob", "pickle", "test1", "michele", "antonio", "sucks", "pavilion", "changeme", "caesar", "prelude", "tanner", "adrian", "darkside", "bowling", "wutang", "sunset", "robbie", "alabama", "danger", "zeppelin", "juan", "rusty", "pppppp", "nick", "2001", "ping", "darkstar", "madonna", "qwe123", "bigone", "casino", "cheryl", "charlie1", "mmmmmm", "integra", "wrangler", "apache", "tweety", "qwerty12", "bobafett", "simone", "none", "business", "sterling", "trevor", "transam", "dustin", "harvey", "england", "2323", "seattle", "ssssss", "rose", "harry", "openup", "pandora", "pussys", "trucker", "wallace", "indigo", "storm", "malibu", "weed", "review", "babydoll", "doggy", "dilbert", "pegasus", "joker", "catfish", "flipper", "valerie", "herman", "fuckit", "detroit", "kenneth", "cheyenne", "bruins", "stacey", "smoke", "joey", "seven", "marino", "fetish", "xfiles", "wonder", "stinger", "pizza", "babe", "pretty", "stealth", "manutd", "gracie", "gundam", "cessna", "longhorn", "presario", "mnbvcxz", "wicked", "mustang1", "victory", "21122112", "shelly", "awesome", "athena", "q1w2e3r4", "help", "holiday", "knicks", "street", "redneck", "12341234", "casey", "gizmo", "scully", "dragon1", "devildog", "triumph", "eddie", "bluebird", "shotgun", "peewee", "ronnie", "angel1", "daisy", "special", "metallica", "madman", "country", "impala", "lennon", "roscoe", "omega", "access14", "enterpri", "miranda", "search", "smitty", "blizzard", "unicorn", "tight", "rick", "ronald", "asdf1234", "harrison", "trigger", "truck", "danny", "home", "winnie", "beauty", "thailand", "1234567890", "cadillac", "castle", "tyler", "bobcat", "buddy1", "sunny", "stones", "asian", "freddie", "chuck", "butt", "loveyou", "norton", "hellfire", "hotsex", "indiana", "short", "panzer", "lonewolf", "trumpet", "colors", "blaster", "12121212", "fireball", "logan", "precious", "aaron", "elaine", "jungle", "atlanta", "gold", "corona", "curtis", "nikki", "polaris", "timber", "theone", "baller", "chipper", "orlando", "island", "skyline", "dragons", "dogs", "benson", "licker", "goldie", "engineer", "kong", "pencil", "basketba", "open", "hornet", "world", "linda", "barbie", "chan", "farmer", "valentin", "wetpussy", "indians", "larry", "redman", "foobar", "travel", "morpheus", "bernie", "target", "141414", "hotstuff", "photos", "laura", "savage", "holly", "rocky1", "fuck_inside", "dollar", "turbo", "design", "newton", "hottie", "moon", "202020", "blondes", "4128", "lestat", "avatar", "future", "goforit", "random", "abgrtyu", "jjjjjj", "cancer", "q1w2e3", "smiley", "goldberg", "express", "virgin", "zipper", "wrinkle1", "stone", "andy", "babylon", "dong", "powers", "consumer", "dudley", "monkey1", "serenity", "samurai", "99999999", "bigboobs", "skeeter", "lindsay", "joejoe", "master1", "aaaaa", "chocolat", "christia", "birthday", "stephani", "tang", "1234qwer", "alfred", "ball", "98765432", "maria", "sexual", "maxima", "77777777", "sampson", "buckeye", "highland", "kristin", "seminole", "reaper", "bassman", "nugget", "lucifer", "airforce", "nasty", "watson", "warlock", "2121", "philip", "always", "dodge", "chrissy", "burger", "bird", "snatch", "missy", "pink", "gang", "maddie", "holmes", "huskers", "piglet", "photo", "joanne", "hamilton", "dodger", "paladin", "christy", "chubby", "buckeyes", "hamlet", "abcdefgh", "bigfoot", "sunday", "manson", "goldfish", "garden", "deftones", "icecream", "blondie", "spartan", "julie", "harold", "charger", "brandi", "stormy", "sherry", "pleasure", "juventus", "rodney", "galaxy", "holland", "escort", "zxcvb", "planet", "jerome", "wesley", "blues", "song", "peace", "david1", "ncc1701e", "1966", "51505150", "cavalier", "gambit", "karen", "sidney", "ripper", "oicu812", "jamie", "sister", "marie", "martha", "nylons", "aardvark", "nadine", "minnie", "whiskey", "bing", "plastic", "anal", "babylon5", "chang", "savannah", "loser", "racecar", "insane", "yankees1", "mememe", "hansolo", "chiefs", "fredfred", "freak", "frog", "salmon", "concrete", "yvonne", "zxcv", "shamrock", "atlantis", "warren", "wordpass", "julian", "mariah", "rommel", "1010", "harris", "predator", "sylvia", "massive", "cats", "sammy1", "mister", "stud", "marathon", "rubber", "ding", "trunks", "desire", "montreal", "justme", "faster", "kathleen", "irish", "1999", "bertha", "jessica1", "alpine", "sammie", "diamonds", "tristan", "00000", "swinger", "shan", "stallion", "pitbull", "letmein2", "roberto", "ready", "april", "palmer", "ming", "shadow1", "audrey", "chong", "clitoris", "wang", "shirley", "fuckers", "jackoff", "bluesky", "sundance", "renegade", "hollywoo", "151515", "bernard", "wolfman", "soldier", "picture", "pierre", "ling", "goddess", "manager", "nikita", "sweety", "titans", "hang", "fang", "ficken", "niners", "bottom", "bubble", "hello123", "ibanez", "webster", "sweetpea", "stocking", "323232", "tornado", "lindsey", "content", "bruce", "buck", "aragorn", "griffin", "chen", "campbell", "trojan", "christop", "newman", "wayne", "tina", "rockstar", "father", "geronimo", "pascal", "crimson", "brooks", "hector", "penny", "anna", "google", "camera", "chandler", "fatcat", "lovelove", "cody", "cunts", "waters", "stimpy", "finger", "cindy", "wheels", "viper1", "latin", "robin", "greenday", "987654321", "creampie", "brendan", "hiphop", "willy", "snapper", "funtime", "duck", "trombone", "adult", "cotton", "cookies", "kaiser", "mulder", "westham", "latino", "jeep", "ravens", "aurora", "drizzt", "madness", "energy", "kinky", "314159", "sophia", "stefan", "slick", "rocker", "55555555", "freeman", "french", "mongoose", "speed", "dddddd", "hong", "henry", "hungry", "yang", "catdog", "cheng", "ghost", "gogogo", "randy", "tottenha", "curious", "butterfl", "mission", "january", "singer", "sherman", "shark", "techno", "lancer", "lalala", "autumn", "chichi", "orion", "trixie", "clifford", "delta", "bobbob", "bomber", "holden", "kang", "kiss", "1968", "spunky", "liquid", "mary", "beagle", "granny", "network", "bond", "kkkkkk", "millie", "1973", "biggie", "beetle", "teacher", "susan", "toronto", "anakin", "genius", "dream", "cocks", "dang", "bush", "karate", "snakes", "bangkok", "callie", "fuckyou2", "pacific", "daytona", "kelsey", "infantry", "skywalke", "foster", "felix", "sailing", "raistlin", "vanhalen", "huang", "herbert", "jacob", "blackie", "tarzan", "strider", "sherlock", "lang", "gong", "sang", "dietcoke", "ultimate", "tree", "shai", "sprite", "ting", "artist", "chai", "chao", "devil", "python", "ninja", "misty", "ytrewq", "sweetie", "superfly", "456789", "tian", "jing", "jesus1", "freedom1", "dian", "drpepper", "potter", "chou", "darren", "hobbit", "violet", "yong", "shen", "phillip", "maurice", "gloria", "nolimit", "mylove", "biscuit", "yahoo", "shasta", "sex4me", "smoker", "smile", "pebbles", "pics", "philly", "tong", "tintin", "lesbians", "marlin", "cactus", "frank1", "tttttt", "chun", "danni", "emerald", "showme", "pirates", "lian", "dogg", "colleen", "xiao", "xian", "tazman", "tanker", "patton", "toshiba", "richie", "alberto", "gotcha", "graham", "dillon", "rang", "emily", "keng", "jazz", "bigguy", "yuan", "woman", "tomtom", "marion", "greg", "chaos", "fossil", "flight", "racerx", "tuan", "creamy", "boss", "bobo", "musicman", "warcraft", "window", "blade", "shuang", "sheila", "shun", "lick", "jian", "microsoft", "rong", "allen", "feng", "getsome", "sally", "quality", "kennedy", "morrison", "1977", "beng", "wwwwww", "yoyoyo", "zhang", "seng", "teddy", "joanna", "andreas", "harder", "luke", "qazxsw", "qian", "cong", "chuan", "deng", "nang", "boeing", "keeper", "western", "isabelle", "1963", "subaru", "sheng", "thuglife", "teng", "jiong", "miao", "martina", "mang", "maniac", "pussie", "tracey", "a1b2c3", "clayton", "zhou", "zhuang", "xing", "stonecol", "snow", "spyder", "liang", "jiang", "memphis", "regina", "ceng", "magic1", "logitech", "chuang", "dark", "million", "blow", "sesame", "shao", "poison", "titty", "terry", "kuan", "kuai", "kyle", "mian", "guan", "hamster", "guai", "ferret", "florence", "geng", "duan", "pang", "maiden", "quan", "velvet", "nong", "neng", "nookie", "buttons", "bian", "bingo", "biao", "zhong", "zeng", "xiong", "zhun", "ying", "zong", "xuan", "zang", "0.0.000", "suan", "shei", "shui", "sharks", "shang", "shua", "small", "peng", "pian", "piao", "liao", "meng", "miami", "reng", "guang", "cang", "change", "ruan", "diao", "luan", "lucas", "qing", "chui", "chuo", "cuan", "nuan", "ning", "heng", "huan", "kansas", "muscle", "monroe", "weng", "whitney", "1passwor", "bluemoon", "zhui", "zhua", "xiang", "zheng", "zhen", "zhei", "zhao", "zhan", "yomama", "zhai", "zhuo", "zuan", "tarheel", "shou", "shuo", "tiao", "lady", "leonard", "leng", "kuang", "jiao", "13579", "basket", "qiao", "qiong", "qiang", "chuai", "nian", "niao", "niang", "huai", "22222222", "bianca", "zhuan", "zhuai", "shuan", "shuai", "stardust", "jumper", "margaret", "archie", "66666666", "charlott", "forget", "qwertz", "bones", "history", "milton", "waterloo", "2002", "stuff", "11223344", "office", "oldman", "preston", "trains", "murray", "vertigo", "246810", "black1", "swallow", "smiles", "standard", "alexandr", "parrot", "luther", "user", "nicolas", "1976", "surfing", "pioneer", "pete", "masters", "apple1", "asdasd", "auburn", "hannibal", "frontier", "panama", "lucy", "buffy", "brianna", "welcome1", "vette", "blue22", "shemale", "111222", "baggins", "groovy", "global", "turner", "181818", "1979", "blades", "spanking", "life", "byteme", "lobster", "collins", "dawg", "hilton", "japanese", "1970", "1964", "2424", "polo", "markus", "coco", "deedee", "mikey", "1972", "171717", "1701", "strip", "jersey", "green1", "capital", "sasha", "sadie", "putter", "vader", "seven7", "lester", "marcel", "banshee", "grendel", "gilbert", "dicks", "dead", "hidden", "iloveu", "1980", "sound", "ledzep", "michel", "147258", "female", "bugger", "buffett", "bryan", "hell", "kristina", "molson", "2020", "wookie", "sprint", "thanks", "jericho", "102030", "grace", "fuckin", "mandy", "ranger1", "trebor", "deepthroat", "bonehead", "molly1", "mirage", "models", "1984", "2468", "stuart", "showtime", "squirrel", "pentium", "mario", "anime", "gator", "powder", "twister", "connect", "neptune", "bruno", "butts", "engine", "eatshit", "mustangs", "woody1", "shogun", "septembe", "pooh", "jimbo", "roger", "annie", "bacon", "center", "russian", "sabine", "damien", "mollie", "voyeur", "2525", "363636", "leonardo", "camel", "chair", "germany", "giant", "qqqq", "nudist", "bone", "sleepy", "tequila", "megan", "fighter", "garrett", "dominic", "obiwan", "makaveli", "vacation", "walnut", "1974", "ladybug", "cantona", "ccbill", "satan", "rusty1", "passwor1", "columbia", "napoleon", "dusty", "kissme", "motorola", "william1", "1967", "zzzz", "skater", "smut", "play", "matthew1", "robinson", "valley", "coolio", "dagger", "boner", "bull", "horndog", "jason1", "blake", "penguins", "rescue", "griffey", "8j4ye3uz", "californ", "champs", "qwertyuiop", "portland", "queen", "colt45", "boat", "xxxxxxx", "xanadu", "tacoma", "mason", "carpet", "gggggg", "safety", "palace", "italia", "stevie", "picturs", "picasso", "thongs", "tempest", "ricardo", "roberts", "asd123", "hairy", "foxtrot", "gary", "nimrod", "hotboy", "343434", "1111111", "asdfghjkl", "goose", "overlord", "blood", "wood", "stranger", "454545", "shaolin", "sooners", "socrates", "spiderman", "peanuts", "maxine", "rogers", "13131313", "andrew1", "filthy", "donnie", "ohyeah", "africa", "national", "kenny", "keith", "monique", "intrepid", "jasmin", "pickles", "assass", "fright", "potato", "darwin", "hhhhhh", "kingdom", "weezer", "424242", "pepsi1", "throat", "romeo", "gerard", "looker", "puppy", "butch", "monika", "suzanne", "sweets", "temple", "laurie", "josh", "megadeth", "analsex", "nymets", "ddddddd", "bigballs", "support", "stick", "today", "down", "oakland", "oooooo", "qweasd", "chucky", "bridge", "carrot", "chargers", "discover", "dookie", "condor", "night", "butler", "hoover", "horny1", "isabella", "sunrise", "sinner", "jojo", "megapass", "martini", "assfuck", "grateful", "ffffff", "abigail", "esther", "mushroom", "janice", "jamaica", "wright", "sims", "space", "there", "timmy", "7654321", "77777", "cccccc", "gizmodo", "roxanne", "ralph", "tractor", "cristina", "dance", "mypass", "hongkong", "helena", "1975", "blue123", "pissing", "thomas1", "redred", "rich", "basketball", "attack", "cash", "satan666", "drunk", "dixie", "dublin", "bollox", "kingkong", "katrina", "miles", "1971", "22222", "272727", "sexx", "penelope", "thompson", "anything", "bbbb", "battle", "grizzly", "passat", "porter", "tracy", "defiant", "bowler", "knickers", "monitor", "wisdom", "wild", "slappy", "thor", "letsgo", "robert1", "feet", "rush", "brownie", "hudson", "098765", "playing", "playtime", "lightnin", "melvin", "atomic", "bart", "hawk", "goku", "glory", "llllll", "qwaszx", "cosmos", "bosco", "knights", "bentley", "beast", "slapshot", "lewis", "assword", "frosty", "gillian", "sara", "dumbass", "mallard", "dddd", "deanna", "elwood", "wally", "159357", "titleist", "angelo", "aussie", "guest", "golfing", "doobie", "loveit", "chloe", "elliott", "werewolf", "vipers", "janine", "1965", "blabla", "surf", "sucking", "tardis", "serena", "shelley", "thegame", "legion", "rebels", "fernando", "fast", "gerald", "sarah1", "double", "onelove", "loulou", "toto", "crash", "blackcat", "0007", "tacobell", "soccer1", "jedi", "manuel", "method", "river", "chase", "ludwig", "poopie", "derrick", "boob", "breast", "kittycat", "isabel", "belly", "pikachu", "thunder1", "thankyou", "jose", "celeste", "celtics", "frances", "frogger", "scoobydo", "sabbath", "coltrane", "budman", "willis", "jackal", "bigger", "zzzzz", "silvia", "sooner", "licking", "gopher", "geheim", "lonestar", "primus", "pooper", "newpass", "brasil", "heather1", "husker", "element", "moomoo", "beefcake", "zzzzzzzz", "tammy", "shitty", "smokin", "personal", "jjjj", "anthony1", "anubis", "backup", "gorilla", "fuckface", "painter", "lowrider", "punkrock", "traffic", "claude", "daniela", "dale", "delta1", "nancy", "boys", "easy", "kissing", "kelley", "wendy", "theresa", "amazon", "alan", "fatass", "dodgeram", "dingdong", "malcolm", "qqqqqqqq", "breasts", "boots", "honda1", "spidey", "poker", "temp", "johnjohn", "miguel", "147852", "archer", "asshole1", "dogdog", "tricky", "crusader", "weather", "syracuse", "spankme", "speaker", "meridian", "amadeus", "back", "harley1", "falcons", "dorothy", "turkey50", "kenwood", "keyboard", "ilovesex", "1978", "blackman", "shazam", "shalom", "lickit", "jimbob", "richmond", "roller", "carson", "check", "fatman", "funny", "garbage", "sandiego", "loving", "magnus", "cooldude", "clover", "mobile", "bell", "payton", "plumber", "texas1", "tool", "topper", "jenna", "mariners", "rebel", "harmony", "caliente", "celica", "fletcher", "german", "diana", "oxford", "osiris", "orgasm", "punkin", "porsche9", "tuesday", "close", "breeze", "bossman", "kangaroo", "billie", "latinas", "judith", "astros", "scruffy", "donna", "qwertyu", "davis", "hearts", "kathy", "jammer", "java", "springer", "rhonda", "ricky", "1122", "goodtime", "chelsea1", "freckles", "flyboy", "doodle", "city", "nebraska", "bootie", "kicker", "webmaster", "vulcan", "iverson", "191919", "blueeyes", "stoner", "321321", "farside", "rugby", "director", "pussy69", "power1", "bobbie", "hershey", "hermes", "monopoly", "west", "birdman", "blessed", "blackjac", "southern", "peterpan", "thumbs", "lawyer", "melinda", "fingers", "fuckyou1", "rrrrrr", "a1b2c3d4", "coke", "nicola", "bohica", "heart", "elvis1", "kids", "blacky", "stories", "sentinel", "snake1", "phoebe", "jesse", "richard1", "1234abcd", "guardian", "candyman", "fisting", "scarlet", "dildo", "pancho", "mandingo", "lucky7", "condom", "munchkin", "billyboy", "summer1", "student", "sword", "skiing", "sergio", "site", "sony", "thong", "rootbeer", "assassin", "cassidy", "frederic", "fffff", "fitness", "giovanni", "scarlett", "durango", "postal", "achilles", "dawn", "dylan", "kisses", "warriors", "imagine", "plymouth", "topdog", "asterix", "hallo", "cameltoe", "fuckfuck", "bridget", "eeeeee", "mouth", "weird", "will", "sithlord", "sommer", "toby", "theking", "juliet", "avenger", "backdoor", "goodbye", "chevrole", "faith", "lorraine", "trance", "cosworth", "brad", "houses", "homers", "eternity", "kingpin", "verbatim", "incubus", "1961", "blond", "zaphod", "shiloh", "spurs", "station", "jennie", "maynard", "mighty", "aliens", "hank", "charly", "running", "dogman", "omega1", "printer", "aggies", "chocolate", "deadhead", "hope", "javier", "bitch1", "stone55", "pineappl", "thekid", "lizzie", "rockets", "ashton", "camels", "formula", "forrest", "rosemary", "oracle", "rain", "pussey", "porkchop", "abcde", "clancy", "nellie", "mystic", "inferno", "blackdog", "steve1", "pauline", "alexander", "alice", "alfa", "grumpy", "flames", "scream", "lonely", "puffy", "proxy", "valhalla", "unreal", "cynthia", "herbie", "engage", "yyyyyy", "010101", "solomon", "pistol", "melody", "celeb", "flying", "gggg", "santiago", "scottie", "oakley", "portugal", "a12345", "newbie", "mmmm", "venus", "1qazxsw2", "beverly", "zorro", "work", "writer", "stripper", "sebastia", "spread", "phil", "tobias", "links", "members", "metal", "1221", "andre", "565656", "funfun", "trojans", "again", "cyber", "hurrican", "moneys", "1x2zkg8w", "zeus", "thing", "tomato", "lion", "atlantic", "celine", "usa123", "trans", "account", "aaaaaaa", "homerun", "hyperion", "kevin1", "blacks", "44444444", "skittles", "sean", "hastings", "fart", "gangbang", "fubar", "sailboat", "older", "oilers", "craig", "conrad", "church", "damian", "dean", "broken", "buster1", "hithere", "immortal", "sticks", "pilot", "peters", "lexmark", "jerkoff", "maryland", "anders", "cheers", "possum", "columbus", "cutter", "muppet", "beautiful", "stolen", "swordfish", "sport", "sonic", "peter1", "jethro", "rockon", "asdfghj", "pass123", "paper", "pornos", "ncc1701a", "bootys", "buttman", "bonjour", "escape", "1960", "becky", "bears", "362436", "spartans", "tinman", "threesom", "lemons", "maxmax", "1414", "bbbbb", "camelot", "chad", "chewie", "gogo", "fusion", "saint", "dilligaf", "nopass", "myself", "hustler", "hunter1", "whitey", "beast1", "yesyes", "spank", "smudge", "pinkfloy", "patriot", "lespaul", "annette", "hammers", "catalina", "finish", "formula1", "sausage", "scooter1", "orioles", "oscar1", "over", "colombia", "cramps", "natural", "eating", "exotic", "iguana", "bella", "suckers", "strong", "sheena", "start", "slave", "pearl", "topcat", "lancelot", "angelica", "magelan", "racer", "ramona", "crunch", "british", "button", "eileen", "steph", "456123", "skinny", "seeking", "rockhard", "chief", "filter", "first", "freaks", "sakura", "pacman", "poontang", "dalton", "newlife", "homer1", "klingon", "watcher", "walleye", "tasha", "tasty", "sinatra", "starship", "steel", "starbuck", "poncho", "amber1", "gonzo", "grover", "catherin", "carol", "candle", "firefly", "goblin", "scotch", "diver", "usmc", "huskies", "eleven", "kentucky", "kitkat", "israel", "beckham", "bicycle", "yourmom", "studio", "tara", "33333333", "shane", "splash", "jimmy1", "reality", "12344321", "caitlin", "focus", "sapphire", "mailman", "raiders1", "clark", "ddddd", "hopper", "excalibu", "more", "wilbur", "illini", "imperial", "phillips", "lansing", "maxx", "gothic", "golfball", "carlton", "camille", "facial", "front242", "macdaddy", "qwer1234", "vectra", "cowboys1", "crazy1", "dannyboy", "jane", "betty", "benny", "bennett", "leader", "martinez", "aquarius", "barkley", "hayden", "caught", "franky", "ffff", "floyd", "sassy", "pppp", "pppppppp", "prodigy", "clarence", "noodle", "eatpussy", "vortex", "wanking", "beatrice", "billy1", "siemens", "pedro", "phillies", "research", "groups", "carolyn", "chevy1", "cccc", "fritz", "gggggggg", "doughboy", "dracula", "nurses", "loco", "madrid", "lollipop", "trout", "utopia", "chrono", "cooler", "conner", "nevada", "wibble", "werner", "summit", "marco", "marilyn", "1225", "babies", "capone", "fugazi", "panda", "mama", "qazwsxed", "puppies", "triton", "9876", "command", "nnnnnn", "ernest", "momoney", "iforgot", "wolfie", "studly", "shawn", "renee", "alien", "hamburg", "81fukkc", "741852", "catman", "china", "forgot", "gagging", "scott1", "drew", "oregon", "qweqwe", "train", "crazybab", "daniel1", "cutlass", "brothers", "holes", "heidi", "mothers", "music1", "what", "walrus", "1957", "bigtime", "bike", "xtreme", "simba", "ssss", "rookie", "angie", "bathing", "fresh", "sanchez", "rotten", "maestro", "luis", "look", "turbo1", "99999", "butthole", "hhhh", "elijah", "monty", "bender", "yoda", "shania", "shock", "phish", "thecat", "rightnow", "reagan", "baddog", "asia", "greatone", "gateway1", "randall", "abstr", "napster", "brian1", "bogart", "high", "hitler", "emma", "kill", "weaver", "wildfire", "jackson1", "isaiah", "1981", "belinda", "beaner", "yoyo", "0.0.0.000", "super1", "select", "snuggles", "slutty", "some", "phoenix1", "technics", "toon", "raven1", "rayray", "123789", "1066", "albion", "greens", "fashion", "gesperrt", "santana", "paint", "powell", "credit", "darling", "mystery", "bowser", "bottle", "brucelee", "hehehe", "kelly1", "mojo", "1998", "bikini", "woofwoof", "yyyy", "strap", "sites", "spears", "theodore", "julius", "richards", "amelia", "central", "f**k", "nyjets", "punisher", "username", "vanilla", "twisted", "bryant", "brent", "bunghole", "here", "elizabeth", "erica", "kimber", "viagra", "veritas", "pony", "pool", "titts", "labtec", "lifetime", "jenny1", "masterbate", "mayhem", "redbull", "govols", "gremlin", "505050", "gmoney", "rupert", "rovers", "diamond1", "lorenzo", "trident", "abnormal", "davidson", "deskjet", "cuddles", "nice", "bristol", "karina", "milano", "vh5150", "jarhead", "1982", "bigbird", "bizkit", "sixers", "slider", "star69", "starfish", "penetration", "tommy1", "john316", "meghan", "michaela", "market", "grant", "caligula", "carl", "flicks", "films", "madden", "railroad", "cosmo", "cthulhu", "bradford", "br0d3r", "military", "bearbear", "swedish", "spawn", "patrick1", "polly", "these", "todd", "reds", "anarchy", "groove", "franco", "fuckher", "oooo", "tyrone", "vegas", "airbus", "cobra1", "christine", "clips", "delete", "duster", "kitty1", "mouse1", "monkeys", "jazzman", "1919", "262626", "swinging", "stroke", "stocks", "sting", "pippen", "labrador", "jordan1", "justdoit", "meatball", "females", "saturday", "park", "vector", "cooter", "defender", "desert", "demon", "nike", "bubbas", "bonkers", "english", "kahuna", "wildman", "4121", "sirius", "static", "piercing", "terror", "teenage", "leelee", "marissa", "microsof", "mechanic", "robotech", "rated", "hailey", "chaser", "sanders", "salsero", "nuts", "macross", "quantum", "rachael", "tsunami", "universe", "daddy1", "cruise", "nguyen", "newpass6", "nudes", "hellyeah", "vernon", "1959", "zaq12wsx", "striker", "sixty", "steele", "spice", "spectrum", "smegma", "thumb", "jjjjjjjj", "mellow", "astrid", "cancun", "cartoon", "sabres", "samiam", "pants", "oranges", "oklahoma", "lust", "coleman", "denali", "nude", "noodles", "buzz", "brest", "hooter", "mmmmmmmm", "warthog", "bloody", "blueblue", "zappa", "wolverine", "sniffing", "lance", "jean", "jjjjj", "harper", "calico", "freee", "rover", "door", "pooter", "closeup", "bonsai", "evelyn", "emily1", "kathryn", "keystone", "iiii", "1955", "yzerman", "theboss", "tolkien", "jill", "megaman", "rasta", "bbbbbbbb", "bean", "handsome", "hal9000", "goofy", "gringo", "gofish", "gizmo1", "samsam", "scuba", "onlyme", "tttttttt", "corrado", "clown", "clapton", "deborah", "boris", "bulls", "vivian", "jayhawk", "bethany", "wwww", "sharky", "seeker", "ssssssss", "somethin", "pillow", "thesims", "lighter", "lkjhgf", "melissa1", "marcius2", "barry", "guiness", "gymnast", "casey1", "goalie", "godsmack", "doug", "lolo", "rangers1", "poppy", "abby", "clemson", "clipper", "deeznuts", "nobody", "holly1", "elliot", "eeee", "kingston", "miriam", "belle", "yosemite", "sucked", "sex123", "sexy69", "pic's", "tommyboy", "lamont", "meat", "masterbating", "marianne", "marc", "gretzky", "happyday", "frisco", "scratch", "orchid", "orange1", "manchest", "quincy", "unbelievable", "aberdeen", "dawson", "nathalie", "ne1469", "boxing", "hill", "korn", "intercourse", "161616", "1985", "ziggy", "supersta", "stoney", "senior", "amature", "barber", "babyboy", "bcfields", "goliath", "hack", "hardrock", "children", "frodo", "scout", "scrappy", "rosie", "qazqaz", "tracker", "active", "craving", "commando", "cohiba", "deep", "cyclone", "dana", "bubba69", "katie1", "mpegs", "vsegda", "jade", "irish1", "better", "sexy1", "sinclair", "smelly", "squerting", "lions", "jokers", "jeanette", "julia", "jojojo", "meathead", "ashley1", "groucho", "cheetah", "champ", "firefox", "gandalf1", "packer", "magnolia", "love69", "tyler1", "typhoon", "tundra", "bobby1", "kenworth", "village", "volley", "beth", "wolf359", "0420", "000007", "swimmer", "skydive", "smokes", "patty", "peugeot", "pompey", "legolas", "kristy", "redhot", "rodman", "redalert", "having", "grapes", "4runner", "carrera", "floppy", "dollars", "ou8122", "quattro", "adams", "cloud9", "davids", "nofear", "busty", "homemade", "mmmmm", "whisper", "vermont", "webmaste", "wives", "insertion", "jayjay", "philips", "phone", "topher", "tongue", "temptress", "midget", "ripken", "havefun", "gretchen", "canon", "celebrity", "five", "getting", "ghetto", "direct", "otto", "ragnarok", "trinidad", "usnavy", "conover", "cruiser", "dalshe", "nicole1", "buzzard", "hottest", "kingfish", "misfit", "moore", "milfnew", "warlord", "wassup", "bigsexy", "blackhaw", "zippy", "shearer", "tights", "thursday", "kungfu", "labia", "journey", "meatloaf", "marlene", "rider", "area51", "batman1", "bananas", "636363", "cancel", "ggggg", "paradox", "mack", "lynn", "queens", "adults", "aikido", "cigars", "nova", "hoosier", "eeyore", "moose1", "warez", "interacial", "streaming", "313131", "pertinant", "pool6123", "mayday", "rivers", "revenge", "animated", "banker", "baddest", "gordon24", "ccccc", "fortune", "fantasies", "touching", "aisan", "deadman", "homepage", "ejaculation", "whocares", "iscool", "jamesbon", "1956", "1pussy", "womam", "sweden", "skidoo", "spock", "sssss", "petra", "pepper1", "pinhead", "micron", "allsop", "amsterda", "army", "aside", "gunnar", "666999", "chip", "foot", "fowler", "february", "face", "fletch", "george1", "sapper", "science", "sasha1", "luckydog", "lover1", "magick", "popopo", "public", "ultima", "derek", "cypress", "booker", "businessbabe", "brandon1", "edwards", "experience", "vulva", "vvvv", "jabroni", "bigbear", "yummy", "010203", "searay", "secret1", "showing", "sinbad", "sexxxx", "soleil", "software", "piccolo", "thirteen", "leopard", "legacy", "jensen", "justine", "memorex", "marisa", "mathew", "redwing", "rasputin", "134679", "anfield", "greenbay", "gore", "catcat", "feather", "scanner", "pa55word", "contortionist", "danzig", "daisy1", "hores", "erik", "exodus", "vinnie", "iiiiii", "zero", "1001", "subway", "tank", "second", "snapple", "sneakers", "sonyfuck", "picks", "poodle", "test1234", "their", "llll", "junebug", "june", "marker", "mellon", "ronaldo", "roadkill", "amanda1", "asdfjkl", "beaches", "greene", "great1", "cheerleaers", "force", "doitnow", "ozzy", "madeline", "radio", "tyson", "christian", "daphne", "boxster", "brighton", "housewifes", "emmanuel", "emerson", "kkkk", "mnbvcx", "moocow", "vides", "wagner", "janet", "1717", "bigmoney", "blonds", "1000", "storys", "stereo", "4545", "420247", "seductive", "sexygirl", "lesbean", "live", "justin1", "124578", "animals", "balance", "hansen", "cabbage", "canadian", "gangbanged", "dodge1", "dimas", "lori", "loud", "malaka", "puss", "probes", "adriana", "coolman", "crawford", "dante", "nacked", "hotpussy", "erotica", "kool", "mirror", "wearing", "implants", "intruder", "bigass", "zenith", "woohoo", "womans", "tanya", "tango", "stacy", "pisces", "laguna", "krystal", "maxell", "andyod22", "barcelon", "chainsaw", "chickens", "flash1", "downtown", "orgasms", "magicman", "profit", "pusyy", "pothead", "coconut", "chuckie", "contact", "clevelan", "designer", "builder", "budweise", "hotshot", "horizon", "hole", "experienced", "mondeo", "wifes", "1962", "strange", "stumpy", "smiths", "sparks", "slacker", "piper", "pitchers", "passwords", "laptop", "jeremiah", "allmine", "alliance", "bbbbbbb", "asscock", "halflife", "grandma", "hayley", "88888", "cecilia", "chacha", "saratoga", "sandy1", "santos", "doogie", "number", "positive", "qwert40", "transexual", "crow", "close-up", "darrell", "bonita", "ib6ub9", "volvo", "jacob1", "iiiii", "beastie", "sunnyday", "stoned", "sonics", "starfire", "snapon", "pictuers", "pepe", "testing1", "tiberius", "lisalisa", "lesbain", "litle", "retard", "ripple", "austin1", "badgirl", "golfgolf", "flounder", "garage", "royals", "dragoon", "dickie", "passwor", "ocean", "majestic", "poppop", "trailers", "dammit", "nokia", "bobobo", "br549", "emmitt", "knock", "minime", "mikemike", "whitesox", "1954", "3232", "353535", "seamus", "solo", "sparkle", "sluttey", "pictere", "titten", "lback", "1024", "angelina", "goodluck", "charlton", "fingerig", "gallaries", "goat", "ruby", "passme", "oasis", "lockerroom", "logan1", "rainman", "twins", "treasure", "absolutely", "club", "custom", "cyclops", "nipper", "bucket", "homepage-", "hhhhh", "momsuck", "indain", "2345", "beerbeer", "bimmer", "susanne", "stunner", "stevens", "456456", "shell", "sheba", "tootsie", "tiny", "testerer", "reefer", "really", "1012", "harcore", "gollum", "545454", "chico", "caveman", "carole", "fordf150", "fishes", "gaymen", "saleen", "doodoo", "pa55w0rd", "looney", "presto", "qqqqq", "cigar", "bogey", "brewer", "helloo", "dutch", "kamikaze", "monte", "wasser", "vietnam", "visa", "japanees", "0123", "swords", "slapper", "peach", "jump", "marvel", "masterbaiting", "march", "redwood", "rolling", "1005", "ametuer", "chiks", "cathy", "callaway", "fucing", "sadie1", "panasoni", "mamas", "race", "rambo", "unknown", "absolut", "deacon", "dallas1", "housewife", "kristi", "keywest", "kirsten", "kipper", "morning", "wings", "idiot", "18436572", "1515", "beating", "zxczxc", "sullivan", "303030", "shaman", "sparrow", "terrapin", "jeffery", "masturbation", "mick", "redfish", "1492", "angus", "barrett", "goirish", "hardcock", "felicia", "forfun", "galary", "freeporn", "duchess", "olivier", "lotus", "pornographic", "ramses", "purdue", "traveler", "crave", "brando", "enter1", "killme", "moneyman", "welder", "windsor", "wifey", "indon", "yyyyy", "stretch", "taylor1", "4417", "shopping", "picher", "pickup", "thumbnils", "johnboy", "jets", "jess", "maureen", "anne", "ameteur", "amateurs", "apollo13", "hambone", "goldwing", "5050", "charley", "sally1", "doghouse", "padres", "pounding", "quest", "truelove", "underdog", "trader", "crack", "climber", "bolitas", "bravo", "hohoho", "model", "italian", "beanie", "beretta", "wrestlin", "stroker", "tabitha", "sherwood", "sexyman", "jewels", "johannes", "mets", "marcos", "rhino", "bdsm", "balloons", "goodman", "grils", "happy123", "flamingo", "games", "route66", "devo", "dino", "outkast", "paintbal", "magpie", "llllllll", "twilight", "critter", "christie", "cupcake", "nickel", "bullseye", "krista", "knickerless", "mimi", "murder", "videoes", "binladen", "xerxes", "slim", "slinky", "pinky", "peterson", "thanatos", "meister", "menace", "ripley", "retired", "albatros", "balloon", "bank", "goten", "5551212", "getsdown", "donuts", "divorce", "nwo4life", "lord", "lost", "underwear", "tttt", "comet", "deer", "damnit", "dddddddd", "deeznutz", "nasty1", "nonono", "nina", "enterprise", "eeeee", "misfit99", "milkman", "vvvvvv", "isaac", "1818", "blueboy", "beans", "bigbutt", "wyatt", "tech", "solution", "poetry", "toolman", "laurel", "juggalo", "jetski", "meredith", "barefoot", "50spanks", "gobears", "scandinavian", "original", "truman", "cubbies", "nitram", "briana", "ebony", "kings", "warner", "bilbo", "yumyum", "zzzzzzz", "stylus", "321654", "shannon1", "server", "secure", "silly", "squash", "starman", "steeler", "staples", "phrases", "techniques", "laser", "135790", "allan", "barker", "athens", "cbr600", "chemical", "fester", "gangsta", "fucku2", "freeze", "game", "salvador", "droopy", "objects", "passwd", "lllll", "loaded", "louis", "manchester", "losers", "vedder", "clit", "chunky", "darkman", "damage", "buckshot", "buddah", "boobed", "henti", "hillary", "webber", "winter1", "ingrid", "bigmike", "beta", "zidane", "talon", "slave1", "pissoff", "person", "thegreat", "living", "lexus", "matador", "readers", "riley", "roberta", "armani", "ashlee", "goldstar", "5656", "cards", "fmale", "ferris", "fuking", "gaston", "fucku", "ggggggg", "sauron", "diggler", "pacers", "looser", "pounded", "premier", "pulled", "town", "trisha", "triangle", "cornell", "collin", "cosmic", "deeper", "depeche", "norway", "bright", "helmet", "kristine", "kendall", "mustard", "misty1", "watch", "jagger", "bertie", "berger", "word", "3x7pxr", "silver1", "smoking", "snowboar", "sonny", "paula", "penetrating", "photoes", "lesbens", "lambert", "lindros", "lillian", "roadking", "rockford", "1357", "143143", "asasas", "goodboy", "898989", "chicago1", "card", "ferrari1", "galeries", "godfathe", "gawker", "gargoyle", "gangster", "rubble", "rrrr", "onetime", "pussyman", "pooppoop", "trapper", "twenty", "abraham", "cinder", "company", "newcastl", "boricua", "bunny1", "boxer", "hotred", "hockey1", "hooper", "edward1", "evan", "kris", "misery", "moscow", "milk", "mortgage", "bigtit", "show", "snoopdog", "three", "lionel", "leanne", "joshua1", "july", "1230", "assholes", "cedric", "fallen", "farley", "gene", "frisky", "sanity", "script", "divine", "dharma", "lucky13", "property", "tricia", "akira", "desiree", "broadway", "butterfly", "hunt", "hotbox", "hootie", "heat", "howdy", "earthlink", "karma", "kiteboy", "motley", "westwood", "1988", "bert", "blackbir", "biggles", "wrench", "working", "wrestle", "slippery", "pheonix", "penny1", "pianoman", "tomorrow", "thedude", "jenn", "jonjon", "jones1", "mattie", "memory", "micheal", "roadrunn", "arrow", "attitude", "azzer", "seahawks", "diehard", "dotcom", "lola", "tunafish", "chivas", "cinnamon", "clouds", "deluxe", "northern", "nuclear", "north", "boom", "boobie", "hurley", "krishna", "momomo", "modles", "volume", "23232323", "bluedog", "wwwwwww", "zerocool", "yousuck", "pluto", "limewire", "link", "joung", "marcia", "awnyce", "gonavy", "haha", "films+pic+galeries", "fabian", "francois", "girsl", "fuckthis", "girfriend", "rufus", "drive", "uncencored", "a123456", "airport", "clay", "chrisbln", "combat", "cygnus", "cupoi", "never", "netscape", "brett", "hhhhhhhh", "eagles1", "elite", "knockers", "kendra", "mommy", "1958", "tazmania", "shonuf", "piano", "pharmacy", "thedog", "lips", "jillian", "jenkins", "midway", "arsenal1", "anaconda", "australi", "gromit", "gotohell", "787878", "66666", "carmex2", "camber", "gator1", "ginger1", "fuzzy", "seadoo", "dorian", "lovesex", "rancid", "uuuuuu", "911911", "nature", "bulldog1", "helen", "health", "heater", "higgins", "kirk", "monalisa", "mmmmmmm", "whiteout", "virtual", "ventura", "jamie1", "japanes", "james007", "2727", "2469", "blam", "bitchass", "believe", "zephyr", "stiffy", "sweet1", "silent", "southpar", "spectre", "tigger1", "tekken", "lenny", "lakota", "lionking", "jjjjjjj", "medical", "megatron", "1369", "hawaiian", "gymnastic", "golfer1", "gunners", "7779311", "515151", "famous", "glass", "screen", "rudy", "royal", "sanfran", "drake", "optimus", "panther1", "love1", "mail", "maggie1", "pudding", "venice", "aaron1", "delphi", "niceass", "bounce", "busted", "house1", "killer1", "miracle", "momo", "musashi", "jammin", "2003", "234567", "wp2003wp", "submit", "silence", "sssssss", "state", "spikes", "sleeper", "passwort", "toledo", "kume", "media", "meme", "medusa", "mantis", "remote", "reading", "reebok", "1017", "artemis", "hampton", "harry1", "cafc91", "fettish", "friendly", "oceans", "oooooooo", "mango", "ppppp", "trainer", "troy", "uuuu", "909090", "cross", "death1", "news", "bullfrog", "hokies", "holyshit", "eeeeeee", "mitch", "jasmine1", "&amp", "&amp;", "sergeant", "spinner", "leon", "jockey", "records", "right", "babyblue", "hans", "gooner", "474747", "cheeks", "cars", "candice", "fight", "glow", "pass1234", "parola", "okokok", "pablo", "magical", "major", "ramsey", "poseidon", "989898", "confused", "circle", "crusher", "cubswin", "nnnn", "hollywood", "erin", "kotaku", "milo", "mittens", "whatsup", "vvvvv", "iomega", "insertions", "bengals", "bermuda", "biit", "yellow1", "012345", "spike1", "south", "sowhat", "pitures", "peacock", "pecker", "theend", "juliette", "jimmie", "romance", "augusta", "hayabusa", "hawkeyes", "castro", "florian", "geoffrey", "dolly", "lulu", "qaz123", "usarmy", "twinkle", "cloud", "chuckles", "cold", "hounddog", "hover", "hothot", "europa", "ernie", "kenshin", "kojak", "mikey1", "water1", "196969", "because", "wraith", "zebra", "wwwww", "33333", "simon1", "spider1", "snuffy", "philippe", "thunderb", "teddy1", "lesley", "marino13", "maria1", "redline", "renault", "aloha", "antoine", "handyman", "cerberus", "gamecock", "gobucks", "freesex", "duffman", "ooooo", "papa", "nuggets", "magician", "longbow", "preacher", "porno1", "county", "chrysler", "contains", "dalejr", "darius", "darlene", "dell", "navy", "buffy1", "hedgehog", "hoosiers", "honey1", "hott", "heyhey", "europe", "dutchess", "everest", "wareagle", "ihateyou", "sunflowe", "3434", "senators", "shag", "spoon", "sonoma", "stalker", "poochie", "terminal", "terefon", "laurence", "maradona", "maryann", "marty", "roman", "1007", "142536", "alibaba", "america1", "bartman", "astro", "goth", "century", "chicken1", "cheater", "four", "ghost1", "passpass", "oral", "r2d2c3po", "civic", "cicero", "myxworld", "kkkkk", "missouri", "wishbone", "infiniti", "jameson", "1a2b3c", "1qwerty", "wonderboy", "skip", "shojou", "stanford", "sparky1", "smeghead", "poiuy", "titanium", "torres", "lantern", "jelly", "jeanne", "meier", "1213", "bayern", "basset", "gsxr750", "cattle", "charlene", "fishing1", "fullmoon", "gilles", "dima", "obelix", "popo", "prissy", "ramrod", "unique", "absolute", "bummer", "hotone", "dynasty", "entry", "konyor", "missy1", "moses", "282828", "yeah", "xyz123", "stop", "426hemi", "404040", "seinfeld", "simmons", "pingpong", "lazarus", "matthews", "marine1", "manning", "recovery", "12345a", "beamer", "babyface", "greece", "gustav", "7007", "charity", "camilla", "ccccccc", "faggot", "foxy", "frozen", "gladiato", "duckie", "dogfood", "paranoid", "packers1", "longjohn", "radical", "tuna", "clarinet", "claudio", "circus", "danny1", "novell", "nights", "bonbon", "kashmir", "kiki", "mortimer", "modelsne", "moondog", "monaco", "vladimir", "insert", "1953", "zxc123", "supreme", "3131", "sexxx", "selena", "softail", "poipoi", "pong", "together", "mars", "martin1", "rogue", "alone", "avalanch", "audia4", "55bgates", "cccccccc", "chick", "came11", "figaro", "geneva", "dogboy", "dnsadm", "dipshit", "paradigm", "othello", "operator", "officer", "malone", "post", "rafael", "valencia", "tripod", "choice", "chopin", "coucou", "coach", "cocksuck", "common", "creature", "borussia", "book", "browning", "heritage", "hiziad", "homerj", "eight", "earth", "millions", "mullet", "whisky", "jacques", "store", "4242", "speedo", "starcraf", "skylar", "spaceman", "piggy", "pierce", "tiger2", "legos", "lala", "jezebel", "judy", "joker1", "mazda", "barton", "baker", "727272", "chester1", "fishman", "food", "rrrrrrrr", "sandwich", "dundee", "lumber", "magazine", "radar", "ppppppp", "tranny", "aaliyah", "admiral", "comics", "cleo", "delight", "buttfuck", "homeboy", "eternal", "kilroy", "kellie", "khan", "violin", "wingman", "walmart", "bigblue", "blaze", "beemer", "beowulf", "bigfish", "yyyyyyy", "woodie", "yeahbaby", "0123456", "tbone", "style", "syzygy", "starter", "lemon", "linda1", "merlot", "mexican", "11235813", "anita", "banner", "bangbang", "badman", "barfly", "grease", "carla", "charles1", "ffffffff", "screw", "doberman", "diane", "dogshit", "overkill", "counter", "coolguy", "claymore", "demons", "demo", "nomore", "normal", "brewster", "hhhhhhh", "hondas", "iamgod", "enterme", "everett", "electron", "eastside", "kayla", "minimoni", "mybaby", "wildbill", "wildcard", "ipswich", "200000", "bearcat", "zigzag", "yyyyyyyy", "xander", "sweetnes", "369369", "skyler", "skywalker", "pigeon", "peyton", "tipper", "lilly", "asdf123", "alphabet", "asdzxc", "babybaby", "banane", "barnes", "guyver", "graphics", "grand", "chinook", "florida1", "flexible", "fuckinside", "otis", "ursitesux", "tototo", "trust", "tower", "adam12", "christma", "corey", "chrome", "buddie", "bombers", "bunker", "hippie", "keegan", "misfits", "vickie", "292929", "woofer", "wwwwwwww", "stubby", "sheep", "secrets", "sparta", "stang", "spud", "sporty", "pinball", "jorge", "just4fun", "johanna", "maxxxx", "rebecca1", "gunther", "fatima", "fffffff", "freeway", "garion", "score", "rrrrr", "sancho", "outback", "maggot", "puddin", "trial", "adrienne", "987456", "colton", "clyde", "brain", "brains", "hoops", "eleanor", "dwayne", "kirby", "mydick", "villa", "19691969", "bigcat", "becker", "shiner", "silverad", "spanish", "templar", "lamer", "juicy", "marsha", "mike1", "maximum", "rhiannon", "real", "1223", "10101010", "arrows", "andres", "alucard", "baldwin", "baron", "avenue", "ashleigh", "haggis", "channel", "cheech", "safari", "ross", "dog123", "orion1", "paloma", "qwerasdf", "presiden", "vegitto", "trees", "969696", "adonis", "colonel", "cookie1", "newyork1", "brigitte", "buddyboy", "hellos", "heineken", "dwight", "eraser", "kerstin", "motion", "moritz", "millwall", "visual", "jaybird", "1983", "beautifu", "bitter", "yvette", "zodiac", "steven1", "sinister", "slammer", "smashing", "slick1", "sponge", "teddybea", "theater", "this", "ticklish", "lipstick", "jonny", "massage", "mann", "reynolds", "ring", "1211", "amazing", "aptiva", "applepie", "bailey1", "guitar1", "chanel", "canyon", "gagged", "fuckme1", "rough", "digital1", "dinosaur", "punk", "98765", "90210", "clowns", "cubs", "daniels", "deejay", "nigga", "naruto", "boxcar", "icehouse", "hotties", "electra", "kent", "widget", "india", "insanity", "1986", "2004", "best", "bluefish", "bingo1", "*****", "stratus", "strength", "sultan", "storm1", "44444", "4200", "sentnece", "season", "sexyboy", "sigma", "smokie", "spam", "point", "pippo", "ticket", "temppass", "joel", "manman", "medicine", "1022", "anton", "almond", "bacchus", "aztnm", "axio", "awful", "bamboo", "hakr", "gregor", "hahahaha", "5678", "casanova", "caprice", "camero1", "fellow", "fountain", "dupont", "dolphin1", "dianne", "paddle", "magnet", "qwert1", "pyon", "porsche1", "tripper", "vampires", "coming", "noway", "burrito", "bozo", "highheel", "hughes", "hookem", "eddie1", "ellie", "entropy", "kkkkkkkk", "kkkkkkk", "illinois", "jacobs", "1945", "1951", "24680", "21212121", "100000", "stonecold", "taco", "subzero", "sharp", "sexxxy", "skolko", "shanna", "skyhawk", "spurs1", "sputnik", "piazza", "testpass", "letter", "lane", "kurt", "jiggaman", "matilda", "1224", "harvard", "hannah1", "525252", "4ever", "carbon", "chef", "federico", "ghosts", "gina", "scorpio1", "rt6ytere", "madison1", "loki", "raquel", "promise", "coolness", "christina", "coldbeer", "citadel", "brittney", "highway", "evil", "monarch", "morgan1", "washingt", "1997", "bella1", "berry", "yaya", "yolanda", "superb", "taxman", "studman", "stephanie", "3636", "sherri", "sheriff", "shepherd", "poland", "pizzas", "tiffany1", "toilet", "latina", "lassie", "larry1", "joseph1", "mephisto", "meagan", "marian", "reptile", "rico", "razor", "1013", "barron", "hammer1", "gypsy", "grande", "carroll", "camper", "chippy", "cat123", "call", "chimera", "fiesta", "glock", "glenn", "domain", "dieter", "dragonba", "onetwo", "nygiants", "odessa", "password2", "louie", "quartz", "prowler", "prophet", "towers", "ultra", "cocker", "corleone", "dakota1", "cumm", "nnnnnnn", "natalia", "boxers", "hugo", "heynow", "hollow", "iceberg", "elvira", "kittykat", "kate", "kitchen", "wasabi", "vikings1", "impact", "beerman", "string", "sleep", "splinter", "snoopy1", "pipeline", "pocket", "legs", "maple", "mickey1", "manuela", "mermaid", "micro", "meowmeow", "redbird", "alisha", "baura", "battery", "grass", "chevys", "chestnut", "caravan", "carina", "charmed", "fraser", "frogman", "diving", "dogger", "draven", "drifter", "oatmeal", "paris1", "longdong", "quant4307s", "rachel1", "vegitta", "cole", "cobras", "corsair", "dadada", "noelle", "mylife", "nine", "bowwow", "body", "hotrats", "eastwood", "moonligh", "modena", "wave", "illusion", "iiiiiii", "jayhawks", "birgit", "zone", "sutton", "susana", "swingers", "shocker", "shrimp", "sexgod", "squall", "stefanie", "squeeze", "soul", "patrice", "poiu", "players", "tigers1", "toejam", "tickler", "line", "julie1", "jimbo1", "jefferso", "juanita", "michael2", "rodeo", "robot", "1023", "annie1", "bball", "guess", "happy2", "charter", "farm", "flasher", "falcon1", "fiction", "fastball", "gadget", "scrabble", "diaper", "dirtbike", "dinner", "oliver1", "partner", "paco", "lucille", "macman", "poopy", "popper", "postman", "ttttttt", "ursula", "acura", "cowboy1", "conan", "daewoo", "cyrus", "customer", "nation", "nemrac58", "nnnnn", "nextel", "bolton", "bobdylan", "hopeless", "eureka", "extra", "kimmie", "kcj9wx5n", "killbill", "musica", "volkswag", "wage", "windmill", "wert", "vintage", "iloveyou1", "itsme", "bessie", "zippo", "311311", "starligh", "smokey1", "spot", "snappy", "soulmate", "plasma", "thelma", "tonight", "krusty", "just4me", "mcdonald", "marius", "rochelle", "rebel1", "1123", "alfredo", "aubrey", "audi", "chantal", "fick", "goaway", "roses", "sales", "rusty2", "dirt", "dogbone", "doofus", "ooooooo", "oblivion", "mankind", "luck", "mahler", "lllllll", "pumper", "puck", "pulsar", "valkyrie", "tupac", "compass", "concorde", "costello", "cougars", "delaware", "niceguy", "nocturne", "bob123", "boating", "bronze", "hopkins", "herewego", "hewlett", "houhou", "hubert", "earnhard", "eeeeeeee", "keller", "mingus", "mobydick", "venture", "verizon", "imation", "1950", "1948", "1949", "223344", "bigbig", "blossom", "zack", "wowwow", "sissy", "skinner", "spiker", "square", "snooker", "sluggo", "player1", "junk", "jeannie", "jsbach", "jumbo", "jewel", "medic", "robins", "reddevil", "reckless", "123456a", "1125", "1031", "beacon", "astra", "gumby", "hammond", "hassan", "757575", "585858", "chillin", "fuck1", "sander", "lowell", "radiohea", "upyours", "trek", "courage", "coolcool", "classics", "choochoo", "darryl", "nikki1", "nitro", "bugs", "boytoy", "ellen", "excite", "kirsty", "kane", "wingnut", "wireless", "icu812", "1master", "beatle", "bigblock", "blanca", "wolfen", "summer99", "sugar1", "tartar", "sexysexy", "senna", "sexman", "sick", "someone", "soprano", "pippin", "platypus", "pixies", "telephon", "land", "laura1", "laurent", "rimmer", "road", "report", "1020", "12qwaszx", "arturo", "around", "hamish", "halifax", "fishhead", "forum", "dododo", "doit", "outside", "paramedi", "lonesome", "mandy1", "twist", "uuuuu", "uranus", "ttttt", "butcher", "bruce1", "helper", "hopeful", "eduard", "dusty1", "kathy1", "katherin", "moonbeam", "muscles", "monster1", "monkeybo", "morton", "windsurf", "vvvvvvv", "vivid", "install", "1947", "187187", "1941", "1952", "tatiana", "susan1", "31415926", "sinned", "sexxy", "senator", "sebastian", "shadows", "smoothie", "snowflak", "playstat", "playa", "playboy1", "toaster", "jerry1", "marie1", "mason1", "merlin1", "roger1", "roadster", "112358", "1121", "andrea1", "bacardi", "auto", "hardware", "hardy", "789789", "5555555", "captain1", "flores", "fergus", "sascha", "rrrrrrr", "dome", "onion", "nutter", "lololo", "qqqqqqq", "quick", "undertak", "uuuuuuuu", "uuuuuuu", "criminal", "cobain", "cindy1", "coors", "dani", "descent", "nimbus", "nomad", "nanook", "norwich", "bomb", "bombay", "broker", "hookup", "kiwi", "winners", "jackpot", "1a2b3c4d", "1776", "beardog", "bighead", "blast", "bird33", "0987", "stress", "shot", "spooge", "pelican", "peepee", "perry", "pointer", "titan", "thedoors", "jeremy1", "annabell", "altima", "baba", "hallie", "hate", "hardone", "5454", "candace", "catwoman", "flip", "faithful", "finance", "farmboy", "farscape", "genesis1", "salomon", "destroy", "papers", "option", "page", "loser1", "lopez", "r2d2", "pumpkins", "training", "chriss", "cumcum", "ninjas", "ninja1", "hung", "erika", "eduardo", "killers", "miller1", "islander", "jamesbond", "intel", "jarvis", "19841984", "2626", "bizzare", "blue12", "biker", "yoyoma", "sushi", "styles", "shitface", "series", "shanti", "spanker", "steffi", "smart", "sphinx", "please1", "paulie", "pistons", "tiburon", "limited", "maxwell1", "mdogg", "rockies", "armstron", "alexia", "arlene", "alejandr", "arctic", "banger", "audio", "asimov", "augustus", "grandpa", "753951", "4you", "chilly", "care1839", "chapman", "flyfish", "fantasia", "freefall", "santa", "sandrine", "oreo", "ohshit", "macbeth", "madcat", "loveya", "mallory", "rage", "quentin", "qwerqwer", "project", "ramirez", "colnago", "citizen", "chocha", "cobalt", "crystal1", "dabears", "nevets", "nineinch", "broncos1", "helene", "huge", "edgar", "epsilon", "easter", "kestrel", "moron", "virgil", "winston1", "warrior1", "iiiiiiii", "iloveyou2", "1616", "beat", "bettina", "woowoo", "zander", "straight", "shower", "sloppy", "specialk", "tinkerbe", "jellybea", "reader", "romero", "redsox1", "ride", "1215", "1112", "annika", "arcadia", "answer", "baggio", "base", "guido", "555666", "carmel", "cayman", "cbr900rr", "chips", "gabriell", "gertrude", "glennwei", "roxy", "sausages", "disco", "pass1", "luna", "lovebug", "macmac", "queenie", "puffin", "vanguard", "trip", "trinitro", "airwolf", "abbott", "aaa111", "cocaine", "cisco", "cottage", "dayton", "deadly", "datsun", "bricks", "bumper", "eldorado", "kidrock", "wizard1", "whiskers", "wind", "wildwood", "istheman", "interest", "italy", "25802580", "benoit", "bigones", "woodland", "wolfpac", "strawber", "suicide", "3030", "sheba1", "sixpack", "peace1", "physics", "pearson", "tigger2", "toad", "megan1", "meow", "ringo", "roll", "amsterdam", "717171", "686868", "5424", "catherine", "canuck", "football1", "footjob", "fulham", "seagull", "orgy", "lobo", "mancity", "truth", "trace", "vancouve", "vauxhall", "acidburn", "derf", "myspace1", "boozer", "buttercu", "howell", "hola", "easton", "minemine", "munch", "jared", "1dragon", "biology", "bestbuy", "bigpoppa", "blackout", "blowfish", "bmw325", "bigbob", "stream", "talisman", "tazz", "sundevil", "3333333", "skate", "shutup", "shanghai", "shop", "spencer1", "slowhand", "polish", "pinky1", "tootie", "thecrow", "leroy", "jonathon", "jubilee", "jingle", "martine", "matrix1", "manowar", "michaels", "messiah", "mclaren", "resident", "reilly", "redbaron", "rollins", "romans", "return", "rivera", "andromed", "athlon", "beach1", "badgers", "guitars", "harald", "harddick", "gotribe", "6996", "7grout", "5wr2i7h8", "635241", "chase1", "carver", "charlotte", "fallout", "fiddle", "fredrick", "fenris", "francesc", "fortuna", "ferguson", "fairlane", "felipe", "felix1", "forward", "gasman", "frost", "fucks", "sahara", "sassy1", "dogpound", "dogbert", "divx1", "manila", "loretta", "priest", "pornporn", "quasar", "venom", "987987", "access1", "clippers", "daylight", "decker", "daman", "data", "dentist", "crusty", "nathan1", "nnnnnnnn", "bruno1", "bucks", "brodie", "budapest", "kittens", "kerouac", "mother1", "waldo1", "wedding", "whistler", "whatwhat", "wanderer", "idontkno", "1942", "1946", "bigdawg", "bigpimp", "zaqwsx", "414141", "3000gt", "434343", "shoes", "serpent", "starr", "smurf", "pasword", "tommie", "thisisit", "lake", "john1", "robotics", "redeye", "rebelz", "1011", "alatam", "asses", "asians", "bama", "banzai", "harvest", "gonzalez", "hair", "hanson", "575757", "5329", "cascade", "chinese", "fatty", "fender1", "flower2", "funky", "sambo", "drummer1", "dogcat", "dottie", "oedipus", "osama", "macleod", "prozac", "private1", "rampage", "punch", "presley", "concord", "cook", "cinema", "cornwall", "cleaner", "christopher", "ciccio", "corinne", "clutch", "corvet07", "daemon", "bruiser", "boiler", "hjkl", "eyes", "egghead", "expert", "ethan", "kasper", "mordor", "wasted", "jamess", "iverson3", "bluesman", "zouzou", "090909", "1002", "switch", "stone1", "4040", "sisters", "sexo", "shawna", "smith1", "sperma", "sneaky", "polska", "thewho", "terminat", "krypton", "lawson", "library", "lekker", "jules", "johnson1", "johann", "justus", "rockie", "romano", "aspire", "bastards", "goodie", "cheese1", "fenway", "fishon", "fishin", "fuckoff1", "girls1", "sawyer", "dolores", "desmond", "duane", "doomsday", "pornking", "ramones", "rabbits", "transit", "aaaaa1", "clock", "delilah", "noel", "boyz", "bookworm", "bongo", "bunnies", "brady", "buceta", "highbury", "henry1", "heels", "eastern", "krissy", "mischief", "mopar", "ministry", "vienna", "weston", "wildone", "vodka", "jayson", "bigbooty", "beavis1", "betsy", "xxxxxx1", "yogibear", "000001", "0815", "zulu", "420000", "september", "sigmar", "sprout", "stalin", "peggy", "patch", "lkjhgfds", "lagnaf", "rolex", "redfox", "referee", "123123123", "1231", "angus1", "ariana", "ballin", "attila", "hall", "greedy", "grunt", "747474", "carpedie", "cecile", "caramel", "foxylady", "field", "gatorade", "gidget", "futbol", "frosch", "saiyan", "schmidt", "drums", "donner", "doggy1", "drum", "doudou", "pack", "pain", "nutmeg", "quebec", "valdepen", "trash", "triple", "tosser", "tuscl", "track", "comfort", "choke", "comein", "cola", "deputy", "deadpool", "bremen", "borders", "bronson", "break", "hotass", "hotmail1", "eskimo", "eggman", "koko", "kieran", "katrin", "kordell1", "komodo", "mone", "munich", "vvvvvvvv", "winger", "jaeger", "ivan", "jackson5", "2222222", "bergkamp", "bennie", "bigben", "zanzibar", "worm", "xxx123", "sunny1", "373737", "services", "sheridan", "slater", "slayer1", "snoop", "stacie", "peachy", "thecure", "times", "little1", "jennaj", "marquis", "middle", "rasta69", "1114", "aries", "havana", "gratis", "calgary", "checkers", "flanker", "salope", "dirty1", "draco", "dogface", "luv2epus", "rainbow6", "qwerty123", "umpire", "turnip", "vbnm", "tucson", "troll", "aileen", "codered", "commande", "damon", "nana", "neon", "nico", "nightwin", "neil", "boomer1", "bushido", "hotmail0", "horace", "enternow", "kaitlyn", "keepout", "karen1", "mindy", "mnbv", "viewsoni", "volcom", "wizards", "wine", "1995", "berkeley", "bite", "zach", "woodstoc", "tarpon", "shinobi", "starstar", "phat", "patience", "patrol", "toolbox", "julien", "johnny1", "joebob", "marble", "riders", "reflex", "120676", "1235", "angelus", "anthrax", "atlas", "hawks", "grandam", "harlem", "hawaii50", "gorgeous", "655321", "cabron", "challeng", "callisto", "firewall", "firefire", "fischer", "flyer", "flower1", "factory", "federal", "gambler", "frodo1", "funk", "sand", "sam123", "scania", "dingo", "papito", "passmast", "olive", "palermo", "ou8123", "lock", "ranch", "pride", "randy1", "twiggy", "travis1", "transfer", "treetop", "addict", "admin1", "963852", "aceace", "clarissa", "cliff", "cirrus", "clifton", "colin", "bobdole", "bonner", "bogus", "bonjovi", "bootsy", "boater", "elway7", "edison", "kelvin", "kenny1", "moonshin", "montag", "moreno", "wayne1", "white1", "jazzy", "jakejake", "1994", "1991", "2828", "blunt", "bluejays", "beau", "belmont", "worthy", "systems", "sensei", "southpark", "stan", "peeper", "pharao", "pigpen", "tomahawk", "teensex", "leedsutd", "larkin", "jermaine", "jeepster", "jimjim", "josephin", "melons", "marlon", "matthias", "marriage", "robocop", "1003", "1027", "antelope", "azsxdc", "gordo", "hazard", "granada", "8989", "7894", "ceasar", "cabernet", "cheshire", "california", "chelle", "candy1", "fergie", "fanny", "fidelio", "giorgio", "fuckhead", "ruth", "sanford", "diego", "dominion", "devon", "panic", "longer", "mackie", "qawsed", "trucking", "twelve", "chloe1", "coral", "daddyo", "nostromo", "boyboy", "booster", "bucky", "honolulu", "esquire", "dynamite", "motor", "mollydog", "wilder", "windows1", "waffle", "wallet", "warning", "virus", "washburn", "wealth", "vincent1", "jabber", "jaguars", "javelin", "irishman", "idefix", "bigdog1", "blue42", "blanked", "blue32", "biteme1", "bearcats", "blaine", "yessir", "sylveste", "team", "stephan", "sunfire", "tbird", "stryker", "3ip76k2", "sevens", "sheldon", "pilgrim", "tenchi", "titman", "leeds", "lithium", "lander", "linkin", "landon", "marijuan", "mariner", "markie", "midnite", "reddwarf", "1129", "123asd", "12312312", "allstar", "albany", "asdf12", "antonia", "aspen", "hardball", "goldfing", "7734", "49ers", "carlo", "chambers", "cable", "carnage", "callum", "carlos1", "fitter", "fandango", "festival", "flame", "gofast", "gamma", "fucmy69", "scrapper", "dogwood", "django", "magneto", "loose", "premium", "addison", "9999999", "abc1234", "cromwell", "newyear", "nichole", "bookie", "burns", "bounty", "brown1", "bologna", "earl", "entrance", "elway", "killjoy", "kerry", "keenan", "kick", "klondike", "mini", "mouser", "mohammed", "wayer", "impreza", "irene", "insomnia", "24682468", "2580", "24242424", "billbill", "bellaco", "blessing", "blues1", "bedford", "blanco", "blunts", "stinks", "teaser", "streets", "sf49ers", "shovel", "solitude", "spikey", "sonia", "pimpdadd", "timeout", "toffee", "lefty", "johndoe", "johndeer", "mega", "manolo", "mentor", "margie", "ratman", "ridge", "record", "rhodes", "robin1", "1124", "1210", "1028", "1226", "another", "babylove", "barbados", "harbor", "gramma", "646464", "carpente", "chaos1", "fishbone", "fireblad", "glasgow", "frogs", "scissors", "screamer", "salem", "scuba1", "ducks", "driven", "doggies", "dicky", "donovan", "obsidian", "rams", "progress", "tottenham", "aikman", "comanche", "corolla", "clarke", "conway", "cumslut", "cyborg", "dancing", "boston1", "bong", "houdini", "helmut", "elvisp", "edge", "keksa12", "misha", "monty1", "monsters", "wetter", "watford", "wiseguy", "veronika", "visitor", "janelle", "1989", "1987", "20202020", "biatch", "beezer", "bigguns", "blueball", "bitchy", "wyoming", "yankees2", "wrestler", "stupid1", "sealteam", "sidekick", "simple1", "smackdow", "sporting", "spiral", "smeller", "sperm", "plato", "tophat", "test2", "theatre", "thick", "toomuch", "leigh", "jello", "jewish", "junkie", "maxim", "maxime", "meadow", "remingto", "roofer", "124038", "1018", "1269", "1227", "123457", "arkansas", "alberta", "aramis", "andersen", "beaker", "barcelona", "baltimor", "googoo", "goochi", "852456", "4711", "catcher", "carman", "champ1", "chess", "fortress", "fishfish", "firefigh", "geezer", "rsalinas", "samuel1", "saigon", "scooby1", "doors", "dick1", "devin", "doom", "dirk", "doris", "dontknow", "load", "magpies", "manfred", "raleigh", "vader1", "universa", "tulips", "defense", "mygirl", "burn", "bowtie", "bowman", "holycow", "heinrich", "honeys", "enforcer", "katherine", "minerva", "wheeler", "witch", "waterboy", "jaime", "irving", "1992", "23skidoo", "bimbo", "blue11", "birddog", "woodman", "womble", "zildjian", "030303", "stinker", "stoppedby", "sexybabe", "speakers", "slugger", "spotty", "smoke1", "polopolo", "perfect1", "things", "torpedo", "tender", "thrasher", "lakeside", "lilith", "jimmys", "jerk", "junior1", "marsh", "masamune", "rice", "root", "1214", "april1", "allgood", "bambi", "grinch", "767676", "5252", "cherries", "chipmunk", "cezer121", "carnival", "capecod", "finder", "flint", "fearless", "goats", "funstuff", "gideon", "savior", "seabee", "sandro", "schalke", "salasana", "disney1", "duckman", "options", "pancake", "pantera1", "malice", "lookin", "love123", "lloyd", "qwert123", "puppet", "prayers", "union", "tracer", "crap", "creation", "cwoui", "nascar24", "hookers", "hollie", "hewitt", "estrella", "erection", "ernesto", "ericsson", "edthom", "kaylee", "kokoko", "kokomo", "kimball", "morales", "mooses", "monk", "walton", "weekend", "inter", "internal", "1michael", "1993", "19781978", "25252525", "worker", "summers", "surgery", "shibby", "shamus", "skibum", "sheepdog", "sex69", "spliff", "slipper", "spoons", "spanner", "snowbird", "slow", "toriamos", "temp123", "tennesse", "lakers1", "jomama", "julio", "mazdarx7", "rosario", "recon", "riddle", "room", "revolver", "1025", "1101", "barney1", "babycake", "baylor", "gotham", "gravity", "hallowee", "hancock", "616161", "515000", "caca", "cannabis", "castor", "chilli", "fdsa", "getout", "fuck69", "gators1", "sail", "sable", "rumble", "dolemite", "dork", "dickens", "duffer", "dodgers1", "painting", "onions", "logger", "lorena", "lookout", "magic32", "port", "poon", "prime", "twat", "coventry", "citroen", "christmas", "civicsi", "cocksucker", "coochie", "compaq1", "nancy1", "buzzer", "boulder", "butkus", "bungle", "hogtied", "honor", "hero", "hotgirls", "hilary", "heidi1", "eggplant", "mustang6", "mortal", "monkey12", "wapapapa", "wendy1", "volleyba", "vibrate", "vicky", "bledsoe", "blink", "birthday4", "woof", "xxxxx1", "talk", "stephen1", "suburban", "stock", "tabatha", "sheeba", "start1", "soccer10", "something", "starcraft", "soccer12", "peanut1", "plastics", "penthous", "peterbil", "tools", "tetsuo", "torino", "tennis1", "termite", "ladder", "last", "lemmein", "lakewood", "jughead", "melrose", "megane", "reginald", "redone", "request", "angela1", "alive", "alissa", "goodgirl", "gonzo1", "golden1", "gotyoass", "656565", "626262", "capricor", "chains", "calvin1", "foolish", "fallon", "getmoney", "godfather", "gabber", "gilligan", "runaway", "salami", "dummy", "dungeon", "dudedude", "dumb", "dope", "opus", "paragon", "oxygen", "panhead", "pasadena", "opendoor", "odyssey", "magellan", "lottie", "printing", "pressure", "prince1", "trustme", "christa", "court", "davies", "neville", "nono", "bread", "buffet", "hound", "kajak", "killkill", "mona", "moto", "mildred", "winner1", "vixen", "whiteboy", "versace", "winona", "voyager1", "instant", "indy", "jackjack", "bigal", "beech", "biggun", "blake1", "blue99", "big1", "woods", "synergy", "success1", "336699", "sixty9", "shark1", "skin", "simba1", "sharpe", "sebring", "spongebo", "spunk", "springs", "sliver", "phialpha", "password9", "pizza1", "plane", "perkins", "pookey", "tickling", "lexingky", "lawman", "joe123", "jolly", "mike123", "romeo1", "redheads", "reserve", "apple123", "alanis", "ariane", "antony", "backbone", "aviation", "band", "hand", "green123", "haley", "carlitos", "byebye", "cartman1", "camden", "chewy", "camaross", "favorite6", "forumwp", "franks", "ginscoot", "fruity", "sabrina1", "devil666", "doughnut", "pantie", "oldone", "paintball", "lumina", "rainbow1", "prosper", "total", "true", "umbrella", "ajax", "951753", "achtung", "abc12345", "compact", "color", "corn", "complete", "christi", "closer", "corndog", "deerhunt", "darklord", "dank", "nimitz", "brandy1", "bowl", "breanna", "holidays", "hetfield", "holein1", "hillbill", "hugetits", "east", "evolutio", "kenobi", "whiplash", "waldo", "wg8e3wjf", "wing", "istanbul", "invis", "1996", "benton", "bigjohn", "bluebell", "beef", "beater", "benji", "bluejay", "xyzzy", "wrestling", "storage", "superior", "suckdick", "taichi", "stellar", "stephane", "shaker", "skirt", "seymour", "semper", "splurge", "squeak", "pearls", "playball", "pitch", "phyllis", "pooky", "piss", "tomas", "titfuck", "joemama", "johnny5", "marcello", "marjorie", "married", "maxi", "rhubarb", "rockwell", "ratboy", "reload", "rooney", "redd", "1029", "1030", "1220", "anchor", "bbking", "baritone", "gryphon", "gone", "57chevy", "494949", "celeron", "fishy", "gladiator", "fucker1", "roswell", "dougie", "downer", "dicker", "diva", "domingo", "donjuan", "nympho", "omar", "praise", "racers", "trick", "trauma", "truck1", "trample", "acer", "corwin", "cricket1", "clemente", "climax", "denmark", "cuervo", "notnow", "nittany", "neutron", "native", "bosco1", "buffa", "breaker", "hello2", "hydro", "estelle", "exchange", "explore", "kisskiss", "kittys", "kristian", "montecar", "modem", "mississi", "mooney", "weiner", "washington", "20012001", "bigdick1", "bibi", "benfica", "yahoo1", "striper", "tabasco", "supra", "383838", "456654", "seneca", "serious", "shuttle", "socks", "stanton", "penguin1", "pathfind", "testibil", "thethe", "listen", "lightning", "lighting", "jeter2", "marma", "mark1", "metoo", "republic", "rollin", "redleg", "redbone", "redskin", "rocco", "1245", "armand", "anthony7", "altoids", "andrews", "barley", "away", "asswipe", "bauhaus", "bbbbbb1", "gohome", "harrier", "golfpro", "goldeney", "818181", "6666666", "5000", "5rxypn", "cameron1", "calling", "checker", "calibra", "fields", "freefree", "faith1", "fist", "fdm7ed", "finally", "giraffe", "glasses", "giggles", "fringe", "gate", "georgie", "scamper", "rrpass1", "screwyou", "duffy", "deville", "dimples", "pacino", "ontario", "passthie", "oberon", "quest1", "postov1000", "puppydog", "puffer", "raining", "protect", "qwerty7", "trey", "tribe", "ulysses", "tribal", "adam25", "a1234567", "compton", "collie", "cleopatr", "contract", "davide", "norris", "namaste", "myrtle", "buffalo1", "bonovox", "buckley", "bukkake", "burning", "burner", "bordeaux", "burly", "hun999", "emilie", "elmo", "enters", "enrique", "keisha", "mohawk", "willard", "vgirl", "whale", "vince", "jayden", "jarrett", "1812", "1943", "222333", "bigjim", "bigd", "zoom", "wordup", "ziggy1", "yahooo", "workout", "young1", "written", "xmas", "zzzzzz1", "surfer1", "strife", "sunlight", "tasha1", "skunk", "shauna", "seth", "soft", "sprinter", "peaches1", "planes", "pinetree", "plum", "pimping", "theforce", "thedon", "toocool", "leeann", "laddie", "list", "lkjh", "lara", "joke", "jupiter1", "mckenzie", "matty", "rene", "redrose", "1200", "102938", "annmarie", "alexa", "antares", "austin31", "ground", "goose1", "737373", "78945612", "789987", "6464", "calimero", "caster", "casper1", "cement", "chevrolet", "chessie", "caddy", "chill", "child", "canucks", "feeling", "favorite", "fellatio", "f00tball", "francine", "gateway2", "gigi", "gamecube", "giovanna", "rugby1", "scheisse", "dshade", "dudes", "dixie1", "owen", "offshore", "olympia", "lucas1", "macaroni", "manga", "pringles", "puff", "tribble", "trouble1", "ussy", "core", "clint", "coolhand", "colonial", "colt", "debra", "darthvad", "dealer", "cygnusx1", "natalie1", "newark", "husband", "hiking", "errors", "eighteen", "elcamino", "emmett", "emilia", "koolaid", "knight1", "murphy1", "volcano", "idunno", "2005", "2233", "block", "benito", "blueberr", "biguns", "yamahar1", "zapper", "zorro1", "0911", "3006", "sixsix", "shopper", "siobhan", "sextoy", "stafford", "snowboard", "speedway", "sounds", "pokey", "peabody", "playboy2", "titi", "think", "toast", "toonarmy", "lister", "lambda", "joecool", "jonas", "joyce", "juniper", "mercer", "max123", "manny", "massimo", "mariposa", "met2002", "reggae", "ricky1", "1236", "1228", "1016", "all4one", "arianna", "baberuth", "asgard", "gonzales", "484848", "5683", "6669", "catnip", "chiquita", "charisma", "capslock", "cashmone", "chat", "figure", "galant", "frenchy", "gizmodo1", "girlies", "gabby", "garner", "screwy", "doubled", "divers", "dte4uw", "done", "dragonfl", "maker", "locks", "rachelle", "treble", "twinkie", "trailer", "tropical", "acid", "crescent", "cooking", "cococo", "cory", "dabomb", "daffy", "dandfa", "cyrano", "nathanie", "briggs", "boners", "helium", "horton", "hoffman", "hellas", "espresso", "emperor", "killa", "kikimora", "wanda", "w4g8at", "verona", "ilikeit", "iforget", "1944", "20002000", "birthday1", "beatles1", "blue1", "bigdicks", "beethove", "blacklab", "blazers", "benny1", "woodwork", "0069", "0101", "taffy", "susie", "survivor", "swim", "stokes", "4567", "shodan", "spoiled", "steffen", "pissed", "pavlov", "pinnacle", "place", "petunia", "terrell", "thirty", "toni", "tito", "teenie", "lemonade", "lily", "lillie", "lalakers", "lebowski", "lalalala", "ladyboy", "jeeper", "joyjoy", "mercury1", "mantle", "mannn", "rocknrol", "riversid", "reeves", "123aaa", "11112222", "121314", "1021", "1004", "1120", "allen1", "ambers", "amstel", "ambrose", "alice1", "alleycat", "allegro", "ambrosia", "alley", "australia", "hatred", "gspot", "graves", "goodsex", "hattrick", "harpoon", "878787", "8inches", "4wwvte", "cassandr", "charlie123", "case", "chavez", "fighting", "gabriela", "gatsby", "fudge", "gerry", "generic", "gareth", "fuckme2", "samm", "sage", "seadog", "satchmo", "scxakv", "santafe", "dipper", "dingle", "dizzy", "outoutout", "madmad", "london1", "qbg26i", "pussy123", "randolph", "vaughn", "tzpvaw", "vamp", "comedy", "comp", "cowgirl", "coldplay", "dawgs", "delaney", "nt5d27", "novifarm", "needles", "notredam", "newness", "mykids", "bryan1", "bouncer", "hihihi", "honeybee", "iceman1", "herring", "horn", "hook", "hotlips", "dynamo", "klaus", "kittie", "kappa", "kahlua", "muffy", "mizzou", "mohamed", "musical", "wannabe", "wednesda", "whatup", "weller", "waterfal", "willy1", "invest", "blanche", "bear1", "billabon", "youknow", "zelda", "yyyyyy1", "zachary1", "01234567", "070462", "zurich", "superstar", "storms", "tail", "stiletto", "strat", "427900", "sigmachi", "shelter", "shells", "sexy123", "smile1", "sophie1", "stefano", "stayout", "somerset", "smithers", "playmate", "pinkfloyd", "phish1", "payday", "thebear", "telefon", "laetitia", "kswbdu", "larson", "jetta", "jerky", "melina", "metro", "revoluti", "retire", "respect", "1216", "1201", "1204", "1222", "1115", "archange", "barry1", "handball", "676767", "chandra", "chewbacc", "flesh", "furball", "gocubs", "fruit", "fullback", "gman", "gentle", "dunbar", "dewalt", "dominiqu", "diver1", "dhip6a", "olemiss", "ollie", "mandrake", "mangos", "pretzel", "pusssy", "tripleh", "valdez", "vagabond", "clean", "comment", "crew", "clovis", "deaths", "dandan", "csfbr5yy", "deadspin", "darrel", "ninguna", "noah", "ncc74656", "bootsie", "bp2002", "bourbon", "brennan", "bumble", "books", "hose", "heyyou", "houston1", "hemlock", "hippo", "hornets", "hurricane", "horseman", "hogan", "excess", "extensa", "muffin1", "virginie", "werdna", "idontknow", "info", "iron", "jack1", "1bitch", "151nxjmt", "bendover", "bmwbmw", "bills", "zaq123", "wxcvbn", "surprise", "supernov", "tahoe", "talbot", "simona", "shakur", "sexyone", "seviyi", "sonja", "smart1", "speed1", "pepito", "phantom1", "playoffs", "terry1", "terrier", "laser1", "lite", "lancia", "johngalt", "jenjen", "jolene", "midori", "message", "maserati", "matteo", "mental", "miami1", "riffraff", "ronald1", "reason", "rhythm", "1218", "1026", "123987", "1015", "1103", "armada", "architec", "austria", "gotmilk", "hawkins", "gray", "camila", "camp", "cambridg", "charge", "camero", "flex", "foreplay", "getoff", "glacier", "glotest", "froggie", "gerbil", "rugger", "sanity72", "salesman", "donna1", "dreaming", "deutsch", "orchard", "oyster", "palmtree", "ophelia", "pajero", "m5wkqf", "magenta", "luckyone", "treefrog", "vantage", "usmarine", "tyvugq", "uptown", "abacab", "aaaaaa1", "advance", "chuck1", "delmar", "darkange", "cyclones", "nate", "navajo", "nope", "border", "bubba123", "building", "iawgk2", "hrfzlz", "dylan1", "enrico", "encore", "emilio", "eclipse1", "killian", "kayleigh", "mutant", "mizuno", "mustang2", "video1", "viewer", "weed420", "whales", "jaguar1", "insight", "1990", "159159", "1love", "bliss", "bears1", "bigtruck", "binder", "bigboss", "blitz", "xqgann", "yeahyeah", "zeke", "zardoz", "stickman", "table", "3825", "signal", "sentra", "side", "shiva", "skipper1", "singapor", "southpaw", "sonora", "squid", "slamdunk", "slimjim", "placid", "photon", "placebo", "pearl1", "test12", "therock1", "tiger123", "leinad", "legman", "jeepers", "joeblow", "mccarthy", "mike23", "redcar", "rhinos", "rjw7x4", "1102", "13576479", "112211", "alcohol", "gwju3g", "greywolf", "7bgiqk", "7878", "535353", "4snz9g", "candyass", "cccccc1", "carola", "catfight", "cali", "fister", "fosters", "finland", "frankie1", "gizzmo", "fuller", "royalty", "rugrat", "sandie", "rudolf", "dooley", "dive", "doreen", "dodo", "drop", "oemdlg", "out3xf", "paddy", "opennow", "puppy1", "qazwsxedc", "pregnant", "quinn", "ramjet", "under", "uncle", "abraxas", "corner", "creed", "cocoa", "crown", "cows", "cn42qj", "dancer1", "death666", "damned", "nudity", "negative", "nimda2k", "buick", "bobb", "braves1", "brook", "henrik", "higher", "hooligan", "dust", "everlast", "karachi", "mortis", "mulligan", "monies", "motocros", "wally1", "weapon", "waterman", "view", "willie1", "vicki", "inspiron", "1test", "2929", "bigblack", "xytfu7", "yackwin", "zaq1xsw2", "yy5rbfsc", "100100", "0660", "tahiti", "takehana", "talks", "332211", "3535", "sedona", "seawolf", "skydiver", "shine", "spleen", "slash", "spjfet", "special1", "spooner", "slimshad", "sopranos", "spock1", "penis1", "patches1", "terri", "thierry", "thething", "toohot", "large", "limpone", "johnnie", "mash4077", "matchbox", "masterp", "maxdog", "ribbit", "reed", "rita", "rockin", "redhat", "rising", "1113", "14789632", "1331", "allday", "aladin", "andrey", "amethyst", "ariel", "anytime", "baseball1", "athome", "basil", "goofy1", "greenman", "gustavo", "goofball", "ha8fyp", "goodday", "778899", "charon", "chappy", "castillo", "caracas", "cardiff", "capitals", "canada1", "cajun", "catter", "freddy1", "favorite2", "frazier", "forme", "follow", "forsaken", "feelgood", "gavin", "gfxqx686", "garlic", "sarge", "saskia", "sanjose", "russ", "salsa", "dilbert1", "dukeduke", "downhill", "longhair", "loop", "locutus", "lockdown", "malachi", "mamacita", "lolipop", "rainyday", "pumpkin1", "punker", "prospect", "rambo1", "rainbows", "quake", "twin", "trinity1", "trooper1", "aimee", "citation", "coolcat", "crappy", "default", "dental", "deniro", "d9ungl", "daddys", "napoli", "nautica", "nermal", "bukowski", "brick", "bubbles1", "bogota", "board", "branch", "breath", "buds", "hulk", "humphrey", "hitachi", "evans", "ender", "export", "kikiki", "kcchiefs", "kram", "morticia", "montrose", "mongo", "waqw3p", "wizzard", "visited", "whdbtp", "whkzyc", "image", "154ugeiu", "1fuck", "binky", "blind", "bigred1", "blubber", "benz", "becky1", "year2005", "wonderfu", "wooden", "xrated", "0001", "tampabay", "survey", "tammy1", "stuffer", "3mpz4r", "3000", "3some", "selina", "sierra1", "shampoo", "silk", "shyshy", "slapnuts", "standby", "spartan1", "sprocket", "sometime", "stanley1", "poker1", "plus", "thought", "theshit", "torture", "thinking", "lavalamp", "light1", "laserjet", "jediknig", "jjjjj1", "jocelyn", "mazda626", "menthol", "maximo", "margaux", "medic1", "release", "richter", "rhino1", "roach", "renate", "repair", "reveal", "1209", "1234321", "amigos", "apricot", "alexandra", "asdfgh1", "hairball", "hatter", "graduate", "grimace", "7xm5rq", "6789", "cartoons", "capcom", "cheesy", "cashflow", "carrots", "camping", "fanatic", "fool", "format", "fleming", "girlie", "glover", "gilmore", "gardner", "safeway", "ruthie", "dogfart", "dondon", "diapers", "outsider", "odin", "opiate", "lollol", "love12", "loomis", "mallrats", "prague", "primetime21", "pugsley", "program", "r29hqq", "touch", "valleywa", "airman", "abcdefg1", "darkone", "cummer", "dempsey", "damn", "nadia", "natedogg", "nineball", "ndeyl5", "natchez", "newone", "normandy", "nicetits", "buddy123", "buddys", "homely", "husky", "iceland", "hr3ytm", "highlife", "holla", "earthlin", "exeter", "eatmenow", "kimkim", "karine", "k2trix", "kernel", "kirkland", "money123", "moonman", "miles1", "mufasa", "mousey", "wilma", "wilhelm", "whites", "warhamme", "instinct", "jackass1", "2277", "20spanks", "blobby", "blair", "blinky", "bikers", "blackjack", "becca", "blue23", "xman", "wyvern", "085tzzqi", "zxzxzx", "zsmj2v", "suede", "t26gn4", "sugars", "sylvie", "tantra", "swoosh", "swiss", "4226", "4271", "321123", "383pdjvl", "shoe", "shane1", "shelby1", "spades", "spain", "smother", "soup", "sparhawk", "pisser", "photo1", "pebble", "phones", "peavey", "picnic", "pavement", "terra", "thistle", "tokyo", "therapy", "lives", "linden", "kronos", "lilbit", "linux", "johnston", "material", "melanie1", "marbles", "redlight", "reno", "recall", "1208", "1138", "1008", "alchemy", "aolsucks", "alexalex", "atticus", "auditt", "ballet", "b929ezzh", "goodyear", "hanna", "griffith", "gubber", "863abgsg", "7474", "797979", "464646", "543210", "4zqauf", "4949", "ch5nmk", "carlito", "chewey", "carebear", "caleb", "checkmat", "cheddar", "chachi", "fever", "forgetit", "fine", "forlife", "giants1", "gates", "getit", "gamble", "gerhard", "galileo", "g3ujwg", "ganja", "rufus1", "rushmore", "scouts", "discus", "dudeman", "olympus", "oscars", "osprey", "madcow", "locust", "loyola", "mammoth", "proton", "rabbit1", "question", "ptfe3xxp", "pwxd5x", "purple1", "punkass", "prophecy", "uyxnyd", "tyson1", "aircraft", "access99", "abcabc", "cocktail", "colts", "civilwar", "cleveland", "claudia1", "contour", "clement", "dddddd1", "cypher", "denied", "dapzu455", "dagmar", "daisydog", "name", "noles", "butters", "buford", "hoochie", "hotel", "hoser", "eddy", "ellis", "eldiablo", "kingrich", "mudvayne", "motown", "mp8o6d", "wife", "vipergts", "italiano", "innocent", "2055", "2211", "beavers", "bloke", "blade1", "yamato", "zooropa", "yqlgr667", "050505", "zxcvbnm1", "zw6syj", "suckcock", "tango1", "swing", "stern", "stephens", "swampy", "susanna", "tammie", "445566", "333666", "380zliki", "sexpot", "sexylady", "sixtynin", "sickboy", "spiffy", "sleeping", "skylark", "sparkles", "slam", "pintail", "phreak", "places", "teller", "timtim", "tires", "thighs", "left", "latex", "llamas", "letsdoit", "lkjhg", "landmark", "letters", "lizzard", "marlins", "marauder", "metal1", "manu", "register", "righton", "1127", "alain", "alcat", "amigo", "basebal1", "azertyui", "attract", "azrael", "hamper", "gotenks", "golfgti", "gutter", "hawkwind", "h2slca", "harman", "grace1", "6chid8", "789654", "canine", "casio", "cazzo", "chamber", "cbr900", "cabrio", "calypso", "capetown", "feline", "flathead", "fisherma", "flipmode", "fungus", "goal", "g9zns4", "full", "giggle", "gabriel1", "fuck123", "saffron", "dogmeat", "dreamcas", "dirtydog", "dunlop", "douche", "dresden", "dickdick", "destiny1", "pappy", "oaktree", "lydia", "luft4", "puta", "prayer", "ramada", "trumpet1", "vcradq", "tulip", "tracy71", "tycoon", "aaaaaaa1", "conquest", "click", "chitown", "corps", "creepers", "constant", "couples", "code", "cornhole", "danman", "dada", "density", "d9ebk7", "cummins", "darth", "cute", "nash", "nirvana1", "nixon", "norbert", "nestle", "brenda1", "bonanza", "bundy", "buddies", "hotspur", "heavy", "horror", "hufmqw", "electro", "erasure", "enough", "elisabet", "etvww4", "ewyuza", "eric1", "kinder", "kenken", "kismet", "klaatu", "musician", "milamber", "willi", "waiting", "isacs155", "igor", "1million", "1letmein", "x35v8l", "yogi", "ywvxpz", "xngwoj", "zippy1", "020202", "****", "stonewal", "sweeney", "story", "sentry", "sexsexsex", "spence", "sonysony", "smirnoff", "star12", "solace", "sledge", "states", "snyder", "star1", "paxton", "pentagon", "pkxe62", "pilot1", "pommes", "paulpaul", "plants", "tical", "tictac", "toes", "lighthou", "lemans", "kubrick", "letmein22", "letmesee", "jys6wz", "jonesy", "jjjjjj1", "jigga", "joelle", "mate", "merchant", "redstorm", "riley1", "rosa", "relief", "14141414", "1126", "allison1", "badboy1", "asthma", "auggie", "basement", "hartley", "hartford", "hardwood", "gumbo", "616913", "57np39", "56qhxs", "4mnveh", "cake", "forbes", "fatluvr69", "fqkw5m", "fidelity", "feathers", "fresno", "godiva", "gecko", "gladys", "gibson1", "gogators", "fridge", "general1", "saxman", "rowing", "sammys", "scotts", "scout1", "sasasa", "samoht", "dragon69", "ducky", "dragonball", "driller", "p3wqaw", "nurse", "papillon", "oneone", "openit", "optimist", "longshot", "portia", "rapier", "pussy2", "ralphie", "tuxedo", "ulrike", "undertow", "trenton", "copenhag", "come", "delldell", "culinary", "deltas", "mytime", "nicky", "nickie", "noname", "noles1", "bucker", "bopper", "bullock", "burnout", "bryce", "hedges", "ibilltes", "hihje863", "hitter", "ekim", "espana", "eatme69", "elpaso", "envelope", "express1", "eeeeee1", "eatme1", "karaoke", "kara", "mustang5", "misses", "wellingt", "willem", "waterski", "webcam", "jasons", "infinite", "iloveyou!", "jakarta", "belair", "bigdad", "beerme", "yoshi", "yinyang", "zimmer", "x24ik3", "063dyjuy", "0000007", "ztmfcq", "stopit", "stooges", "survival", "stockton", "symow8", "strato", "2hot4u", "ship", "simons", "skins", "shakes", "sex1", "shield", "snacks", "softtail", "slimed123", "pizzaman", "pipe", "pitt", "pathetic", "pinto", "tigercat", "tonton", "lager", "lizzy", "juju", "john123", "jennings", "josiah", "jesse1", "jordon", "jingles", "martian", "mario1", "rootedit", "rochard", "redwine", "requiem", "riverrat", "rats", "1117", "1014", "1205", "althea", "allie", "amor", "amiga", "alpina", "alert", "atreides", "banana1", "bahamut", "hart", "golfman", "happines", "7uftyx", "5432", "5353", "5151", "4747", "byron", "chatham", "chadwick", "cherie", "foxfire", "ffvdj474", "freaked", "foreskin", "gayboy", "gggggg1", "glenda", "gameover", "glitter", "funny1", "scoobydoo", "scroll", "rudolph", "saddle", "saxophon", "dingbat", "digimon", "omicron", "parsons", "ohio", "panda1", "loloxx", "macintos", "lululu", "lollypop", "racer1", "queen1", "qwertzui", "prick", "upnfmc", "tyrant", "trout1", "9skw5g", "aceman", "adelaide", "acls2h", "aaabbb", "acapulco", "aggie", "comcast", "craft", "crissy", "cloudy", "cq2kph", "custer", "d6o8pm", "cybersex", "davecole", "darian", "crumbs", "daisey", "davedave", "dasani", "needle", "mzepab", "myporn", "narnia", "nineteen", "booger1", "bravo1", "budgie", "btnjey", "highlander", "hotel6", "humbug", "edwin", "ewtosi", "kristin1", "kobe", "knuckles", "keith1", "katarina", "muff", "muschi", "montana1", "wingchun", "wiggle", "whatthe", "walking", "watching", "vette1", "vols", "virago", "intj3a", "ishmael", "intern", "jachin", "illmatic", "199999", "2010", "beck", "blender", "bigpenis", "bengal", "blue1234", "your", "zaqxsw", "xray", "xxxxxxx1", "zebras", "yanks", "worlds", "tadpole", "stripes", "svetlana", "3737", "4343", "3728", "4444444", "368ejhih", "solar", "sonne", "smalls", "sniffer", "sonata", "squirts", "pitcher", "playstation", "pktmxr", "pescator", "points", "texaco", "lesbos", "lilian", "l8v53x", "jo9k2jw2", "jimbeam", "josie", "jimi", "jupiter2", "jurassic", "marines1", "maya", "rocket1", "ringer", "14725836", "12345679", "1219", "123098", "1233", "alessand", "althor", "angelika", "arch", "armando", "alpha123", "basher", "barefeet", "balboa", "bbbbb1", "banks", "badabing", "harriet", "gopack", "golfnut", "gsxr1000", "gregory1", "766rglqy", "8520", "753159", "8dihc6", "69camaro", "666777", "cheeba", "chino", "calendar", "cheeky", "camel1", "fishcake", "falling", "flubber", "giuseppe", "gianni", "gloves", "gnasher23", "frisbee", "fuzzy1", "fuzzball", "sauce", "save13tx", "schatz", "russell1", "sandra1", "scrotum", "scumbag", "sabre", "samdog", "dripping", "dragon12", "dragster", "paige", "orwell", "mainland", "lunatic", "lonnie", "lotion", "maine", "maddux", "qn632o", "poophead", "rapper", "porn4life", "producer", "rapunzel", "tracks", "velocity", "vanessa1", "ulrich", "trueblue", "vampire1", "abacus", "902100", "crispy", "corky", "crane", "chooch", "d6wnro", "cutie", "deal", "dabulls", "dehpye", "navyseal", "njqcw4", "nownow", "nigger1", "nightowl", "nonenone", "nightmar", "bustle", "buddy2", "boingo", "bugman", "bulletin", "bosshog", "bowie", "hybrid", "hillside", "hilltop", "hotlegs", "honesty", "hzze929b", "hhhhh1", "hellohel", "eloise", "evilone", "edgewise", "e5pftu", "eded", "embalmer", "excalibur", "elefant", "kenzie", "karl", "karin", "killah", "kleenex", "mouses", "mounta1n", "motors", "mutley", "muffdive", "vivitron", "winfield", "wednesday", "w00t88", "iloveit", "jarjar", "incest", "indycar", "17171717", "1664", "17011701", "222777", "2663", "beelch", "benben", "yitbos", "yyyyy1", "yasmin", "zapata", "zzzzz1", "stooge", "tangerin", "taztaz", "stewart1", "summer69", "sweetness", "system1", "surveyor", "stirling", "3qvqod", "3way", "456321", "sizzle", "simhrq", "shrink", "shawnee", "someday", "sparty", "ssptx452", "sphere", "spark", "slammed", "sober", "persian", "peppers", "ploppy", "pn5jvw", "poobear", "pianos", "plaster", "testme", "tiff", "thriller", "larissa", "lennox", "jewell", "master12", "messier", "rockey", "1229", "1217", "1478", "1009", "anastasi", "almighty", "amonra", "aragon", "argentin", "albino", "azazel", "grinder", "6uldv8", "83y6pv", "8888888", "4tlved", "515051", "carsten", "changes", "flanders", "flyers88", "ffffff1", "firehawk", "foreman", "firedog", "flashman", "ggggg1", "gerber", "godspeed", "galway", "giveitup", "funtimes", "gohan", "giveme", "geryfe", "frenchie", "sayang", "rudeboy", "savanna", "sandals", "devine", "dougal", "drag0n", "dga9la", "disaster", "desktop", "only", "onlyone", "otter", "pandas", "mafia", "lombard", "luckys", "lovejoy", "lovelife", "manders", "product", "qqh92r", "qcmfd454", "pork", "radar1", "punani", "ptbdhw", "turtles", "undertaker", "trs8f7", "tramp", "ugejvp", "abba", "911turbo", "acdc", "abcd123", "clever", "corina", "cristian", "create", "crash1", "colony", "crosby", "delboy", "daniele", "davinci", "daughter", "notebook", "niki", "nitrox", "borabora", "bonzai", "budd", "brisbane", "hotter", "heeled", "heroes", "hooyah", "hotgirl", "i62gbq", "horse1", "hills", "hpk2qc", "epvjb6", "echo", "korean", "kristie", "mnbvc", "mohammad", "mind", "mommy1", "munster", "wade", "wiccan", "wanted", "jacket", "2369", "bettyboo", "blondy", "bismark", "beanbag", "bjhgfi", "blackice", "yvtte545", "ynot", "yess", "zlzfrh", "wolvie", "007bond", "******", "tailgate", "tanya1", "sxhq65", "stinky1", "3234412", "3ki42x", "seville", "shimmer", "sheryl", "sienna", "shitshit", "skillet", "seaman", "sooners1", "solaris", "smartass", "pastor", "pasta", "pedros", "pennywis", "pfloyd", "tobydog", "thetruth", "lethal", "letme1n", "leland", "jenifer", "mario66", "micky", "rocky2", "rewq", "ripped", "reindeer", "1128", "1207", "1104", "1432", "aprilia", "allstate", "alyson", "bagels", "basic", "baggies", "barb", "barrage", "greatest", "gomez", "guru", "guard", "72d5tn", "606060", "4wcqjn", "caldwell", "chance1", "catalog", "faust", "film", "flange", "fran", "fartman", "geil", "gbhcf2", "fussball", "glen", "fuaqz4", "gameboy", "garnet", "geneviev", "rotary", "seahawk", "russel", "saab", "seal", "samadams", "devlt4", "ditto", "drevil", "drinker", "deuce", "dipstick", "donut", "octopus", "ottawa", "losangel", "loverman", "porky", "q9umoz", "rapture", "pump", "pussy4me", "university", "triplex", "ue8fpw", "trent", "trophy", "turbos", "troubles", "agent", "aaa340", "churchil", "crazyman", "consult", "creepy", "craven", "class", "cutiepie", "ddddd1", "dejavu", "cuxldv", "nettie", "nbvibt", "nikon", "niko", "norwood", "nascar1", "nolan", "bubba2", "boobear", "boogers", "buff", "bullwink", "bully", "bulldawg", "horsemen", "escalade", "editor", "eagle2", "dynamic", "ella", "efyreg", "edition", "kidney", "minnesot", "mogwai", "morrow", "msnxbi", "moonlight", "mwq6qlzo", "wars", "werder", "verygood", "voodoo1", "wheel", "iiiiii1", "159951", "1624", "1911a1", "2244", "bellagio", "bedlam", "belkin", "bill1", "woodrow", "xirt2k", "worship", "??????", "tanaka", "swift", "susieq", "sundown", "sukebe", "tales", "swifty", "2fast4u", "senate", "sexe", "sickness", "shroom", "shaun", "seaweed", "skeeter1", "status", "snicker", "sorrow", "spanky1", "spook", "patti", "phaedrus", "pilots", "pinch", "peddler", "theo", "thumper1", "tessie", "tiger7", "tmjxn151", "thematri", "l2g7k3", "letmeinn", "lazy", "jeffjeff", "joan", "johnmish", "mantra", "mariana", "mike69", "marshal", "mart", "mazda6", "riptide", "robots", "rental", "1107", "1130", "142857", "11001001", "1134", "armored", "alvin", "alec", "allnight", "alright", "amatuers", "bartok", "attorney", "astral", "baboon", "bahamas", "balls1", "bassoon", "hcleeb", "happyman", "granite", "graywolf", "golf1", "gomets", "8vjzus", "7890", "789123", "8uiazp", "5757", "474jdvff", "551scasi", "50cent", "camaro1", "cherry1", "chemist", "final", "firenze", "fishtank", "farrell", "freewill", "glendale", "frogfrog", "gerhardt", "ganesh", "same", "scirocco", "devilman", "doodles", "dinger", "okinawa", "olympic", "nursing", "orpheus", "ohmygod", "paisley", "pallmall", "null", "lounge", "lunchbox", "manhatta", "mahalo", "mandarin", "qwqwqw", "qguvyt", "pxx3eftp", "president", "rambler", "puzzle", "poppy1", "turk182", "trotter", "vdlxuc", "trish", "tugboat", "valiant", "tracie", "uwrl7c", "chris123", "coaster", "cmfnpu", "decimal", "debbie1", "dandy", "daedalus", "dede", "natasha1", "nissan1", "nancy123", "nevermin", "napalm", "newcastle", "boats", "branden", "britt", "bonghit", "hester", "ibxnsm", "hhhhhh1", "holger", "durham", "edmonton", "erwin", "equinox", "dvader", "kimmy", "knulla", "mustafa", "monsoon", "mistral", "morgana", "monica1", "mojave", "month", "monterey", "mrbill", "vkaxcs", "victor1", "wacker", "wendell", "violator", "vfdhif", "wilson1", "wavpzt", "verena", "wildstar", "winter99", "iqzzt580", "jarrod", "imback", "1914", "19741974", "1monkey", "1q2w3e4r5t", "2500", "2255", "blank", "bigshow", "bigbucks", "blackcoc", "zoomer", "wtcacq", "wobble", "xmen", "xjznq5", "yesterda", "yhwnqc", "zzzxxx", "streak", "393939", "2fchbg", "skinhead", "skilled", "shakira", "shaft", "shadow12", "seaside", "sigrid", "sinful", "silicon", "smk7366", "snapshot", "sniper1", "soccer11", "staff", "slap", "smutty", "peepers", "pleasant", "plokij", "pdiddy", "pimpdaddy", "thrust", "terran", "topaz", "today1", "lionhear", "littlema", "lauren1", "lincoln1", "lgnu9d", "laughing", "juneau", "methos", "medina", "merlyn", "rogue1", "romulus", "redshift", "1202", "1469", "12locked", "arizona1", "alfarome", "al9agd", "aol123", "altec", "apollo1", "arse", "baker1", "bbb747", "bach", "axeman", "astro1", "hawthorn", "goodfell", "hawks1", "gstring", "hannes", "8543852", "868686", "4ng62t", "554uzpad", "5401", "567890", "5232", "catfood", "frame", "flow", "fire1", "flipflop", "fffff1", "fozzie", "fluff", "garrison", "fzappa", "furious", "round", "rustydog", "sandberg", "scarab", "satin", "ruger", "samsung1", "destin", "diablo2", "dreamer1", "detectiv", "dominick", "doqvq3", "drywall", "paladin1", "papabear", "offroad", "panasonic", "nyyankee", "luetdi", "qcfmtz", "pyf8ah", "puddles", "privacy", "rainer", "pussyeat", "ralph1", "princeto", "trivia", "trewq", "tri5a3", "advent", "9898", "agyvorc", "clarkie", "coach1", "courier", "contest", "christo", "corinna", "chowder", "concept", "climbing", "cyzkhw", "davidb", "dad2ownu", "days", "daredevi", "de7mdf", "nose", "necklace", "nazgul", "booboo1", "broad", "bonzo", "brenna", "boot", "butch1", "huskers1", "hgfdsa", "hornyman", "elmer", "elektra", "england1", "elodie", "kermit1", "knife", "kaboom", "minute", "modern", "motherfucker", "morten", "mocha", "monday1", "morgoth", "ward", "weewee", "weenie", "walters", "vorlon", "website", "wahoo", "ilovegod", "insider", "jayman", "1911", "1dallas", "1900", "1ranger", "201jedlz", "2501", "1qaz", "bertram", "bignuts", "bigbad", "beebee", "billows", "belize", "bebe", "wvj5np", "wu4etd", "yamaha1", "wrinkle5", "zebra1", "yankee1", "zoomzoom", "09876543", "0311", "?????", "stjabn", "tainted", "3tmnej", "shoot", "skooter", "skelter", "sixteen", "starlite", "smack", "spice1", "stacey1", "smithy", "perrin", "pollux", "peternorth", "pixie", "paulina", "piston", "pick", "poets", "pine", "toons", "tooth", "topspin", "kugm7b", "legends", "jeepjeep", "juliana", "joystick", "junkmail", "jojojojo", "jonboy", "judge", "midland", "meteor", "mccabe", "matter", "mayfair", "meeting", "merrill", "raul", "riches", "reznor", "rockrock", "reboot", "reject", "robyn", "renee1", "roadway", "rasta220", "1411", "1478963", "1019", "archery", "allman", "andyandy", "barks", "bagpuss", "auckland", "gooseman", "hazmat", "gucci", "guns", "grammy", "happydog", "greek", "7kbe9d", "7676", "6bjvpe", "5lyedn", "5858", "5291", "charlie2", "chas", "c7lrwu", "candys", "chateau", "ccccc1", "cardinals", "fear", "fihdfv", "fortune12", "gocats", "gaelic", "fwsadn", "godboy", "gldmeo", "fx3tuo", "fubar1", "garland", "generals", "gforce", "rxmtkp", "rulz", "sairam", "dunhill", "division", "dogggg", "detect", "details", "doll", "drinks", "ozlq6qwm", "ov3ajy", "lockout", "makayla", "macgyver", "mallorca", "loves", "prima", "pvjegu", "qhxbij", "raphael", "prelude1", "totoro", "tusymo", "trousers", "tunnel", "valeria", "tulane", "turtle1", "tracy1", "aerosmit", "abbey1", "address", "clticic", "clueless", "cooper1", "comets", "collect", "corbin", "delpiero", "derick", "cyprus", "dante1", "dave1", "nounours", "neal", "nexus6", "nero", "nogard", "norfolk", "brent1", "booyah", "bootleg", "buckaroo", "bulls23", "bulls1", "booper", "heretic", "icecube", "hellno", "hounds", "honeydew", "hooters1", "hoes", "howie", "hevnm4", "hugohugo", "eighty", "epson", "evangeli", "eeeee1", "eyphed"];

module.exports = CommonPasswords;

/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

// https://github.com/xbsoftware/enjoyhint
// (+ some custom changes for binary.com)

var $ = __webpack_require__(72);
var Kinetic = __webpack_require__(555);

module.exports = function (_options) {
    var that = this;
    // Some options
    var defaults = {
        onStart: function onStart() {},
        onEnd: function onEnd() {}
    };
    var options = $.extend(defaults, _options);

    var data = [];
    var current_step = 0;

    $body = $('body');

    /********************* PRIVAT METHODS ***************************************/
    var init = function init() {
        if ($('.enjoyhint')) $('.enjoyhint').remove();
        $("html, body").css({ 'overflow': 'hidden' });
        $(document).on("touchmove", lockTouch);

        $body.enjoyhint({
            onNextClick: function onNextClick() {
                current_step++;
                stepAction();
            },
            onSkipClick: function onSkipClick() {
                var step_data = data[current_step];
                var $element = $(step_data.selector);
                off(step_data.event);
                $element.off(makeEventName(step_data.event));
                destroyEnjoy();
            }
        });
    };

    var lockTouch = function lockTouch(e) {
        e.preventDefault();
    };

    var destroyEnjoy = function destroyEnjoy() {
        $body = $('body');
        $('.enjoyhint').remove();
        $("html, body").css({ 'overflow': 'auto' });
        $("html, body").css({ 'overflow-x': 'hidden' });
        $(document).off("touchmove", lockTouch);
    };

    that.clear = function () {
        //Remove userClass and set default text
        $(".enjoyhint_next_btn").removeClass(that.nextUserClass);
        $(".enjoyhint_next_btn").text("Next");
        $(".enjoyhint_skip_btn").removeClass(that.skipUserClass);
        $(".enjoyhint_skip_btn").text("Skip");
    };

    var $body = $('body');
    var stepAction = function stepAction() {
        if (data && data[current_step]) {
            $(".enjoyhint").removeClass("enjoyhint-step-" + current_step);
            $(".enjoyhint").addClass("enjoyhint-step-" + (current_step + 1));
            var step_data = data[current_step];
            if (step_data.onBeforeStart && typeof step_data.onBeforeStart === 'function') {
                step_data.onBeforeStart();
            }
            var timeout = step_data.timeout || 0;
            setTimeout(function () {
                if (!step_data.selector) {
                    for (var prop in step_data) {
                        if (step_data.hasOwnProperty(prop) && prop.split(" ")[1]) {
                            step_data.selector = prop.split(" ")[1];
                            step_data.event = prop.split(" ")[0];
                            if (prop.split(" ")[0] == 'next' || prop.split(" ")[0] == 'auto' || prop.split(" ")[0] == 'custom') {
                                step_data.event_type = prop.split(" ")[0];
                            }
                            step_data.description = step_data[prop];
                        }
                    }
                }
                setTimeout(function () {
                    that.clear();
                }, 250);
                $(document.body).scrollTo(step_data.selector, step_data.scrollAnimationSpeed || 250, { offset: -100 });
                setTimeout(function () {
                    var $element = $(step_data.selector);
                    var event = makeEventName(step_data.event);

                    $body.enjoyhint('show');
                    $body.enjoyhint('hide_next');
                    var $event_element = $element;
                    if (step_data.event_selector) {
                        $event_element = $(step_data.event_selector);
                    }
                    if (!step_data.event_type && step_data.event == "key") {
                        $element.keydown(function (event) {
                            if (event.which == step_data.keyCode) {
                                current_step++;
                                stepAction();
                            }
                        });
                    }
                    if (step_data.showNext == true) {
                        $body.enjoyhint('show_next');
                    }
                    if (step_data.showSkip == true) {
                        $body.enjoyhint('show_skip');
                    } else {
                        $body.enjoyhint('hide_skip');
                    }
                    if (step_data.showSkip == true) {}

                    if (step_data.nextButton) {
                        $(".enjoyhint_next_btn").addClass(step_data.nextButton.className || "");
                        $(".enjoyhint_next_btn").html(step_data.nextButton.html || "Next");
                        that.nextUserClass = step_data.nextButton.className;
                    }

                    if (step_data.skipButton) {
                        $(".enjoyhint_skip_btn").addClass(step_data.skipButton.className || "");
                        $(".enjoyhint_skip_btn").html(step_data.skipButton.html || "Skip");
                        that.skipUserClass = step_data.skipButton.className;
                    }

                    if (step_data.event_type) {
                        switch (step_data.event_type) {
                            case 'auto':
                                $element[step_data.event]();
                                switch (step_data.event) {
                                    case 'click':
                                        break;
                                }
                                current_step++;
                                stepAction();
                                return;
                                break;
                            case 'custom':
                                on(step_data.event, function () {
                                    current_step++;
                                    off(step_data.event);
                                    stepAction();
                                });
                                break;
                            case 'next':
                                $body.enjoyhint('show_next');
                                break;

                        }
                    } else {
                        $event_element.on(event, function (e) {
                            if (step_data.keyCode && e.keyCode != step_data.keyCode) {
                                return;
                            }
                            current_step++;
                            $(this).off(event);

                            stepAction();
                        });
                    }
                    var max_habarites = Math.max($element.outerWidth(), $element.outerHeight());
                    var radius = step_data.radius || Math.round(max_habarites / 2) + 5;
                    var offset = $element.offset();
                    var w = $element.outerWidth();
                    var h = $element.outerHeight();
                    var shape_margin = step_data.margin !== undefined ? step_data.margin : 10;
                    var coords = {
                        x: offset.left + Math.round(w / 2),
                        y: offset.top + Math.round(h / 2) - $(document).scrollTop()
                    };
                    var shape_data = {
                        center_x: coords.x,
                        center_y: coords.y,
                        text: step_data.description,
                        top: step_data.top,
                        bottom: step_data.bottom,
                        left: step_data.left,
                        right: step_data.right,
                        margin: step_data.margin,
                        scroll: step_data.scroll
                    };

                    if (step_data.shape && step_data.shape == 'circle') {
                        shape_data.shape = 'circle';
                        shape_data.radius = radius;
                    } else {
                        shape_data.radius = 0;
                        shape_data.width = w + shape_margin;
                        shape_data.height = h + shape_margin;
                    }
                    $body.enjoyhint('render_label_with_shape', shape_data);
                }, step_data.scrollAnimationSpeed + 20 || 270);
            }, timeout);
        } else {
            $body.enjoyhint('hide');
            options.onEnd();
            destroyEnjoy();
        }
    };

    var makeEventName = function makeEventName(name, is_custom) {
        return name + (is_custom ? 'custom' : '') + '.enjoy_hint';
    };

    var on = function on(event_name, callback) {
        $body.on(makeEventName(event_name, true), callback);
    };
    var off = function off(event_name) {
        $body.off(makeEventName(event_name, true));
    };

    /********************* PUBLIC METHODS ***************************************/
    that.runScript = function () {
        current_step = 0;
        options.onStart();
        stepAction();
    };

    that.resumeScript = function () {
        stepAction();
    };

    that.getCurrentStep = function () {
        return current_step;
    };

    that.trigger = function (event_name) {
        $body.trigger(makeEventName(event_name, true));
    };

    that.setScript = function (_data) {
        if (_data) {
            data = _data;
        }
    };

    //support deprecated API methods
    that.set = function (_data) {
        that.setScript(_data);
    };

    that.setSteps = function (_data) {
        that.setScript(_data);
    };

    that.run = function () {
        that.runScript();
    };

    that.resume = function () {
        that.resumeScript();
    };

    init();
};

if (typeof CanvasRenderingContext2D !== 'undefined') {
    CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
        if (w < 2 * r) r = w / 2;
        if (h < 2 * r) r = h / 2;
        this.beginPath();
        this.moveTo(x + r, y);
        this.arcTo(x + w, y, x + w, y + h, r);
        this.arcTo(x + w, y + h, x, y + h, r);
        this.arcTo(x, y + h, x, y, r);
        this.arcTo(x, y, x + w, y, r);
        this.closePath();
        return this;
    };
}

var methods = {
    init: function init(options) {
        //console.log(options,'-------------');
        return this.each(function () {
            var defaults = {
                onNextClick: function onNextClick() {},
                onSkipClick: function onSkipClick() {},
                animation_time: 800
            };

            this.enjoyhint_obj = {};
            var that = this.enjoyhint_obj;
            var $that = $(this);
            var $body = $('body');
            that.options = jQuery.extend(defaults, options);

            //general classes
            that.gcl = {
                chooser: 'enjoyhint'
            };

            // classes
            that.cl = {
                enjoy_hint: 'enjoyhint',
                hide: 'enjoyhint_hide',
                disable_events_element: 'enjoyhint_disable_events',
                btn: 'enjoyhint_btn',
                skip_btn: 'enjoyhint_skip_btn',
                close_btn: 'enjoyhint_close_btn',
                next_btn: 'enjoyhint_next_btn',
                main_canvas: 'enjoyhint_canvas',
                main_svg: 'enjoyhint_svg',
                svg_wrapper: 'enjoyhint_svg_wrapper',
                svg_transparent: 'enjoyhint_svg_transparent',
                kinetic_container: 'kinetic_container'
            };
            function makeSVG(tag, attrs) {
                var el = document.createElementNS('http://www.w3.org/2000/svg', tag);
                for (var k in attrs) {
                    el.setAttribute(k, attrs[k]);
                }return el;
            }

            // =======================================================================
            // ========================---- enjoyhint ----==============================
            // =======================================================================
            that.canvas_size = {
                w: $(window).width() * 1.4,
                h: $(window).height() * 1.4
            };
            var canvas_id = "enj_canvas";

            that.enjoyhint = $('<div>', { 'class': that.cl.enjoy_hint + ' ' + that.cl.svg_transparent }).appendTo($that);
            that.enjoyhint_svg_wrapper = $('<div>', { 'class': that.cl.svg_wrapper + ' ' + that.cl.svg_transparent }).appendTo(that.enjoyhint);
            that.$stage_container = $('<div id="' + that.cl.kinetic_container + '">').appendTo(that.enjoyhint);
            that.$canvas = $('<canvas id="' + canvas_id + '" width="' + that.canvas_size.w + '" height="' + that.canvas_size.h + '" class="' + that.cl.main_canvas + '">').appendTo(that.enjoyhint);
            that.$svg = $('<svg width="' + that.canvas_size.w + '" height="' + that.canvas_size.h + '" class="' + that.cl.main_canvas + ' ' + that.cl.main_svg + '">').appendTo(that.enjoyhint_svg_wrapper);
            var defs = $(makeSVG('defs'));
            var marker = $(makeSVG('marker', { id: "arrowMarker", viewBox: "0 0 36 21", refX: "21", refY: "10", markerUnits: "strokeWidth", orient: "auto", markerWidth: "16", markerHeight: "12" }));
            var polilyne = $(makeSVG('path', { style: "fill:none; stroke:rgb(255,255,255); stroke-width:2", d: "M0,0 c30,11 30,9 0,20" }));
            defs.append(marker.append(polilyne)).appendTo(that.$svg);
            that.kinetic_stage = new Kinetic.Stage({
                container: that.cl.kinetic_container,
                width: that.canvas_size.w,
                height: that.canvas_size.h
            });
            //console.log(that.enjoyhint);

            that.layer = new Kinetic.Layer();
            that.rect = new Kinetic.Rect({
                //          x: 0,
                //          y: 0,
                fill: 'rgba(0,0,0,0.6)',
                width: that.canvas_size.w,
                height: that.canvas_size.h
            });

            var $top_dis_events = $('<div>', { 'class': that.cl.disable_events_element }).appendTo(that.enjoyhint);
            var $bottom_dis_events = $top_dis_events.clone().appendTo(that.enjoyhint);
            var $left_dis_events = $top_dis_events.clone().appendTo(that.enjoyhint);
            var $right_dis_events = $top_dis_events.clone().appendTo(that.enjoyhint);

            that.$skip_btn = $('<div>', { 'class': that.cl.skip_btn }).appendTo(that.enjoyhint).html('Skip').click(function (e) {
                that.hide();
                that.options.onSkipClick();
            });
            that.$next_btn = $('<div>', { 'class': that.cl.next_btn }).appendTo(that.enjoyhint).html('Next').click(function (e) {
                that.options.onNextClick();
            });

            that.$close_btn = $('<div>', { 'class': that.cl.close_btn }).appendTo(that.enjoyhint).html('').click(function (e) {
                that.hide();
                that.options.onSkipClick();
            });

            that.$canvas.mousedown(function (e) {
                //console.log('cl')
                $('canvas').css({ left: '4000px' });

                var BottomElement = document.elementFromPoint(e.clientX, e.clientY);
                //console.log(BottomElement.tagName)
                $('canvas').css({ left: '0' });

                $(BottomElement).click();
                //          that.$canvas.show();
                return false;
            });

            var circle_r = 0;
            var shape_init_shift = 130;
            that.shape = new Kinetic.Shape({
                radius: circle_r,
                center_x: -shape_init_shift,
                center_y: -shape_init_shift,
                width: 0,
                height: 0,
                sceneFunc: function sceneFunc(context) {
                    var ctx = this.getContext("2d")._context;
                    var pos = this.pos;
                    var def_comp = ctx.globalCompositeOperation;
                    ctx.globalCompositeOperation = 'destination-out';
                    ctx.beginPath();

                    var x = this.attrs.center_x - Math.round(this.attrs.width / 2);
                    var y = this.attrs.center_y - Math.round(this.attrs.height / 2);
                    ctx.roundRect(x, y, this.attrs.width, this.attrs.height, this.attrs.radius);
                    ctx.fillStyle = "red";
                    ctx.fill();

                    ctx.globalCompositeOperation = def_comp;
                }
            });
            that.shape.radius = circle_r;
            that.layer.add(that.rect);
            that.layer.add(that.shape);
            that.kinetic_stage.add(that.layer);

            var enjoyhint_elements = [that.enjoyhint, $top_dis_events, $bottom_dis_events, $left_dis_events, $right_dis_events];

            that.show = function () {
                that.enjoyhint.removeClass(that.cl.hide);
            };

            that.hide = function () {
                that.enjoyhint.addClass(that.cl.hide);
                var tween = new Kinetic.Tween({
                    node: that.shape,
                    duration: 0.002,
                    center_x: -shape_init_shift,
                    center_y: -shape_init_shift
                });
                tween.play();
            };

            that.hide();

            that.hideNextBtn = function () {
                that.$next_btn.addClass(that.cl.hide);
                that.nextBtn = "hide";
            };
            that.showNextBtn = function () {
                that.$next_btn.removeClass(that.cl.hide);
                that.nextBtn = "show";
            };

            that.hideSkipBtn = function () {
                that.$skip_btn.addClass(that.cl.hide);
            };
            that.showSkipBtn = function () {
                that.$skip_btn.removeClass(that.cl.hide);
            };

            that.renderCircle = function (data) {
                var r = data.r || 0;
                var x = data.x || 0;
                var y = data.y || 0;

                var tween = new Kinetic.Tween({
                    node: that.shape,
                    duration: 0.2,
                    center_x: x,
                    center_y: y,
                    width: r * 2,
                    height: r * 2,
                    radius: r
                });
                tween.play();

                var left = x - r;
                var right = x + r;
                var top = y - r;
                var bottom = y + r;
                var margin = 20;
                return {
                    x: x,
                    y: y,
                    left: left,
                    right: right,
                    top: top,
                    bottom: bottom,
                    conn: {
                        left: {
                            x: left - margin,
                            y: y
                        },
                        right: {
                            x: right + margin,
                            y: y
                        },
                        top: {
                            x: x,
                            y: top - margin
                        },
                        bottom: {
                            x: x,
                            y: bottom + margin
                        }
                    }
                };
            };

            that.renderRect = function (data) {
                var r = data.r || 0;
                var x = data.x || 0;
                var y = data.y || 0;
                var w = data.w || 0;
                var h = data.h || 0;
                var margin = 20;
                var tween = new Kinetic.Tween({
                    node: that.shape,
                    duration: 0.2,
                    center_x: x,
                    center_y: y,
                    width: w,
                    height: h,
                    radius: r
                });
                tween.play();
                var half_w = Math.round(w / 2);
                var half_h = Math.round(h / 2);
                var left = x - half_w;
                var right = x + half_w;
                var top = y - half_h;
                var bottom = y + half_h;
                return {
                    x: x,
                    y: y,
                    left: left,
                    right: right,
                    top: top,
                    bottom: bottom,
                    conn: {
                        left: {
                            x: left - margin,
                            y: y
                        },
                        right: {
                            x: right + margin,
                            y: y
                        },
                        top: {
                            x: x,
                            y: top - margin
                        },
                        bottom: {
                            x: x,
                            y: bottom + margin
                        }
                    }
                };
            };
            that.renderLabel = function (data) {
                var x = data.x || 0;
                var y = data.y || 0;
                var text = data.text || 0;

                var label = that.getLabelElement({
                    x: x,
                    y: y,
                    text: data.text
                });
                var label_w = label.width();
                var label_h = label.height();
                var label_left = label.offset().left;
                var label_right = label.offset().left + label_w;
                var label_top = label.offset().top - $(document).scrollTop();;
                var label_bottom = label.offset().top + label_h;

                var margin = 10;
                var conn_left = {
                    x: label_left - margin,
                    y: label_top + Math.round(label_h / 2)
                };
                var conn_right = {
                    x: label_right + margin,
                    y: label_top + Math.round(label_h / 2)
                };
                var conn_top = {
                    x: label_left + Math.round(label_w / 2),
                    y: label_top - margin
                };
                var conn_bottom = {
                    x: label_left + Math.round(label_w / 2),
                    y: label_bottom + margin
                };
                label.detach();
                setTimeout(function () {
                    $('#enjoyhint_label').remove();
                    label.appendTo(that.enjoyhint);
                }, that.options.animation_time / 2);
                return {
                    label: label,
                    left: label_left,
                    right: label_right,
                    top: label_top,
                    bottom: label_bottom,
                    conn: {
                        left: conn_left,
                        right: conn_right,
                        top: conn_top,
                        bottom: conn_bottom
                    }

                };
            };
            that.renderArrow = function (data) {
                var x_from = data.x_from || 0;
                var y_from = data.y_from || 0;
                var x_to = data.x_to || 0;
                var y_to = data.y_to || 0;
                var by_top_side = data.by_top_side;
                var control_point_x = 0;
                var control_point_y = 0;
                if (by_top_side) {
                    if (y_from >= y_to) {
                        control_point_y = y_to;
                        control_point_x = x_from;
                    } else {
                        control_point_y = y_from;
                        control_point_x = x_to;
                    }
                } else {
                    if (y_from >= y_to) {
                        control_point_y = y_from;
                        control_point_x = x_to;
                    } else {
                        control_point_y = y_to;
                        control_point_x = x_from;
                    }
                }

                var text = data.text || '';
                that.enjoyhint.addClass(that.cl.svg_transparent);
                setTimeout(function () {
                    $('#enjoyhint_arrpw_line').remove();
                    var d = 'M' + x_from + ',' + y_from + ' Q' + control_point_x + ',' + control_point_y + ' ' + x_to + ',' + y_to;
                    that.$svg.append(makeSVG('path', { style: "fill:none; stroke:rgb(255,255,255); stroke-width:3", 'marker-end': "url(#arrowMarker)", d: d, id: 'enjoyhint_arrpw_line' }));
                    that.enjoyhint.removeClass(that.cl.svg_transparent);
                }, that.options.animation_time / 2);
            };

            that.getLabelElement = function (data) {
                return $('<div>', { "class": 'enjoy_hint_label', id: 'enjoyhint_label' }).css({
                    'top': data.y + 'px',
                    'left': data.x + 'px'
                }).html(data.text).appendTo(that.enjoyhint);
            };

            that.disableEventsNearRect = function (rect) {
                $top_dis_events.css({
                    top: '0',
                    left: '0'
                }).height(rect.top);
                $bottom_dis_events.css({
                    top: rect.bottom + 'px',
                    left: '0'
                });
                $left_dis_events.css({
                    top: '0',
                    left: 0 + 'px'
                }).width(rect.left);
                $right_dis_events.css({
                    top: '0',
                    left: rect.right + 'px'
                });
            };

            that.renderLabelWithShape = function (data) {
                var shape_type = data.shape || 'rect';
                var shape_data = {};

                var half_w = 0;
                var half_h = 0;

                var shape_offsets = {
                    top: data.top || 0,
                    bottom: data.bottom || 0,
                    left: data.left || 0,
                    right: data.right || 0
                };

                switch (shape_type) {
                    case 'circle':
                        half_w = half_h = data.radius;
                        var sides_pos = {
                            top: data.center_y - half_h + shape_offsets.top,
                            bottom: data.center_y + half_h - shape_offsets.bottom,
                            left: data.center_x - half_w + shape_offsets.left,
                            right: data.center_x + half_w - shape_offsets.right
                        };
                        var width = sides_pos.right - sides_pos.left;
                        var height = sides_pos.bottom - sides_pos.top;
                        data.radius = Math.round(Math.min(width, height) / 2);
                        //new half habarites
                        half_w = half_h = Math.round(data.radius / 2);

                        var new_half_w = Math.round(width / 2);
                        var new_half_h = Math.round(height / 2);
                        //new center_x and center_y
                        data.center_x = sides_pos.left + new_half_w;
                        data.center_y = sides_pos.top + new_half_h;

                        shape_data = that.renderCircle({
                            x: data.center_x,
                            y: data.center_y,
                            r: data.radius
                        });

                        break;
                    case 'rect':
                        half_w = Math.round(data.width / 2);
                        half_h = Math.round(data.height / 2);

                        var sides_pos = {
                            top: data.center_y - half_h + shape_offsets.top,
                            bottom: data.center_y + half_h - shape_offsets.bottom,
                            left: data.center_x - half_w + shape_offsets.left,
                            right: data.center_x + half_w - shape_offsets.right
                        };
                        data.width = sides_pos.right - sides_pos.left;
                        data.height = sides_pos.bottom - sides_pos.top;

                        half_w = Math.round(data.width / 2);
                        half_h = Math.round(data.height / 2);
                        //new center_x and center_y
                        data.center_x = sides_pos.left + half_w;
                        data.center_y = sides_pos.top + half_h;
                        shape_data = that.renderRect({
                            x: data.center_x,
                            y: data.center_y,
                            w: data.width,
                            h: data.height,
                            r: data.radius
                        });
                        break;
                }

                var body_size = {
                    w: that.enjoyhint.width(),
                    h: that.enjoyhint.height()
                };
                //temp label used for detect label width and height
                var label = that.getLabelElement({
                    x: 0,
                    y: 0,
                    text: data.text
                });
                var label_width = label.outerWidth();
                var label_height = label.outerHeight();
                label.remove();
                var top_offset = data.center_y - half_h;
                var bottom_offset = body_size.h - (data.center_y + half_h);
                var left_offset = data.center_x - half_w;
                var right_offset = body_size.w - (data.center_x + half_w);

                var label_hor_side = body_size.w - data.center_x < data.center_x ? 'left' : 'right';
                var label_ver_side = body_size.h - data.center_y < data.center_y ? 'top' : 'bottom';
                var label_shift = 150;
                var label_margin = 40;
                var label_shift_with_label_width = label_shift + label_width + label_margin;
                var label_shift_with_label_height = label_shift + label_height + label_margin;
                var label_hor_offset = half_w + label_shift;
                var label_ver_offset = half_h + label_shift;

                var label_x = label_hor_side == 'left' ? data.center_x - label_hor_offset - label_width : data.center_x + label_hor_offset;
                var label_y = label_ver_side == 'top' ? data.center_y - label_ver_offset - label_height : data.center_y + label_ver_offset;
                if (top_offset < label_shift_with_label_height && bottom_offset < label_shift_with_label_height) {
                    label_y = data.center_y + label_margin;
                }
                if (left_offset < label_shift_with_label_width && right_offset < label_shift_with_label_width) {
                    label_x = data.center_x;
                }

                var label_data = that.renderLabel({
                    x: label_x,
                    y: label_y,
                    text: data.text
                });

                that.$next_btn.css({
                    left: label_x,
                    top: label_y + label_height + 15
                });
                var left_skip = label_x + that.$next_btn.width() + 10;
                //console.log(that.nextBtn);
                if (that.nextBtn == "hide") {
                    left_skip = label_x;
                }

                that.$skip_btn.css({
                    left: left_skip,
                    top: label_y + label_height + 15
                });
                that.$close_btn.css({
                    right: 10,
                    top: 10
                });

                that.disableEventsNearRect({
                    top: shape_data.top,
                    bottom: shape_data.bottom,
                    left: shape_data.left,
                    right: shape_data.right
                });

                var x_to = 0;
                var y_to = 0;
                var arrow_side = false;
                var conn_label_side = 'left';
                var conn_circle_side = 'left';

                var is_center = label_data.left <= shape_data.x && label_data.right >= shape_data.x;
                var is_left = label_data.right < shape_data.x;
                var is_right = label_data.left > shape_data.x;

                var is_abs_left = label_data.right < shape_data.left;
                var is_abs_right = label_data.left > shape_data.right;

                var is_top = label_data.bottom < shape_data.top;
                var is_bottom = label_data.top > shape_data.bottom;
                var is_mid = label_data.bottom >= shape_data.y && label_data.top <= shape_data.y;
                var is_mid_top = label_data.bottom <= shape_data.y && !is_top;
                var is_mid_bottom = label_data.top >= shape_data.y && !is_bottom;

                function setArrowData(l_s, c_s, a_s) {
                    conn_label_side = l_s;
                    conn_circle_side = c_s;
                    arrow_side = a_s;
                }

                function sideStatements(top_s, mid_top_s, mid_s, mid_bottom_s, bottom_s) {
                    var statement = [];
                    if (is_top) {
                        statement = top_s;
                    } else if (is_mid_top) {
                        statement = mid_top_s;
                    } else if (is_mid) {
                        statement = mid_s;
                    } else if (is_mid_bottom) {
                        statement = mid_bottom_s;
                    } else {
                        //bottom
                        statement = bottom_s;
                    }
                    if (!statement) {
                        return;
                    } else {
                        setArrowData(statement[0], statement[1], statement[2]);
                    }
                }

                if (is_center) {
                    if (is_top) {
                        setArrowData('bottom', 'top', 'top');
                    } else if (is_bottom) {
                        setArrowData('top', 'bottom', 'bottom');
                    } else {
                        return;
                    }
                } else if (is_left) {
                    sideStatements(['right', 'top', 'top'], //top
                    ['bottom', 'left', 'bottom'], //mid_top
                    ['right', 'left', 'top'], //mid
                    ['top', 'left', 'top'], //mid_bot
                    ['right', 'bottom', 'bottom'] //bot
                    );
                } else {
                    //right
                    sideStatements(['left', 'top', 'top'], //top
                    ['bottom', 'right', 'bottom'], //mid_top
                    ['left', 'right', 'top'], //mid
                    ['top', 'right', 'top'], //mid_bot
                    ['left', 'bottom', 'bottom'] //bot
                    );
                }

                var label_conn_coordinates = label_data.conn[conn_label_side];
                var circle_conn_coordinates = shape_data.conn[conn_circle_side];
                var by_top_side = arrow_side == 'top' ? true : false;
                that.renderArrow({
                    x_from: label_conn_coordinates.x,
                    y_from: label_conn_coordinates.y,
                    x_to: circle_conn_coordinates.x,
                    y_to: circle_conn_coordinates.y,
                    by_top_side: by_top_side
                });
            };

            that.clear = function () {
                that.ctx.clearRect(0, 0, 3000, 2000);
            };

            return this;
        });
    },

    set: function set(val) {
        this.each(function () {
            this.enjoyhint_obj.setValue(val);
        });
        return this;
    },

    show: function show() {
        this.each(function () {
            this.enjoyhint_obj.show();
        });
        return this;
    },

    hide: function hide() {
        this.each(function () {
            this.enjoyhint_obj.hide();
        });
        return this;
    },

    hide_next: function hide_next() {
        this.each(function () {
            this.enjoyhint_obj.hideNextBtn();
        });
        return this;
    },

    show_next: function show_next() {
        this.each(function () {
            this.enjoyhint_obj.showNextBtn();
        });
        return this;
    },

    hide_skip: function hide_skip() {
        this.each(function () {
            this.enjoyhint_obj.hideSkipBtn();
        });
        return this;
    },

    show_skip: function show_skip() {
        this.each(function () {
            this.enjoyhint_obj.showSkipBtn();
        });
        return this;
    },

    render_circle: function render_circle(x, y, r) {
        this.each(function () {
            this.enjoyhint_obj.renderCircle(x, y, r);
        });
        return this;
    },

    render_label: function render_label(x, y, r) {
        this.each(function () {
            this.enjoyhint_obj.renderLabel(x, y, r);
        });
        return this;
    },

    render_label_with_shape: function render_label_with_shape(data) {
        this.each(function () {
            this.enjoyhint_obj.renderLabelWithShape(data);
        });
        return this;
    },

    clear: function clear() {
        this.each(function () {
            this.enjoyhint_obj.clear();
        });
        return this;
    },

    close: function close(val) {
        this.each(function () {
            this.enjoyhint_obj.closePopdown();
        });
        return this;
    }
};

$.fn.enjoyhint = function (method) {
    //console.log(method);
    if (methods[method]) {
        return methods[method].apply(this, Array.prototype.slice.call(arguments, 1));
    } else if ((typeof method === 'undefined' ? 'undefined' : _typeof(method)) === 'object' || !method) {
        return methods.init.apply(this, arguments);
    } else {
        $.error('Method ' + method + ' does not exist on $.numinput');
    }
    return this;
};

/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/*	
 * jQuery mmenu v4.2.2
 * @requires jQuery 1.7.0 or later
 *
 * mmenu.frebsite.nl
 *	
 * Copyright (c) Fred Heusschen
 * www.frebsite.nl
 *
 * Dual licensed under the MIT and GPL licenses.
 * http://en.wikipedia.org/wiki/MIT_License
 * http://en.wikipedia.org/wiki/GNU_General_Public_License
 */
!function (e) {
  function t(t, n, s) {
    if (s) {
      if ("object" != (typeof t === "undefined" ? "undefined" : _typeof(t)) && (t = {}), "boolean" != typeof t.isMenu) {
        var o = s.children();t.isMenu = 1 == o.length && o.is(n.panelNodetype);
      }return t;
    }return t = e.extend(!0, {}, e[a].defaults, t), ("top" == t.position || "bottom" == t.position) && ("back" == t.zposition || "next" == t.zposition) && (e[a].deprecated('Using position "' + t.position + '" in combination with zposition "' + t.zposition + '"', 'zposition "front"'), t.zposition = "front"), t;
  }function n(t) {
    return t = e.extend(!0, {}, e[a].configuration, t), "string" != typeof t.pageSelector && (t.pageSelector = "> " + t.pageNodetype), t;
  }function s() {
    r.$wndw = e(window), r.$html = e("html"), r.$body = e("body"), r.$allMenus = e(), e.each([d, c, u], function (e, t) {
      t.add = function (e) {
        e = e.split(" ");for (var n in e) {
          t[e[n]] = t.mm(e[n]);
        }
      };
    }), d.mm = function (e) {
      return "mm-" + e;
    }, d.add("menu ismenu panel list subtitle selected label spacer current highest hidden page blocker modal background opened opening subopened subopen fullsubopen subclose"), d.umm = function (e) {
      return "mm-" == e.slice(0, 3) && (e = e.slice(3)), e;
    }, c.mm = function (e) {
      return "mm-" + e;
    }, c.add("parent style"), u.mm = function (e) {
      return e + ".mm";
    }, u.add("toggle open opening opened close closing closed update setPage setSelected transitionend webkitTransitionEnd mousedown touchstart mouseup touchend scroll touchmove click keydown keyup resize"), r.$wndw.on(u.keydown, function (e) {
      return r.$html.hasClass(d.opened) && 9 == e.keyCode ? (e.preventDefault(), !1) : void 0;
    });var t = 0;r.$wndw.on(u.resize, function (e, n) {
      if (n || r.$html.hasClass(d.opened)) {
        var s = r.$wndw.height();(n || s != t) && (t = s, r.$page.css("minHeight", s));
      }
    }), e[a]._c = d, e[a]._d = c, e[a]._e = u, e[a].glbl = r;
  }function o(t, n) {
    if (t.hasClass(d.current)) return !1;var s = e("." + d.panel, n),
        o = s.filter("." + d.current);return s.removeClass(d.highest).removeClass(d.current).not(t).not(o).addClass(d.hidden), t.hasClass(d.opened) ? o.addClass(d.highest).removeClass(d.opened).removeClass(d.subopened) : (t.addClass(d.highest), o.addClass(d.subopened)), t.removeClass(d.hidden).removeClass(d.subopened).addClass(d.current).addClass(d.opened), "open";
  }function i(e, t, n) {
    var s = !1,
        o = function o() {
      s || t.call(e[0]), s = !0;
    };e.one(u.transitionend, o), e.one(u.webkitTransitionEnd, o), setTimeout(o, 1.1 * n);
  }var a = "mmenu",
      l = "4.2.2";if (!e[a]) {
    var r = { $wndw: null, $html: null, $body: null, $page: null, $blck: null, $allMenus: null },
        d = {},
        c = {},
        u = {},
        p = 0,
        h = 0;e[a] = function (e, t, n) {
      return r.$allMenus = r.$allMenus.add(e), this.$menu = e, this.opts = t, this.conf = n, this.serialnr = p++, this._init(), this;
    }, e[a].prototype = { open: function open() {
        var e = this;return this._openSetup(), setTimeout(function () {
          e._openFinish();
        }, 50), "open";
      }, _openSetup: function _openSetup() {
        h = r.$wndw.scrollTop(), this.$menu.addClass(d.current), r.$allMenus.not(this.$menu).trigger(u.close), r.$page.data(c.style, r.$page.attr("style") || ""), r.$wndw.trigger(u.resize, [!0]), this.opts.modal && r.$html.addClass(d.modal), this.opts.moveBackground && r.$html.addClass(d.background), "left" != this.opts.position && r.$html.addClass(d.mm(this.opts.position)), "back" != this.opts.zposition && r.$html.addClass(d.mm(this.opts.zposition)), this.opts.classes && r.$html.addClass(this.opts.classes), r.$html.addClass(d.opened), this.$menu.addClass(d.opened);
      }, _openFinish: function _openFinish() {
        var e = this;i(r.$page, function () {
          e.$menu.trigger(u.opened);
        }, this.conf.transitionDuration), r.$html.addClass(d.opening), this.$menu.trigger(u.opening);
      }, close: function close() {
        var e = this;return i(r.$page, function () {
          e.$menu.removeClass(d.current).removeClass(d.opened), r.$html.removeClass(d.opened).removeClass(d.modal).removeClass(d.background).removeClass(d.mm(e.opts.position)).removeClass(d.mm(e.opts.zposition)), e.opts.classes && r.$html.removeClass(e.opts.classes), r.$page.attr("style", r.$page.data(c.style)), e.$menu.trigger(u.closed);
        }, this.conf.transitionDuration), r.$html.removeClass(d.opening), this.$menu.trigger(u.closing), "close";
      }, _init: function _init() {
        if (this.opts = t(this.opts, this.conf, this.$menu), this.direction = this.opts.slidingSubmenus ? "horizontal" : "vertical", this._initPage(r.$page), this._initMenu(), this._initBlocker(), this._initPanles(), this._initLinks(), this._initOpenClose(), this._bindCustomEvents(), e[a].addons) for (var n = 0; n < e[a].addons.length; n++) {
          "function" == typeof this["_addon_" + e[a].addons[n]] && this["_addon_" + e[a].addons[n]]();
        }
      }, _bindCustomEvents: function _bindCustomEvents() {
        var t = this;this.$menu.off(u.open + " " + u.close + " " + u.setPage + " " + u.update).on(u.open + " " + u.close + " " + u.setPage + " " + u.update, function (e) {
          e.stopPropagation();
        }), this.$menu.on(u.open, function (n) {
          return e(this).hasClass(d.current) ? (n.stopImmediatePropagation(), !1) : t.open();
        }).on(u.close, function (n) {
          return e(this).hasClass(d.current) ? t.close() : (n.stopImmediatePropagation(), !1);
        }).on(u.setPage, function (e, n) {
          t._initPage(n), t._initOpenClose();
        });var n = this.$menu.find(this.opts.isMenu && "horizontal" != this.direction ? "ul, ol" : "." + d.panel);n.off(u.toggle + " " + u.open + " " + u.close).on(u.toggle + " " + u.open + " " + u.close, function (e) {
          e.stopPropagation();
        }), "horizontal" == this.direction ? n.on(u.open, function () {
          return o(e(this), t.$menu);
        }) : n.on(u.toggle, function () {
          var t = e(this);return t.triggerHandler(t.parent().hasClass(d.opened) ? u.close : u.open);
        }).on(u.open, function () {
          return e(this).parent().addClass(d.opened), "open";
        }).on(u.close, function () {
          return e(this).parent().removeClass(d.opened), "close";
        });
      }, _initBlocker: function _initBlocker() {
        var t = this;r.$blck || (r.$blck = e('<div id="' + d.blocker + '" />').appendTo(r.$body)), r.$blck.off(u.touchstart).on(u.touchstart, function (e) {
          e.preventDefault(), e.stopPropagation(), r.$blck.trigger(u.mousedown);
        }).on(u.mousedown, function (e) {
          e.preventDefault(), r.$html.hasClass(d.modal) || t.$menu.trigger(u.close);
        });
      }, _initPage: function _initPage(t) {
        t || (t = e(this.conf.pageSelector, r.$body), t.length > 1 && (e[a].debug("Multiple nodes found for the page-node, all nodes are wrapped in one <" + this.conf.pageNodetype + ">."), t = t.wrapAll("<" + this.conf.pageNodetype + " />").parent())), t.addClass(d.page), r.$page = t;
      }, _initMenu: function _initMenu() {
        this.conf.clone && (this.$menu = this.$menu.clone(!0), this.$menu.add(this.$menu.find("*")).filter("[id]").each(function () {
          e(this).attr("id", d.mm(e(this).attr("id")));
        })), this.$menu.contents().each(function () {
          3 == e(this)[0].nodeType && e(this).remove();
        }), this.$menu.prependTo("body").addClass(d.menu), this.$menu.addClass(d.mm(this.direction)), this.opts.classes && this.$menu.addClass(this.opts.classes), this.opts.isMenu && this.$menu.addClass(d.ismenu), "left" != this.opts.position && this.$menu.addClass(d.mm(this.opts.position)), "back" != this.opts.zposition && this.$menu.addClass(d.mm(this.opts.zposition));
      }, _initPanles: function _initPanles() {
        var t = this;this.__refactorClass(e("." + this.conf.listClass, this.$menu), "list"), this.opts.isMenu && e("ul, ol", this.$menu).not(".mm-nolist").addClass(d.list);var n = e("." + d.list + " > li", this.$menu);this.__refactorClass(n.filter("." + this.conf.selectedClass), "selected"), this.__refactorClass(n.filter("." + this.conf.labelClass), "label"), this.__refactorClass(n.filter("." + this.conf.spacerClass), "spacer"), n.off(u.setSelected).on(u.setSelected, function (t, s) {
          t.stopPropagation(), n.removeClass(d.selected), "boolean" != typeof s && (s = !0), s && e(this).addClass(d.selected);
        }), this.__refactorClass(e("." + this.conf.panelClass, this.$menu), "panel"), this.$menu.children().filter(this.conf.panelNodetype).add(this.$menu.find("." + d.list).children().children().filter(this.conf.panelNodetype)).addClass(d.panel);var s = e("." + d.panel, this.$menu);s.each(function (n) {
          var s = e(this),
              o = s.attr("id") || d.mm("m" + t.serialnr + "-p" + n);s.attr("id", o);
        }), s.find("." + d.panel).each(function () {
          var n = e(this),
              s = n.is("ul, ol") ? n : n.find("ul ,ol").first(),
              o = n.parent(),
              i = o.find("> a, > span"),
              a = o.closest("." + d.panel);if (n.data(c.parent, o), o.parent().is("." + d.list)) {
            var l = e('<a class="' + d.subopen + '" href="#' + n.attr("id") + '" />').insertBefore(i);i.is("a") || l.addClass(d.fullsubopen), "horizontal" == t.direction && s.prepend('<li class="' + d.subtitle + '"><a class="' + d.subclose + '" href="#' + a.attr("id") + '">' + i.text() + "</a></li>");
          }
        });var o = "horizontal" == this.direction ? u.open : u.toggle;if (s.each(function () {
          var n = e(this),
              s = n.attr("id");e('a[href="#' + s + '"]', t.$menu).off(u.click).on(u.click, function (e) {
            e.preventDefault(), n.trigger(o);
          });
        }), "horizontal" == this.direction) {
          var i = e("." + d.list + " > li." + d.selected, this.$menu);i.add(i.parents("li")).parents("li").removeClass(d.selected).end().each(function () {
            var t = e(this),
                n = t.find("> ." + d.panel);n.length && (t.parents("." + d.panel).addClass(d.subopened), n.addClass(d.opened));
          }).closest("." + d.panel).addClass(d.opened).parents("." + d.panel).addClass(d.subopened);
        } else e("li." + d.selected, this.$menu).addClass(d.opened).parents("." + d.selected).removeClass(d.selected);var a = s.filter("." + d.opened);a.length || (a = s.first()), a.addClass(d.opened).last().addClass(d.current), "horizontal" == this.direction && s.find("." + d.panel).appendTo(this.$menu);
      }, _initLinks: function _initLinks() {
        var t = this;e("." + d.list + " > li > a", this.$menu).not("." + d.subopen).not("." + d.subclose).not('[rel="external"]').not('[target="_blank"]').off(u.click).on(u.click, function (n) {
          var s = e(this),
              o = s.attr("href");t.__valueOrFn(t.opts.onClick.setSelected, s) && s.parent().trigger(u.setSelected);var i = t.__valueOrFn(t.opts.onClick.preventDefault, s, "#" == o.slice(0, 1));i && n.preventDefault(), t.__valueOrFn(t.opts.onClick.blockUI, s, !i) && r.$html.addClass(d.blocking), t.__valueOrFn(t.opts.onClick.close, s, i) && t.$menu.triggerHandler(u.close);
        });
      }, _initOpenClose: function _initOpenClose() {
        var t = this,
            n = this.$menu.attr("id");n && n.length && (this.conf.clone && (n = d.umm(n)), e('a[href="#' + n + '"]').off(u.click).on(u.click, function (e) {
          e.preventDefault(), t.$menu.trigger(u.open);
        }));var n = r.$page.attr("id");n && n.length && e('a[href="#' + n + '"]').off(u.click).on(u.click, function (e) {
          e.preventDefault(), t.$menu.trigger(u.close);
        });
      }, __valueOrFn: function __valueOrFn(e, t, n) {
        return "function" == typeof e ? e.call(t[0]) : "undefined" == typeof e && "undefined" != typeof n ? n : e;
      }, __refactorClass: function __refactorClass(e, t) {
        e.removeClass(this.conf[t + "Class"]).addClass(d[t]);
      } }, e.fn[a] = function (o, i) {
      return r.$wndw || s(), o = t(o, i), i = n(i), this.each(function () {
        var t = e(this);t.data(a) || t.data(a, new e[a](t, o, i));
      });
    }, e[a].version = l, e[a].defaults = { position: "left", zposition: "back", moveBackground: !0, slidingSubmenus: !0, modal: !1, classes: "", onClick: { setSelected: !0 } }, e[a].configuration = { preventTabbing: !0, panelClass: "Panel", listClass: "List", selectedClass: "Selected", labelClass: "Label", spacerClass: "Spacer", pageNodetype: "div", panelNodetype: "ul, ol, div", transitionDuration: 400 }, function () {
      var t = window.document,
          n = window.navigator.userAgent,
          s = (document.createElement("div").style, "ontouchstart" in t),
          o = "WebkitOverflowScrolling" in t.documentElement.style,
          i = function () {
        return n.indexOf("Android") >= 0 ? 2.4 > parseFloat(n.slice(n.indexOf("Android") + 8)) : !1;
      }();e[a].support = { touch: s, oldAndroidBrowser: i, overflowscrolling: function () {
          return s ? o ? !0 : i ? !1 : !0 : !0;
        }() };
    }(), e[a].debug = function () {}, e[a].deprecated = function (e, t) {
      "undefined" != typeof console && "undefined" != typeof console.warn && console.warn("MMENU: " + e + " is deprecated, use " + t + " instead.");
    };
  }
}(jQuery);
/*	
 * jQuery mmenu counters addon
 * @requires mmenu 4.0.0 or later
 *
 * mmenu.frebsite.nl
 *	
 * Copyright (c) Fred Heusschen
 * www.frebsite.nl
 *
 * Dual licensed under the MIT and GPL licenses.
 * http://en.wikipedia.org/wiki/MIT_License
 * http://en.wikipedia.org/wiki/GNU_General_Public_License
 */
!function (t) {
  var e = "mmenu",
      n = "counters";t[e].prototype["_addon_" + n] = function () {
    var o = this,
        u = this.opts[n],
        a = t[e]._c,
        r = t[e]._d,
        d = t[e]._e;a.add("counter noresults"), d.add("updatecounters"), "boolean" == typeof u && (u = { add: u, update: u }), "object" != (typeof u === "undefined" ? "undefined" : _typeof(u)) && (u = {}), u = t.extend(!0, {}, t[e].defaults[n], u), u.count && (t[e].deprecated('the option "count" for counters, the option "update"'), u.update = u.count), this.__refactorClass(t("em." + this.conf.counterClass, this.$menu), "counter");var s = t("." + a.panel, this.$menu);if (u.add && s.each(function () {
      var e = t(this),
          n = e.data(r.parent);if (n) {
        var o = t('<em class="' + a.counter + '" />'),
            u = n.find("> a." + a.subopen);u.parent().find("em." + a.counter).length || u.before(o);
      }
    }), u.update) {
      var c = t("em." + a.counter, this.$menu);c.off(d.updatecounters).on(d.updatecounters, function (t) {
        t.stopPropagation();
      }).each(function () {
        var e = t(this),
            n = t(e.next().attr("href"), o.$menu);n.is("." + a.list) || (n = n.find("> ." + a.list)), n.length && e.on(d.updatecounters, function () {
          var t = n.children().not("." + a.label).not("." + a.subtitle).not("." + a.hidden).not("." + a.noresults);e.html(t.length);
        });
      }).trigger(d.updatecounters), this.$menu.on(d.update, function () {
        c.trigger(d.updatecounters);
      });
    }
  }, t[e].defaults[n] = { add: !1, update: !1 }, t[e].configuration.counterClass = "Counter", t[e].addons = t[e].addons || [], t[e].addons.push(n);
}(jQuery);
/*	
 * jQuery mmenu dragOpen addon
 * @requires mmenu 4.0.0 or later
 *
 * mmenu.frebsite.nl
 *	
 * Copyright (c) Fred Heusschen
 * www.frebsite.nl
 *
 * Dual licensed under the MIT and GPL licenses.
 * http://en.wikipedia.org/wiki/MIT_License
 * http://en.wikipedia.org/wiki/GNU_General_Public_License
 */
!function (e) {
  function t(e, t, a) {
    return t > e && (e = t), e > a && (e = a), e;
  }var a = "mmenu",
      o = "dragOpen";e[a].prototype["_addon_" + o] = function () {
    var n = this,
        r = this.opts[o];if (e.fn.hammer) {
      var i = e[a]._c,
          s = (e[a]._d, e[a]._e);i.add("dragging"), s.add("dragleft dragright dragup dragdown dragend");var d = e[a].glbl;if ("boolean" == typeof r && (r = { open: r }), "object" != (typeof r === "undefined" ? "undefined" : _typeof(r)) && (r = {}), "number" != typeof r.maxStartPos && (r.maxStartPos = "left" == this.opts.position || "right" == this.opts.position ? 150 : 75), r = e.extend(!0, {}, e[a].defaults[o], r), r.open) {
        var p = 0,
            g = !1,
            c = 0,
            h = 0,
            l = "width";switch (this.opts.position) {case "left":case "right":
            l = "width";break;default:
            l = "height";}switch (this.opts.position) {case "left":
            var f = { events: s.dragleft + " " + s.dragright, open_dir: "right", close_dir: "left", delta: "deltaX", page: "pageX", negative: !1 };break;case "right":
            var f = { events: s.dragleft + " " + s.dragright, open_dir: "left", close_dir: "right", delta: "deltaX", page: "pageX", negative: !0 };break;case "top":
            var f = { events: s.dragup + " " + s.dragdown, open_dir: "down", close_dir: "up", delta: "deltaY", page: "pageY", negative: !1 };break;case "bottom":
            var f = { events: s.dragup + " " + s.dragdown, open_dir: "up", close_dir: "down", delta: "deltaY", page: "pageY", negative: !0 };}var u = this.__valueOrFn(r.pageNode, this.$menu, d.$page);"string" == typeof u && (u = e(u));var m = d.$page.find("." + i.mm("fixed-top") + ", ." + i.mm("fixed-bottom")),
            v = d.$page;switch (n.opts.zposition) {case "back":
            v = v.add(m);break;case "front":
            v = n.$menu;break;case "next":
            v = v.add(n.$menu).add(m);}u.hammer().on(s.touchstart + " " + s.mousedown, function (e) {
          if ("touchstart" == e.type) var t = e.originalEvent.touches[0] || e.originalEvent.changedTouches[0],
              a = t[f.page];else if ("mousedown" == e.type) var a = e[f.page];switch (n.opts.position) {case "right":case "bottom":
              a >= d.$wndw[l]() - r.maxStartPos && (p = 1);break;default:
              a <= r.maxStartPos && (p = 1);}
        }).on(f.events + " " + s.dragend, function (e) {
          p > 0 && (e.gesture.preventDefault(), e.stopPropagation());
        }).on(f.events, function (e) {
          var a = f.negative ? -e.gesture[f.delta] : e.gesture[f.delta];if (g = a > c ? f.open_dir : f.close_dir, c = a, c > r.threshold && 1 == p) {
            if (d.$html.hasClass(i.opened)) return;p = 2, n._openSetup(), d.$html.addClass(i.dragging), h = t(d.$wndw[l]() * n.conf[o][l].perc, n.conf[o][l].min, n.conf[o][l].max);
          }2 == p && v.css(n.opts.position, t(c, 10, h) - ("front" == n.opts.zposition ? h : 0));
        }).on(s.dragend, function () {
          2 == p && (d.$html.removeClass(i.dragging), v.css(n.opts.position, ""), g == f.open_dir ? n._openFinish() : n.close()), p = 0;
        });
      }
    }
  }, e[a].defaults[o] = { open: !1, threshold: 50 }, e[a].configuration[o] = { width: { perc: .8, min: 140, max: 440 }, height: { perc: .8, min: 140, max: 880 } }, e[a].addons = e[a].addons || [], e[a].addons.push(o);
}(jQuery);
/*	
 * jQuery mmenu header addon
 * @requires mmenu 4.0.0 or later
 *
 * mmenu.frebsite.nl
 *	
 * Copyright (c) Fred Heusschen
 * www.frebsite.nl
 *
 * Dual licensed under the MIT and GPL licenses.
 * http://en.wikipedia.org/wiki/MIT_License
 * http://en.wikipedia.org/wiki/GNU_General_Public_License
 */
!function (e) {
  var t = "mmenu",
      a = "header";e[t].prototype["_addon_" + a] = function () {
    var n = this,
        r = this.opts[a],
        d = this.conf[a],
        s = e[t]._c,
        i = (e[t]._d, e[t]._e);s.add("header hasheader prev next title titletext"), i.add("updateheader");var o = e[t].glbl;if ("boolean" == typeof r && (r = { add: r, update: r }), "object" != (typeof r === "undefined" ? "undefined" : _typeof(r)) && (r = {}), r = e.extend(!0, {}, e[t].defaults[a], r), r.add) {
      var h = r.content ? r.content : '<a class="' + s.prev + '" href="javascript:;"></a><span class="' + s.title + '"></span><a class="' + s.next + '" href="javascript:;"></a>';e('<div class="' + s.header + '" />').prependTo(this.$menu).append(h);
    }var p = e("div." + s.header, this.$menu);if (p.length && this.$menu.addClass(s.hasheader), r.update && p.length) {
      var l = p.find("." + s.title),
          u = p.find("." + s.prev),
          f = p.find("." + s.next),
          c = "#" + o.$page.attr("id");u.add(f).on(i.click, function (t) {
        t.preventDefault(), t.stopPropagation();var a = e(this).attr("href");"#" !== a && (a == c ? n.$menu.trigger(i.close) : e(a, n.$menu).trigger(i.open));
      }), e("." + s.panel, this.$menu).each(function () {
        var t = e(this),
            a = e("." + d.panelHeaderClass, t).text(),
            n = e("." + d.panelPrevClass, t).attr("href"),
            o = e("." + d.panelNextClass, t).attr("href");a || (a = e("." + s.subclose, t).text()), a || (a = r.title), n || (n = e("." + s.subclose, t).attr("href")), t.off(i.updateheader).on(i.updateheader, function (e) {
          e.stopPropagation(), l[a ? "show" : "hide"]().text(a), u[n ? "show" : "hide"]().attr("href", n), f[o ? "show" : "hide"]().attr("href", o);
        }), t.on(i.open, function () {
          e(this).trigger(i.updateheader);
        });
      }).filter("." + s.current).trigger(i.updateheader);
    }
  }, e[t].defaults[a] = { add: !1, content: !1, update: !1, title: "Menu" }, e[t].configuration[a] = { panelHeaderClass: "Header", panelNextClass: "Next", panelPrevClass: "Prev" }, e[t].addons = e[t].addons || [], e[t].addons.push(a);
}(jQuery);
/*	
 * jQuery mmenu labels addon
 * @requires mmenu 4.1.0 or later
 *
 * mmenu.frebsite.nl
 *	
 * Copyright (c) Fred Heusschen
 * www.frebsite.nl
 *
 * Dual licensed under the MIT and GPL licenses.
 * http://en.wikipedia.org/wiki/MIT_License
 * http://en.wikipedia.org/wiki/GNU_General_Public_License
 */
!function (e) {
  var l = "mmenu",
      s = "labels";e[l].prototype["_addon_" + s] = function () {
    function a() {
      var e = t.hassearch && o.$menu.hasClass(t.hassearch),
          l = t.hasheader && o.$menu.hasClass(t.hasheader);return e ? l ? 100 : 50 : l ? 60 : 0;
    }var o = this,
        n = this.opts[s],
        t = e[l]._c,
        i = (e[l]._d, e[l]._e);if (t.add("collapsed"), t.add("fixedlabels original clone"), i.add("updatelabels position scroll"), e[l].support.touch && (i.scroll += " " + i.mm("touchmove")), "boolean" == typeof n && (n = { collapse: n }), "object" != (typeof n === "undefined" ? "undefined" : _typeof(n)) && (n = {}), n = e.extend(!0, {}, e[l].defaults[s], n), n.collapse) {
      this.__refactorClass(e("li." + this.conf.collapsedClass, this.$menu), "collapsed");var d = e("." + t.label, this.$menu);d.each(function () {
        var l = e(this),
            s = l.nextUntil("." + t.label, "all" == n.collapse ? null : "." + t.collapsed);"all" == n.collapse && (l.addClass(t.opened), s.removeClass(t.collapsed)), s.length && (l.wrapInner("<span />"), e('<a href="javascript:;" class="' + t.subopen + " " + t.fullsubopen + '" />').prependTo(l).on(i.click, function (e) {
          e.preventDefault(), l.toggleClass(t.opened), s[l.hasClass(t.opened) ? "removeClass" : "addClass"](t.collapsed);
        }));
      });
    } else if (n.fixed) {
      if ("horizontal" != this.direction) return;this.$menu.addClass(t.fixedlabels);var r = e("." + t.panel, this.$menu),
          d = e("." + t.label, this.$menu);r.add(d).off(i.updatelabels + " " + i.position + " " + i.scroll).on(i.updatelabels + " " + i.position + " " + i.scroll, function (e) {
        e.stopPropagation();
      });var p = a();r.each(function () {
        var l = e(this),
            s = l.find("." + t.label);if (s.length) {
          var o = l.scrollTop();s.each(function () {
            var s = e(this);s.wrapInner("<div />").wrapInner("<div />");var a,
                n,
                d,
                r = s.find("> div"),
                c = e();s.on(i.updatelabels, function () {
              o = l.scrollTop(), s.hasClass(t.hidden) || (c = s.nextAll("." + t.label).not("." + t.hidden).first(), a = s.offset().top + o, n = c.length ? c.offset().top + o : !1, d = r.height(), s.trigger(i.position));
            }), s.on(i.position, function () {
              var e = 0;n && o + p > n - d ? e = n - a - d : o + p > a && (e = o - a + p), r.css("top", e);
            });
          }), l.on(i.updatelabels, function () {
            o = l.scrollTop(), p = a(), s.trigger(i.position);
          }).on(i.scroll, function () {
            s.trigger(i.updatelabels);
          });
        }
      }), this.$menu.on(i.update, function () {
        r.trigger(i.updatelabels);
      }).on(i.opening, function () {
        r.trigger(i.updatelabels).trigger(i.scroll);
      });
    }
  }, e[l].defaults[s] = { fixed: !1, collapse: !1 }, e[l].configuration.collapsedClass = "Collapsed", e[l].addons = e[l].addons || [], e[l].addons.push(s);
}(jQuery);
/*	
 * jQuery mmenu searchfield addon
 * @requires mmenu 4.0.0 or later
 *
 * mmenu.frebsite.nl
 *	
 * Copyright (c) Fred Heusschen
 * www.frebsite.nl
 *
 * Dual licensed under the MIT and GPL licenses.
 * http://en.wikipedia.org/wiki/MIT_License
 * http://en.wikipedia.org/wiki/GNU_General_Public_License
 */
!function (e) {
  function s(e) {
    switch (e) {case 9:case 16:case 17:case 18:case 37:case 38:case 39:case 40:
        return !0;}return !1;
  }var n = "mmenu",
      t = "searchfield";e[n].prototype["_addon_" + t] = function () {
    var a = this,
        r = this.opts[t],
        o = e[n]._c,
        l = e[n]._d,
        d = e[n]._e;if (o.add("search hassearch noresults nosubresults counter"), d.add("search reset change"), "boolean" == typeof r && (r = { add: r, search: r }), "object" != (typeof r === "undefined" ? "undefined" : _typeof(r)) && (r = {}), r = e.extend(!0, {}, e[n].defaults[t], r), r.add && (e('<div class="' + o.search + '" />').prependTo(this.$menu).append('<input placeholder="' + r.placeholder + '" type="text" autocomplete="off" />'), r.noResults && e("ul, ol", this.$menu).first().append('<li class="' + o.noresults + '">' + r.noResults + "</li>")), e("div." + o.search, this.$menu).length && this.$menu.addClass(o.hassearch), r.search) {
      var i = e("div." + o.search, this.$menu).find("input");if (i.length) {
        var u = e("." + o.panel, this.$menu),
            h = e("." + o.list + "> li." + o.label, this.$menu),
            c = e("." + o.list + "> li", this.$menu).not("." + o.subtitle).not("." + o.label).not("." + o.noresults),
            f = "> a";r.showLinksOnly || (f += ", > span"), i.off(d.keyup + " " + d.change).on(d.keyup, function (e) {
          s(e.keyCode) || a.$menu.trigger(d.search);
        }).on(d.change, function () {
          a.$menu.trigger(d.search);
        }), this.$menu.off(d.reset + " " + d.search).on(d.reset + " " + d.search, function (e) {
          e.stopPropagation();
        }).on(d.reset, function () {
          a.$menu.trigger(d.search, [""]);
        }).on(d.search, function (s, n) {
          "string" == typeof n ? i.val(n) : n = i.val(), n = n.toLowerCase(), u.scrollTop(0), c.add(h).addClass(o.hidden), c.each(function () {
            var s = e(this);e(f, s).text().toLowerCase().indexOf(n) > -1 && s.add(s.prevAll("." + o.label).first()).removeClass(o.hidden);
          }), e(u.get().reverse()).each(function () {
            var s = e(this),
                n = s.data(l.parent);if (n) {
              var t = s.add(s.find("> ." + o.list)).find("> li").not("." + o.subtitle).not("." + o.label).not("." + o.hidden);t.length ? n.removeClass(o.hidden).removeClass(o.nosubresults).prevAll("." + o.label).first().removeClass(o.hidden) : (s.hasClass(o.current) && n.trigger(d.open), n.addClass(o.nosubresults));
            }
          }), a.$menu[c.not("." + o.hidden).length ? "removeClass" : "addClass"](o.noresults), a.$menu.trigger(d.update);
        });
      }
    }
  }, e[n].defaults[t] = { add: !1, search: !1, showLinksOnly: !0, placeholder: "Search", noResults: "No results found." }, e[n].addons = e[n].addons || [], e[n].addons.push(t);
}(jQuery);

/***/ }),
/* 248 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (!Element.prototype.matches) {
    Element.prototype.matches = Element.prototype.matchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector || Element.prototype.webkitMatchesSelector || function (s) {
        var matches = (this.document || this.ownerDocument).querySelectorAll(s),
            i = matches.length;
        while (--i >= 0 && matches.item(i) !== this) {}
        return i > -1;
    };
}

/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Client = __webpack_require__(3);
var getLanguage = __webpack_require__(16).get;
var urlForStatic = __webpack_require__(8).urlForStatic;
var Pushwoosh = __webpack_require__(565).Pushwoosh;

var BinaryPushwoosh = function () {
    var pw = new Pushwoosh();

    var initialised = false;

    var init = function init() {
        if (!/^(www|staging)\.binary\.com$/.test(window.location.hostname)) return;

        if (!initialised) {
            pw.push(['init', {
                logLevel: 'error', // or info or debug
                applicationCode: 'D04E6-FA474',
                safariWebsitePushID: 'web.com.binary',
                defaultNotificationTitle: 'Binary.com',
                defaultNotificationImage: 'https://style.binary.com/images/logo/logomark.png'
            }]);
            initialised = true;
            sendTags();
        }
    };

    var sendTags = function sendTags() {
        pw.push(function (api) {
            api.getTags().then(function (result) {
                if (!result.result['Login ID'] || !result.result['Site Language']) {
                    // send login id and site language
                    return api.setTags({
                        'Login ID': Client.get('loginid'),
                        'Site Language': getLanguage()
                    });
                }
                return null;
            }).catch(function (e) {
                return; // do nothing
            });
        });
    };

    return {
        init: init
    };
}();

module.exports = BinaryPushwoosh;

/***/ }),
/* 250 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isVisible = __webpack_require__(4).isVisible;
var Url = __webpack_require__(8);
var createElement = __webpack_require__(1).createElement;

/*
    adds anchor links to elements with data-anchor attribute
    created anchors work similarly to native anchors,
    but rely on URL params instead

    HOW TO USE:
        <h1 data-anchor>Some title</h1>
*/

var ScrollToAnchor = function () {
    var id_occurrence_count = {};

    var init = function init() {
        addAnchorsToElements();
        var target = getAnchorTargetElement();

        // remove query param if loaded onto a page without target element
        if (!target || !isVisible(target)) {
            Url.updateParamsWithoutReload({
                anchor: null
            }, true);
        } else {
            scrollToAnchorInQuery();
        }
    };

    var encode = function encode(str) {
        var encoded = str.trim().toLowerCase().replace(/[^a-z0-9]+/g, '-');
        var appendix = '';
        if (id_occurrence_count[encoded]) {
            appendix = '-' + ++id_occurrence_count[encoded];
        } else {
            id_occurrence_count[encoded] = 1;
        }
        return encodeURI('' + encoded + appendix);
    };

    var makeAnchorLink = function makeAnchorLink(id) {
        var url = new URL(window.location);
        url.search = 'anchor=' + id;

        return createElement('a', {
            class: 'data-anchor-link',
            href: url.href
        });
    };

    var addAnchorsToElements = function addAnchorsToElements() {
        var els = document.querySelectorAll('[data-anchor]');
        els.forEach(function (el) {
            if (el.querySelector('.data-anchor-link')) return;
            var title = el.innerText;
            var id = encode(title);
            el.dataset.anchor = id;
            var anchor_link = makeAnchorLink(id);
            el.appendChild(anchor_link);
            anchor_link.addEventListener('click', function (e) {
                e.preventDefault();
                scrollToEl(el);
                Url.updateParamsWithoutReload({
                    anchor: id
                }, true);
            });
        });
    };

    var scrollToEl = function scrollToEl(el) {
        $.scrollTo(el, 500, { offset: -10 });
    };

    var getAnchorTargetElement = function getAnchorTargetElement() {
        var id = Url.paramsHash().anchor;
        if (!id) return null;
        return document.querySelector('[data-anchor="' + id + '"]');
    };

    var scrollToAnchorInQuery = function scrollToAnchorInQuery() {
        var el = getAnchorTargetElement();
        if (!el) return;
        window.setTimeout(function () {
            scrollToEl(el);
        }, 100);
    };

    var cleanup = function cleanup() {
        id_occurrence_count = {};
    };

    return {
        init: init,
        cleanup: cleanup
    };
}();

module.exports = ScrollToAnchor;

/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var getPropertyValue = __webpack_require__(1).getPropertyValue;
var Client = __webpack_require__(85);
var BinarySocket = __webpack_require__(5);
var Dialog = __webpack_require__(75);

var ThirdPartyLinks = function () {
    var init = function init() {
        if (Client.isLoggedIn()) {
            BinarySocket.wait('authorize').then(function (response) {
                var landing_company_shortcode = getPropertyValue(response, ['authorize', 'landing_company_name']);
                if (landing_company_shortcode === 'maltainvest') {
                    document.body.addEventListener('click', clickHandler);
                }
            });
        }
    };

    var clickHandler = function clickHandler(e) {
        if (!e.target) return;
        var el_link = e.target.closest('a');
        if (!el_link) return;

        var dialog = document.querySelector('#third_party_redirect_dialog');
        if (dialog && dialog.contains(el_link)) return;

        if (isThirdPartyLink(el_link.href)) {
            e.preventDefault();
            Dialog.confirm({
                id: 'third_party_redirect_dialog',
                message: ['You will be redirected to a third-party website which is not owned by Binary.com.', 'Click OK to proceed.']
            }).then(function (should_proceed) {
                if (should_proceed) {
                    var link = window.open();
                    link.opener = null;
                    link.location = el_link.href;
                }
            });
        }
    };

    var isThirdPartyLink = function isThirdPartyLink(href) {
        var destination = void 0;
        try {
            destination = new URL(href);
        } catch (e) {
            return false;
        }
        return !!destination.host && !/^.*\.binary\.com$/.test(destination.host) // destination host is not binary subdomain
        && window.location.host !== destination.host;
    };

    return {
        init: init,
        isThirdPartyLink: isThirdPartyLink
    };
}();

module.exports = ThirdPartyLinks;

/***/ }),
/* 252 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// ==================== _common ====================
var TabSelector = __webpack_require__(95);

// ==================== app ====================
var LoggedInHandler = __webpack_require__(255);
var Redirect = __webpack_require__(259);
var CashierJP = __webpack_require__(265);
var KnowledgeTest = __webpack_require__(266);
var AccountTransfer = __webpack_require__(268);
var Cashier = __webpack_require__(269);
var DepositWithdraw = __webpack_require__(270);
var PaymentAgentList = __webpack_require__(271);
var PaymentAgentWithdraw = __webpack_require__(272);
var Endpoint = __webpack_require__(273);
var MBTradePage = __webpack_require__(276);
var EconomicCalendar = __webpack_require__(279);
var AssetIndexUI = __webpack_require__(278);
var TradingTimesUI = __webpack_require__(281);
var TradePage = __webpack_require__(290);
var Authenticate = __webpack_require__(291);
var ChangePassword = __webpack_require__(292);
var PaymentAgentTransfer = __webpack_require__(293);
var Portfolio = __webpack_require__(128);
var ProfitTable = __webpack_require__(296);
var Settings = __webpack_require__(299);
var APIToken = __webpack_require__(300);
var AuthorisedApps = __webpack_require__(301);
var CashierPassword = __webpack_require__(179);
var FinancialAssessment = __webpack_require__(302);
var IPHistory = __webpack_require__(305);
var Limits = __webpack_require__(308);
var SelfExclusion = __webpack_require__(310);
var TwoFactorAuthentication = __webpack_require__(311);
var PersonalDetails = __webpack_require__(180);
var professionalClient = __webpack_require__(181);
var Statement = __webpack_require__(312);
var TopUpVirtual = __webpack_require__(315);
var Accounts = __webpack_require__(316);
var LostPassword = __webpack_require__(318);
var MetaTrader = __webpack_require__(129);
var FinancialAccOpening = __webpack_require__(320);
var JapanAccOpening = __webpack_require__(321);
var RealAccOpening = __webpack_require__(322);
var VirtualAccOpening = __webpack_require__(323);
var WelcomePage = __webpack_require__(324);
var ResetPassword = __webpack_require__(327);
var SetCurrency = __webpack_require__(328);
var TelegramBot = __webpack_require__(329);
var TNCApproval = __webpack_require__(183);
var VideoFacility = __webpack_require__(331);

// ==================== static ====================
var GetStartedJP = __webpack_require__(333);
var HomeJP = __webpack_require__(334);
var Charity = __webpack_require__(335);
var Contact = __webpack_require__(336);
var GetStarted = __webpack_require__(337);
var Home = __webpack_require__(185);
var JobDetails = __webpack_require__(338);
var Regulation = __webpack_require__(339);
var StaticPages = __webpack_require__(340);
var TermsAndConditions = __webpack_require__(341);
var WhyUs = __webpack_require__(342);

/* eslint-disable max-len */
var pages_config = {
    account_transfer: { module: AccountTransfer, is_authenticated: true, only_real: true, needs_currency: true },
    accounts: { module: Accounts, is_authenticated: true, needs_currency: true },
    api_tokenws: { module: APIToken, is_authenticated: true },
    assessmentws: { module: FinancialAssessment, is_authenticated: true, only_real: true },
    asset_indexws: { module: AssetIndexUI },
    authenticate: { module: Authenticate, is_authenticated: true, only_real: true },
    authorised_appsws: { module: AuthorisedApps, is_authenticated: true },
    cashier: { module: Cashier },
    cashier_passwordws: { module: CashierPassword, is_authenticated: true, only_real: true },
    change_passwordws: { module: ChangePassword, is_authenticated: true },
    two_factor_authentication: { module: TwoFactorAuthentication, is_authenticated: true },
    charity: { module: Charity },
    contact: { module: Contact },
    detailsws: { module: PersonalDetails, is_authenticated: true, needs_currency: true },
    economic_calendar: { module: EconomicCalendar },
    endpoint: { module: Endpoint },
    epg_forwardws: { module: DepositWithdraw, is_authenticated: true, only_real: true },
    forwardws: { module: DepositWithdraw, is_authenticated: true, only_real: true },
    home: { module: Home, not_authenticated: true },
    iphistoryws: { module: IPHistory, is_authenticated: true },
    japanws: { module: JapanAccOpening, is_authenticated: true, only_virtual: true },
    knowledge_testws: { module: KnowledgeTest, is_authenticated: true, only_virtual: true },
    landing_page: { module: StaticPages.LandingPage, is_authenticated: true, only_virtual: true },
    limitsws: { module: Limits, is_authenticated: true, only_real: true, needs_currency: true },
    logged_inws: { module: LoggedInHandler },
    lost_passwordws: { module: LostPassword, not_authenticated: true },
    maltainvestws: { module: FinancialAccOpening, is_authenticated: true },
    market_timesws: { module: TradingTimesUI },
    metatrader: { module: MetaTrader, is_authenticated: true, needs_currency: true },
    multi_barriers_trading: { module: MBTradePage, needs_currency: true },
    payment_agent_listws: { module: PaymentAgentList, is_authenticated: true },
    payment_methods: { module: Cashier.PaymentMethods },
    platforms: { module: TabSelector },
    portfoliows: { module: Portfolio, is_authenticated: true, needs_currency: true },
    profit_tablews: { module: ProfitTable, is_authenticated: true, needs_currency: true },
    professional: { module: professionalClient, is_authenticated: true, only_real: true },
    realws: { module: RealAccOpening, is_authenticated: true },
    redirect: { module: Redirect },
    regulation: { module: Regulation },
    reset_passwordws: { module: ResetPassword, not_authenticated: true },
    securityws: { module: Settings, is_authenticated: true },
    self_exclusionws: { module: SelfExclusion, is_authenticated: true, only_real: true },
    settingsws: { module: Settings, is_authenticated: true },
    signup: { module: TabSelector },
    statementws: { module: Statement, is_authenticated: true, needs_currency: true },
    tnc_approvalws: { module: TNCApproval, is_authenticated: true, only_real: true },
    top_up_virtualws: { module: TopUpVirtual, is_authenticated: true, only_virtual: true },
    trading: { module: TradePage, needs_currency: true },
    transferws: { module: PaymentAgentTransfer, is_authenticated: true, only_real: true },
    virtualws: { module: VirtualAccOpening, not_authenticated: true },
    welcome: { module: WelcomePage, is_authenticated: true, only_virtual: true },
    withdrawws: { module: PaymentAgentWithdraw, is_authenticated: true, only_real: true },
    'binary-options': { module: GetStarted.BinaryOptions },
    'careers': { module: StaticPages.Careers },
    'cfds': { module: GetStarted.CFDs },
    'contract-specifications': { module: TabSelector },
    'cryptocurrencies': { module: GetStarted.Cryptocurrencies },
    'deposit-jp': { module: CashierJP.Deposit, is_authenticated: true, only_real: true },
    'faq': { module: StaticPages.AffiliatesFAQ },
    'forex': { module: GetStarted.Forex },
    'get-started': { module: TabSelector },
    'get-started-jp': { module: GetStartedJP },
    'home-jp': { module: HomeJP, not_authenticated: true },
    'how-to-trade-mt5': { module: TabSelector },
    'ib-faq': { module: StaticPages.IBProgrammeFAQ },
    'ib-signup': { module: TabSelector },
    'job-details': { module: JobDetails },
    'metals': { module: GetStarted.Metals },
    'open-positions': { module: StaticPages.OpenPositions },
    'open-source-projects': { module: StaticPages.OpenSourceProjects },
    'payment-agent': { module: StaticPages.PaymentAgent },
    'set-currency': { module: SetCurrency, is_authenticated: true, only_real: true, needs_currency: true },
    'terms-and-conditions': { module: TermsAndConditions },
    'terms-and-conditions-jp': { module: TermsAndConditions },
    'types-of-accounts': { module: StaticPages.TypesOfAccounts },
    'video-facility': { module: VideoFacility, is_authenticated: true, only_real: true },
    'why-us': { module: WhyUs },
    'why-us-jp': { module: WhyUs },
    'withdraw-jp': { module: CashierJP.Withdraw, is_authenticated: true, only_real: true },
    'telegram-bot': { module: TelegramBot, is_authenticated: true }
};
/* eslint-enable max-len */

module.exports = pages_config;

/***/ }),
/* 253 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Client = __webpack_require__(3);
var getElementById = __webpack_require__(4).getElementById;

var Contents = function () {
    var onLoad = function onLoad() {
        Client.activateByClientType();
        // This is required for our css to work.
        getElementById('content').className = getElementById('content_class').textContent;
    };

    return {
        onLoad: onLoad
    };
}();

module.exports = Contents;

/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Footer = function () {
    var clearNotification = function clearNotification() {
        var $status_notification = $('#status_notification');
        $status_notification.slideUp(200);
    };

    var displayNotification = function displayNotification(message) {
        var $status_notification = $('#status_notification');
        var $status_message_text = $('#status_notification_text');
        var $close_icon = $('#status_notification_close');

        $status_notification.css('display', 'flex');
        $status_message_text.html(message);

        $close_icon.off('click').on('click', function () {
            $status_notification.slideUp(200);
        });
    };

    return {
        clearNotification: clearNotification,
        displayNotification: displayNotification
    };
}();

module.exports = Footer;

/***/ }),
/* 255 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Cookies = __webpack_require__(50);
var moment = __webpack_require__(9);
var Client = __webpack_require__(3);
var BinarySocket = __webpack_require__(5);
var GTM = __webpack_require__(54);
var SocketCache = __webpack_require__(74);
var getElementById = __webpack_require__(4).getElementById;
var getLanguage = __webpack_require__(16).get;
var urlLang = __webpack_require__(16).urlLang;
var isStorageSupported = __webpack_require__(6).isStorageSupported;
var removeCookies = __webpack_require__(6).removeCookies;
var paramsHash = __webpack_require__(8).paramsHash;
var urlFor = __webpack_require__(8).urlFor;
var getPropertyValue = __webpack_require__(1).getPropertyValue;

var LoggedInHandler = function () {
    var onLoad = function onLoad() {
        SocketCache.clear();
        parent.window.is_logging_in = 1; // this flag is used in base.js to prevent auto-reloading this page
        var redirect_url = void 0;
        var params = paramsHash(window.location.href);
        BinarySocket.send({ authorize: params.token1 }).then(function (response) {
            var account_list = getPropertyValue(response, ['authorize', 'account_list']);
            if (isStorageSupported(localStorage) && isStorageSupported(sessionStorage) && account_list) {
                storeClientAccounts(account_list);
                // redirect url
                redirect_url = sessionStorage.getItem('redirect_url');
                sessionStorage.removeItem('redirect_url');
            } else {
                Client.doLogout({ logout: 1 });
            }

            // redirect back
            var set_default = true;
            if (redirect_url) {
                var do_not_redirect = ['reset_passwordws', 'lost_passwordws', 'change_passwordws', 'home', 'home-jp', '404'];
                var reg = new RegExp(do_not_redirect.join('|'), 'i');
                if (!reg.test(redirect_url) && urlFor('') !== redirect_url) {
                    set_default = false;
                }
            }
            if (set_default) {
                var lang_cookie = urlLang(redirect_url) || Cookies.get('language');
                var language = getLanguage();
                redirect_url = Client.defaultRedirectUrl();
                if (lang_cookie && lang_cookie !== language) {
                    redirect_url = redirect_url.replace(new RegExp('/' + language + '/', 'i'), '/' + lang_cookie.toLowerCase() + '/');
                }
            }
            getElementById('loading_link').setAttribute('href', redirect_url);
            window.location.href = redirect_url; // need to redirect not using pjax
        });
    };

    // store consistent names with other API calls
    // API_V4: send consistent names
    var map_names = {
        country: 'residence',
        landing_company_name: 'landing_company_shortcode'
    };

    var storeClientAccounts = function storeClientAccounts(account_list) {
        // Parse url for loginids, tokens, and currencies returned by OAuth
        var params = paramsHash(window.location.href);

        // Clear all accounts before entering the loop
        Client.clearAllAccounts();

        account_list.forEach(function (account) {
            Object.keys(account).forEach(function (param) {
                if (param === 'loginid') {
                    if (!Client.get('loginid') && !account.is_virtual && !account.is_disabled) {
                        Client.set(param, account[param]);
                    }
                } else {
                    var param_to_set = map_names[param] || param;
                    var value_to_set = typeof account[param] === 'undefined' ? '' : account[param];
                    Client.set(param_to_set, value_to_set, account.loginid);
                }
            });
        });

        var i = 1;
        while (params['acct' + i]) {
            var loginid = params['acct' + i];
            var token = params['token' + i];
            if (loginid && token) {
                Client.set('token', token, loginid);
            }
            i++;
        }

        // if didn't find any login ID that matched the above condition
        // or the selected one doesn't have a token, set the first one
        if (!Client.get('loginid') || !Client.get('token')) {
            Client.set('loginid', params.acct1 || account_list[0].loginid);
        }

        if (Client.isLoggedIn()) {
            GTM.setLoginFlag();
            Client.set('session_start', parseInt(moment().valueOf() / 1000));
            // Remove cookies that were set by the old code
            removeCookies('email', 'login', 'loginid', 'loginid_list', 'residence');
        }
    };

    return {
        onLoad: onLoad
    };
}();

module.exports = LoggedInHandler;

/***/ }),
/* 256 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Client = __webpack_require__(3);
var BinarySocket = __webpack_require__(5);
var getElementById = __webpack_require__(4).getElementById;
var applyToAllElements = __webpack_require__(1).applyToAllElements;
var findParent = __webpack_require__(1).findParent;
var getPropertyValue = __webpack_require__(1).getPropertyValue;
__webpack_require__(247);

var Menu = function () {
    var init = function init() {
        var menu_top = getElementById('menu-top');

        applyToAllElements('li', function (el) {
            el.classList.remove('active', 'active-parent');
        }, '', menu_top);
        if (Client.isLoggedIn()) {
            BinarySocket.wait('landing_company').then(function (response) {
                var financial_shortcode = getPropertyValue(response, ['landing_company', 'financial_company', 'shortcode']);
                // client is virtual and they are allowed to have a financial account
                // or client is real and current account is financial
                var has_financial_markets = Client.get('is_virtual') ? !!financial_shortcode : Client.get('landing_company_shortcode') === financial_shortcode;
                applyToAllElements('.financial-only', function (el) {
                    el.setVisibility(has_financial_markets);
                });
            });
        }

        var menu_top_item_for_page = Array.from(menu_top.getElementsByTagName('a')).find(function (link) {
            return !/invisible/.test(findParent(link, 'li').classList) && link.href !== 'javascript:;' && window.location.pathname.indexOf(link.pathname.replace(/\.html/, '')) >= 0 && link.target !== '_blank';
        });

        if (menu_top_item_for_page) {
            findParent(menu_top_item_for_page, 'li').classList.add('active');
            // if it's a sub-menu item, also make the parent active
            // can't use the class active because it will make all children <a> orange
            var menu_parent = findParent(menu_top_item_for_page, '.nav-dropdown-toggle');
            if (menu_parent) {
                menu_parent.classList.add('active-parent');
            }
        }
    };

    var makeMobileMenu = function makeMobileMenu() {
        // avoid creating mobile menu in desktop view as it duplicates menu items with the same id
        if (getElementById('mobile-menu-container').offsetParent) {
            $('#mobile-menu').mmenu({
                position: 'right',
                zposition: 'front',
                slidingSubmenus: false,
                searchfield: true,
                onClick: { close: true }
            }, { selectedClass: 'active' });
        }
    };

    return {
        init: init,
        makeMobileMenu: makeMobileMenu
    };
}();

module.exports = Menu;

/***/ }),
/* 257 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Header = __webpack_require__(27);
var BinarySocketGeneral = __webpack_require__(260);
var NetworkMonitorBase = __webpack_require__(241);
var getElementById = __webpack_require__(4).getElementById;
var localize = __webpack_require__(2).localize;

var NetworkMonitor = function () {
    var connection_error_code = 'CONNECTION_ERROR';

    var el_status = void 0,
        el_tooltip = void 0;

    var init = function init() {
        el_status = getElementById('network_status');
        el_tooltip = el_status.parentNode;

        NetworkMonitorBase.init(BinarySocketGeneral, updateUI);
    };

    var updateUI = function updateUI(status, is_online) {
        if (is_online) {
            Header.hideNotification(connection_error_code);
        } else {
            Header.displayNotification(localize('Connection error: Please check your internet connection.'), true, connection_error_code);
        }

        if (el_status && el_tooltip) {
            el_status.setAttribute('class', status.class);
            el_tooltip.setAttribute('data-balloon', localize('Network status') + ': ' + localize(status.tooltip));
        }
    };

    return {
        init: init
    };
}();

module.exports = NetworkMonitor;

/***/ }),
/* 258 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Cookies = __webpack_require__(50);
var Client = __webpack_require__(3);
var Contents = __webpack_require__(253);
var Header = __webpack_require__(27);
var Menu = __webpack_require__(256);
var BinarySocket = __webpack_require__(5);
var checkLanguage = __webpack_require__(168).checkLanguage;
var TrafficSource = __webpack_require__(170);
var RealityCheck = __webpack_require__(325);
var Login = __webpack_require__(55);
var elementInnerHtml = __webpack_require__(4).elementInnerHtml;
var getElementById = __webpack_require__(4).getElementById;
var Crowdin = __webpack_require__(161);
var Language = __webpack_require__(16);
var PushNotification = __webpack_require__(249);
var Localize = __webpack_require__(2);
var localize = __webpack_require__(2).localize;
var State = __webpack_require__(6).State;
var scrollToTop = __webpack_require__(94).scrollToTop;
var Url = __webpack_require__(8);
var createElement = __webpack_require__(1).createElement;
var AffiliatePopup = __webpack_require__(184);
__webpack_require__(163);
__webpack_require__(164);

var Page = function () {
    var init = function init() {
        State.set('is_loaded_by_pjax', false);
        Url.init();
        PushNotification.init();
        onDocumentReady();
        Crowdin.init();
    };

    var onDocumentReady = function onDocumentReady() {
        // LocalStorage can be used as a means of communication among
        // different windows. The problem that is solved here is what
        // happens if the user logs out or switches loginid in one
        // window while keeping another window or tab open. This can
        // lead to unintended trades. The solution is to reload the
        // page in all windows after switching loginid or after logout.

        // onLoad.queue does not work on the home page.
        // jQuery's ready function works always.
        $(document).ready(function () {
            // Cookies is not always available.
            // So, fall back to a more basic solution.
            window.addEventListener('storage', function (evt) {
                switch (evt.key) {
                    case 'active_loginid':
                        // not the active tab and logged out or loginid switch
                        if (document.hidden && (evt.newValue === '' || !window.is_logging_in)) {
                            reload();
                        }
                        break;
                    case 'new_release_reload_time':
                        if (evt.newValue !== evt.oldValue) {
                            reload(true);
                        }
                        break;
                    // no default
                }
            });
            scrollToTop();
        });
    };

    var onLoad = function onLoad() {
        if (State.get('is_loaded_by_pjax')) {
            Url.reset();
        } else {
            init();
            if (!Login.isLoginPages()) {
                Language.setCookie(Language.urlLang());
            }
            Localize.forLang(Language.urlLang());
            Header.onLoad();
            Language.setCookie();
            Menu.makeMobileMenu();
            recordAffiliateExposure();
            endpointNotification();
        }
        Contents.onLoad();

        if (sessionStorage.getItem('showLoginPage')) {
            sessionStorage.removeItem('showLoginPage');
            Login.redirectToLogin();
        }
        if (Client.isLoggedIn()) {
            BinarySocket.wait('authorize', 'website_status', 'get_account_status').then(function () {
                checkLanguage();
                RealityCheck.onLoad();
                Menu.init();
            });
        } else {
            checkLanguage();
            Menu.init();
        }
        TrafficSource.setData();
    };

    var recordAffiliateExposure = function recordAffiliateExposure() {
        var token = Url.param('t');
        if (!token || token.length !== 32) {
            return false;
        }

        AffiliatePopup.show();

        var token_length = token.length;
        var is_subsidiary = /\w{1}/.test(Url.param('s'));

        var cookie_token = Cookies.getJSON('affiliate_tracking');
        if (cookie_token) {
            // Already exposed to some other affiliate.
            if (is_subsidiary && cookie_token && cookie_token.t) {
                return false;
            }
        }

        // Record the affiliate exposure. Overwrite existing cookie, if any.
        var cookie_hash = {};
        if (token_length === 32) {
            cookie_hash.t = token.toString();
        }
        if (is_subsidiary) {
            cookie_hash.s = '1';
        }

        Cookies.set('affiliate_tracking', cookie_hash, {
            expires: 365, // expires in 365 days
            path: '/',
            domain: '.' + location.hostname.split('.').slice(-2).join('.')
        });
        return true;
    };

    var reload = function reload(forced_reload) {
        window.location.reload(!!forced_reload);
    };

    var endpointNotification = function endpointNotification() {
        var server = localStorage.getItem('config.server_url');
        if (server && server.length > 0) {
            var message = (/www\.binary\.com/i.test(window.location.hostname) ? '' : localize('This is a staging server - For testing purposes only') + ' - ') + '\n                ' + localize('The server <a href="[_1]">endpoint</a> is: [_2]', [Url.urlFor('endpoint'), server]);

            var end_note = getElementById('end-note');
            elementInnerHtml(end_note, message);
            end_note.setVisibility(1);

            getElementById('footer').style['padding-bottom'] = end_note.offsetHeight;
        }
    };

    var showNotificationOutdatedBrowser = function showNotificationOutdatedBrowser() {
        var src = '//browser-update.org/update.min.js';
        if (document.querySelector('script[src*="' + src + '"]')) return;
        window.$buoop = {
            vs: { i: 11, f: -4, o: -4, s: 9, c: -4 },
            api: 4,
            l: Language.get().toLowerCase(),
            url: 'https://whatbrowser.org/',
            noclose: true, // Do not show the 'ignore' button to close the notification
            text: localize('Your web browser ([_1]) is out of date and may affect your trading experience. Proceed at your own risk. [_2]Update browser[_3]', ['{brow_name}', '<a href="https://www.whatbrowser.org/" target="_blank">', '</a>']),
            reminder: 0 // show all the time
        };
        if (document.body) {
            document.body.appendChild(createElement('script', { src: src }));
        }
    };

    return {
        onLoad: onLoad,
        showNotificationOutdatedBrowser: showNotificationOutdatedBrowser
    };
}();

module.exports = Page;

/***/ }),
/* 259 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var defaultRedirectUrl = __webpack_require__(3).defaultRedirectUrl;
var Url = __webpack_require__(8);

var Redirect = function () {
    var onLoad = function onLoad() {
        var actions_map = {
            signup: { path: 'new_account/virtualws' },
            reset_password: { path: 'user/reset_passwordws' },
            payment_withdraw: { path: 'cashier/forwardws', query: 'action=withdraw' },
            payment_agent_withdraw: { path: 'paymentagent/withdrawws' },
            mt5_password_reset: { path: 'user/metatrader' }
        };

        var params = Url.paramsHash();
        var config = actions_map[params.action];
        // need to redirect not using pjax
        window.location.href = config && params.code ? Url.urlFor(config.path, config.query, params.lang || '') + '#token=' + params.code : defaultRedirectUrl();
    };

    return {
        onLoad: onLoad
    };
}();

module.exports = Redirect;

/***/ }),
/* 260 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BinaryPjax = __webpack_require__(12);
var Client = __webpack_require__(3);
var Clock = __webpack_require__(26);
var Footer = __webpack_require__(254);
var Header = __webpack_require__(27);
var BinarySocket = __webpack_require__(5);
var Dialog = __webpack_require__(75);
var showPopup = __webpack_require__(121);
var setCurrencies = __webpack_require__(7).setCurrencies;
var SessionDurationLimit = __webpack_require__(264);
var updateBalance = __webpack_require__(330);
var GTM = __webpack_require__(54);
var Login = __webpack_require__(55);
var localize = __webpack_require__(2).localize;
var getElementById = __webpack_require__(4).getElementById;
var State = __webpack_require__(6).State;
var urlFor = __webpack_require__(8).urlFor;
var getPropertyValue = __webpack_require__(1).getPropertyValue;

var BinarySocketGeneral = function () {
    var onOpen = function onOpen(is_ready) {
        Header.hideNotification();
        if (is_ready) {
            if (!Login.isLoginPages()) {
                if (!Client.isValidLoginid()) {
                    Client.sendLogoutRequest();
                    return;
                }
                BinarySocket.send({ website_status: 1, subscribe: 1 });
                if (Client.isLoggedIn()) {
                    BinarySocket.wait('authorize').then(function () {
                        Client.setJPFlag();
                        BinaryPjax.init(getElementById('content-holder'), '#content');
                    });
                }
            }
            Clock.startClock();
        }
    };

    var onMessage = function onMessage(response) {
        handleError(response);
        Header.hideNotification('CONNECTION_ERROR');
        var is_available = false;
        switch (response.msg_type) {
            case 'website_status':
                if (response.website_status) {
                    is_available = /^up$/i.test(response.website_status.site_status);
                    if (is_available && !BinarySocket.availability()) {
                        window.location.reload();
                        return;
                    }
                    if (response.website_status.message) {
                        Footer.displayNotification(response.website_status.message);
                    } else {
                        Footer.clearNotification();
                    }
                    BinarySocket.availability(is_available);
                    setCurrencies(response.website_status);
                }
                break;
            case 'authorize':
                if (response.error) {
                    var is_active_tab = sessionStorage.getItem('active_tab') === '1';
                    if (getPropertyValue(response, ['error', 'code']) === 'SelfExclusion' && is_active_tab) {
                        sessionStorage.removeItem('active_tab');
                        Dialog.alert({ id: 'authorize_error_alert', message: response.error.message });
                    }
                    Client.sendLogoutRequest(is_active_tab);
                } else if (!Login.isLoginPages() && !/authorize/.test(State.get('skip_response'))) {
                    if (response.authorize.loginid !== Client.get('loginid')) {
                        Client.sendLogoutRequest(true);
                    } else {
                        Client.responseAuthorize(response);
                        BinarySocket.send({ balance: 1, subscribe: 1 });
                        BinarySocket.send({ get_settings: 1 });
                        BinarySocket.send({ get_account_status: 1 });
                        BinarySocket.send({ payout_currencies: 1 });
                        BinarySocket.send({ mt5_login_list: 1 });
                        setResidence(response.authorize.country || Client.get('residence'));
                        if (!Client.get('is_virtual')) {
                            BinarySocket.send({ get_self_exclusion: 1 });
                        }
                        BinarySocket.sendBuffered();
                        if (/bch/i.test(response.authorize.currency) && !Client.get('accepted_bch')) {
                            showPopup({
                                url: urlFor('user/warning'),
                                popup_id: 'warning_popup',
                                form_id: '#frm_warning',
                                content_id: '#warning_content',
                                validations: [{ selector: '#chk_accept', validations: [['req', { hide_asterisk: true }]] }],
                                onAccept: function onAccept() {
                                    Client.set('accepted_bch', 1);
                                }
                            });
                        }
                    }
                }
                break;
            case 'balance':
                updateBalance(response);
                break;
            case 'logout':
                Client.doLogout(response);
                break;
            case 'landing_company':
                Header.upgradeMessageVisibility();
                if (!response.error) {
                    Header.metatraderMenuItemVisibility();
                }
                break;
            case 'get_self_exclusion':
                SessionDurationLimit.exclusionResponseHandler(response);
                break;
            case 'get_settings':
                if (response.get_settings) {
                    setResidence(response.get_settings.country_code);
                    Client.set('email', response.get_settings.email);
                    GTM.eventHandler(response.get_settings);
                    if (response.get_settings.is_authenticated_payment_agent) {
                        $('#topMenuPaymentAgent').setVisibility(1);
                    }
                }
                break;
            // no default
        }
    };

    var setResidence = function setResidence(residence) {
        if (residence) {
            Client.set('residence', residence);
            BinarySocket.send({ landing_company: residence });
        }
    };

    var handleError = function handleError(response) {
        var msg_type = response.msg_type;
        var error_code = getPropertyValue(response, ['error', 'code']);
        switch (error_code) {
            case 'WrongResponse':
            case 'InternalServerError':
            case 'OutputValidationFailed':
                {
                    if (msg_type !== 'mt5_login_list') {
                        showNoticeMessage(response.error.message);
                    }
                    break;
                }
            case 'RateLimit':
                if (msg_type !== 'cashier_password') {
                    Header.displayNotification(localize('You have reached the rate limit of requests per second. Please try later.'), true, 'RATE_LIMIT');
                }
                break;
            case 'InvalidAppID':
                Header.displayNotification(response.error.message, true, 'INVALID_APP_ID');
                break;
            case 'DisabledClient':
                showNoticeMessage(response.error.message);
                break;
            // no default
        }
    };

    var showNoticeMessage = function showNoticeMessage(text) {
        $('#content').empty().html($('<div/>', { class: 'container' }).append($('<p/>', { class: 'notice-msg center-text', text: text })));
    };

    return {
        onOpen: onOpen,
        onMessage: onMessage
    };
}();

module.exports = BinarySocketGeneral;

/***/ }),
/* 261 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Language = __webpack_require__(16);

var createLanguageDropDown = function createLanguageDropDown(website_status) {
    var $languages = $('.languages');

    if ($languages.find('#display_language li').attr('class')) {
        return;
    }

    var select_language_id = '#select_language';
    var current_language = Language.get();

    $languages.find('#display_language li, ' + select_language_id + ' li').addClass(current_language).find('span.language').text(mapCodeToLanguage(current_language));

    var languages = website_status.supported_languages.sort(function (a, b) {
        return a === 'EN' || a < b ? -1 : 1;
    });
    var $select_language = $languages.find(select_language_id);
    languages.forEach(function (language) {
        $select_language.append($('<li/>', { class: language, text: mapCodeToLanguage(language) }));
    });

    $select_language.find('.' + current_language + ':eq(1)').setVisibility(0);
    Language.onChange();
    $languages.setVisibility(1);
};

var mapCodeToLanguage = function mapCodeToLanguage(code) {
    return Language.getAll()[code];
};

module.exports = createLanguageDropDown;

/***/ }),
/* 262 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Client = __webpack_require__(3);
var BinarySocket = __webpack_require__(5);
var State = __webpack_require__(6).State;
var updateTabDisplay = __webpack_require__(95).updateTabDisplay;
var MetaTrader = __webpack_require__(129);

/*
    data-show attribute controls element visibility based on
        - current landing company
        - metatrader availability
        - logged in status

    attribute value is a list of comma separated
        - landing company shortcodes
        - 'mtcompany' code that stands for metatrader availability
        - 'default' code that describes logged out users

    Examples:
        Show only for logged in clients with costarica landing company:
            data-show='costarica'
        Hide for costarica clients:
            data-show='-costarica'
        Hide for malta and maltainvest clients:
            data-show='-malta, -maltainvest'

    Prohibited values:
        Cannot mix includes and excludes:
            data-show='costarica, -malta' -> throws error
        Shortcodes are case sensitive:
            data-show='Costarica'         -> throws error
*/

var ContentVisibility = function () {
    var init = function init() {
        if (Client.isLoggedIn()) {
            BinarySocket.wait('authorize', 'landing_company').then(function () {
                controlVisibility(State.getResponse('authorize.landing_company_name'), MetaTrader.isEligible());
            });
        } else {
            controlVisibility('default', true);
        }
    };

    var generateParsingErrorMessage = function generateParsingErrorMessage(reason, attr_str) {
        return 'Invalid data-show attribute value! ' + reason + ' Given value: \'' + attr_str + '\'.';
    };

    var parseAttributeString = function parseAttributeString(attr_str) {
        if (!/^[a-z,-\s]+$/.test(attr_str)) {
            throw new Error(generateParsingErrorMessage('Invalid characted used.', attr_str));
        }
        var names = attr_str.split(',').map(function (name) {
            return name.trim();
        });
        if (names.some(function (name) {
            return name.length === 0;
        })) {
            throw new Error(generateParsingErrorMessage('No empty names allowed.', attr_str));
        }
        var is_exclude = names.every(function (name) {
            return name[0] === '-';
        });
        var is_include = names.every(function (name) {
            return name[0] !== '-';
        });
        if (!is_exclude && !is_include) {
            throw new Error(generateParsingErrorMessage('No mixing of includes and excludes allowed.', attr_str));
        }
        if (is_exclude) {
            names = names.map(function (name) {
                return name.slice(1);
            });
        }
        return {
            is_exclude: is_exclude,
            names: names
        };
    };

    var controlVisibility = function controlVisibility(current_landing_company_shortcode, client_has_mt_company) {
        var visible_classname = 'data-show-visible';
        var mt_company_rule = 'mtcompany';

        document.querySelectorAll('[data-show]').forEach(function (el) {
            var attr_str = el.dataset.show;

            var _parseAttributeString = parseAttributeString(attr_str),
                is_exclude = _parseAttributeString.is_exclude,
                names = _parseAttributeString.names;

            var rule_set = new Set(names);

            var rule_set_has_current = rule_set.has(current_landing_company_shortcode);
            var rule_set_has_mt = rule_set.has(mt_company_rule);

            var show_element = false;

            if (client_has_mt_company && rule_set_has_mt) show_element = !is_exclude;else if (is_exclude !== rule_set_has_current) show_element = true;

            if (show_element) {
                el.classList.add(visible_classname);
            } else {
                var open_tab_url = new RegExp('\\?.+_tabs=' + el.id, 'i');
                // check if we hide a tab that's open
                // then redirect to the url without query
                if (el.classList.contains('tm-li') && open_tab_url.test(window.location.href)) {
                    var _window$location = window.location,
                        origin = _window$location.origin,
                        pathname = _window$location.pathname;

                    window.location.href = origin + pathname;
                }
            }
        });

        updateTabDisplay();
    };

    return {
        init: init
    };
}();

module.exports = ContentVisibility;

/***/ }),
/* 263 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Cookies = __webpack_require__(50);
var EnjoyHint = __webpack_require__(246);
var localize = __webpack_require__(2).localize;

/*
 *  This is developed to simplify the usage of enjoyhint (https://github.com/xbsoftware/enjoyhint)
 *
 *  How to Implement in a page:
 *  1. Add the button element to the template: <div id="guideBtn"></div>
 *  2. Add the js initialization call, having the customized parameters: Guide.init({script : 'trading'});
 *  3. Add the script data to getScript() method
 */

var Guide = function () {
    var opt = void 0,
        cookie_name = void 0,
        btn_next = void 0,
        btn_finish = void 0;

    var init = function init(options) {
        opt = {
            script: '', // the script name in scripts
            autoStart: false, // false: start by button click
            guideBtnID: '#guideBtn',
            btnText: localize('Guide'), // guide start button's text
            blink_class: 'highlight',
            blink_inDelay: 1000,
            blink_outDelay: 1000,
            blink_interval: 3000, // 0: continous blinking (blink_inDelay + blink_outDelay)
            blink_count: 0 // 0: infinite
        };
        $.extend(true, opt, options);

        cookie_name = 'hide_guide';
        btn_next = { className: 'button', html: $('<span/>', { text: localize('Next') }) };
        btn_finish = { className: 'button btnFinish', html: $('<span/>', { text: localize('Finish') }) };

        if ($(opt.guideBtnID).length === 0 || opt.script.length === 0) {
            return;
        }

        if (isDisabled()) {
            $(opt.guideBtnID).remove();
            return;
        }

        makeButton();
    };

    /*
     *  do not show the guide button if its close (X) has been clicked before
     */
    var isDisabled = function isDisabled() {
        var disabled = Cookies.get(cookie_name);
        return !!disabled && $.inArray(opt.script, disabled.split(',')) >= 0;
    };

    /*
     *  handle the guide button appearance using a cookie for all scripts
     */
    var setDisabled = function setDisabled() {
        if (!isDisabled()) {
            var disabled = Cookies.get(cookie_name);
            Cookies.set(cookie_name, !disabled ? opt.script : disabled + ',' + opt.script);
        }
    };

    /*
     *  generate the button's html
     */
    var makeButton = function makeButton() {
        if ($(opt.guideBtnID).children().length > 0) {
            return;
        }

        $(opt.guideBtnID).addClass('gr-hide-m pulser').append($('<span/>', { class: 'close', text: 'X' })).append($('<strong/>'));
        $(opt.guideBtnID + ' strong').html('<span></span>' + opt.btnText);

        setEvents();
    };

    /*
     *  both buttons' click event
     */
    var setEvents = function setEvents() {
        $(opt.guideBtnID + ' strong').click(function () {
            var enjoyhint_instance = new EnjoyHint({});
            enjoyhint_instance.setScript(getScript(opt.script));
            enjoyhint_instance.runScript();
        });

        if (opt.autoStart) {
            $(opt.guideBtnID).click();
        }

        // Hide button
        $(opt.guideBtnID + ' span.close').click(function () {
            setDisabled();
            $(opt.guideBtnID).remove();
        });
    };

    /*
     *  each page's script
     */
    var getScript = function getScript(script_name) {
        if (script_name !== 'trading') {
            return null;
        }
        return [{
            selector: '#underlying_component',
            description: '<h1>' + localize('Step') + ' 1</h1>' + localize('Select your market and underlying asset'),
            event_type: 'next',
            nextButton: btn_next
        }, {
            selector: '#contract_component',
            description: '<h1>' + localize('Step') + ' 2</h1>' + localize('Select your trade type'),
            event_type: 'next',
            nextButton: btn_next
        }, {
            selector: '#websocket_form',
            description: '<h1>' + localize('Step') + ' 3</h1>' + localize('Adjust trade parameters'),
            event_type: 'next',
            nextButton: btn_next
        }, {
            selector: '#contracts_list',
            description: '<h1>' + localize('Step') + ' 4</h1>' + localize('Predict the direction<br />and purchase'),
            event_type: 'next',
            nextButton: btn_finish
        }];
    };

    return {
        init: init
    };
}();

module.exports = Guide;

/***/ }),
/* 264 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var moment = __webpack_require__(9);
var Client = __webpack_require__(3);
var localize = __webpack_require__(2).localize;
var getPropertyValue = __webpack_require__(1).getPropertyValue;

var SessionDurationLimit = function () {
    var warning = void 0,
        timeout_before = void 0,
        timeout = void 0,
        timeout_logout = void 0;

    var init = function init() {
        clearTimeout(timeout_before);
        clearTimeout(timeout);
        clearTimeout(timeout_logout);
        $('#session_limit').remove();

        warning = 10 * 1000; // milliseconds before limit to display the warning message

        var limit = Client.get('session_duration_limit') * 1;
        var now = moment().unix();
        var start = Client.get('session_start') * 1;
        var math_limit = Math.pow(2, 31) - 1;
        var remained = (limit + start - now) * 1000;
        if (remained < 0) remained = warning;

        var setTimeOut = function setTimeOut() {
            timeout = setTimeout(displayWarning, remained - warning);
            timeout_logout = setTimeout(Client.sendLogoutRequest, remained);
        };

        // limit of setTimeout is this number
        if (remained > math_limit) {
            remained %= math_limit;
            timeout_before = setTimeout(init, remained);
        } else {
            setTimeOut();
        }
    };

    var exclusionResponseHandler = function exclusionResponseHandler(response) {
        if (getPropertyValue(response, 'error') || !getPropertyValue(response, 'get_self_exclusion')) {
            return;
        }

        var limit = response.get_self_exclusion.session_duration_limit * 60;
        if (isNaN(limit) || limit <= 0) return;

        Client.set('session_duration_limit', limit);
        window.addEventListener('storage', init, false);

        init();
    };

    var displayWarning = function displayWarning() {
        $('body').append($('<div/>', { id: 'session_limit', class: 'lightbox' }).append($('<div/>', { class: 'gr-padding-10 gr-gutter', text: localize('Your session duration limit will end in [_1] seconds.', [warning / 1000]) })));
        $('#session_limit').click(function () {
            $(this).remove();
        });
    };

    return {
        exclusionResponseHandler: exclusionResponseHandler
    };
}();

module.exports = SessionDurationLimit;

/***/ }),
/* 265 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BinaryPjax = __webpack_require__(12);
var Client = __webpack_require__(3);
var BinarySocket = __webpack_require__(5);
var localize = __webpack_require__(2).localize;
var State = __webpack_require__(6).State;

var CashierJP = function () {
    var $amount = void 0,
        $loginid = void 0,
        $email = void 0;

    var _onLoad = function _onLoad(action) {
        if (Client.isJPClient() && Client.get('residence') !== 'jp') BinaryPjax.loadPreviousUrl();
        if (action === 'deposit') {
            return;
        }
        var $container = $('#japan_cashier_container');
        BinarySocket.send({ cashier_password: 1 }).then(function (response) {
            if (response.error) {
                $('#cashier_error_message').text(response.error.code === 'RateLimit' ? localize('You have reached the rate limit of requests per second. Please try later.') : response.error.message).setVisibility(1);
            } else if (response.cashier_password === 1) {
                $container.find('#cashier_locked_message').setVisibility(1);
            } else {
                BinarySocket.send({ get_account_status: 1 }).then(function (response_status) {
                    if (!response_status.error && /cashier_locked/.test(response_status.get_account_status.status)) {
                        $container.find('#cashier_locked_message').text(localize('Your cashier is locked.')).setVisibility(1); // Locked from BO
                    } else {
                        var limit = State.getResponse('get_limits.remainder');
                        if (typeof limit !== 'undefined' && limit < 1) {
                            $container.find('#cashier_locked_message').text(localize('You have reached the withdrawal limit.')).setVisibility(1);
                        } else {
                            $amount = $('#id123-control22598145');
                            $loginid = $('#id123-control22598118');
                            $email = $('#id123-control22598060');

                            var response_authorize = State.getResponse('authorize');
                            if (response_authorize.loginid) {
                                $loginid.val(response_authorize.loginid).attr('readonly', 'true');
                            }
                            if (response_authorize.email) {
                                $email.val(response_authorize.email).attr('readonly', 'true');
                            }
                            $('#japan_cashier_container button').on('click', function (e) {
                                var result = errorHandler();
                                if (!result) e.preventDefault();
                            });
                            $container.find('#cashier_unlocked_message').setVisibility(1);
                        }
                    }
                });
            }
        });
    };

    var errorHandler = function errorHandler() {
        $amount.siblings('.error-msg').setVisibility(0);
        $loginid.siblings('.error-msg').setVisibility(0);
        $email.siblings('.error-msg').setVisibility(0);

        var is_ok = true;

        if (isNaN($amount.val()) || +$amount.val() < 1) {
            $amount.siblings('.error-msg').text(localize('Should be more than [_1]', ['¥1'])).setVisibility(1);
            is_ok = false;
        } else if (parseInt(Client.get('balance')) < +$amount.val()) {
            $amount.siblings('.error-msg').text(localize('Insufficient balance.')).setVisibility(1);
            is_ok = false;
        }
        if (!$loginid.val()) {
            $loginid.removeAttr('readonly').siblings('.error-msg').setVisibility(1);
            is_ok = false;
        }
        if (!$email.val()) {
            $email.removeAttr('readonly').siblings('.error-msg').setVisibility(1);
            is_ok = false;
        }

        return is_ok;
    };

    return {
        errorHandler: errorHandler,

        Deposit: { onLoad: function onLoad() {
                _onLoad('deposit');
            } },
        Withdraw: { onLoad: function onLoad() {
                _onLoad('withdraw');
            } }
    };
}();

module.exports = CashierJP;

/***/ }),
/* 266 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Cookies = __webpack_require__(50);
var KnowledgeTestUI = __webpack_require__(267);
var BinaryPjax = __webpack_require__(12);
var Client = __webpack_require__(3);
var toJapanTimeIfNeeded = __webpack_require__(26).toJapanTimeIfNeeded;
var Header = __webpack_require__(27);
var BinarySocket = __webpack_require__(5);
var localize = __webpack_require__(2).localize;

var KnowledgeTest = function () {
    var submitted = {};
    var obj_random_picks = {};
    var passing_score = 14; // minimum score to pass the test
    var msg_pass = '{JAPAN ONLY}Congratulations, you have pass the test, our Customer Support will contact you shortly.';
    var msg_fail = '{JAPAN ONLY}Sorry, you have failed the test, please try again after 24 hours.';

    var submit_completed = false;
    var random_picks = [];
    var result_score = 0;

    var $container = void 0,
        $header = void 0,
        $message = void 0,
        $questions = void 0,
        $instructions = void 0;

    var onLoad = function onLoad() {
        // need to send get_settings because client status needs to be checked against latest available data
        BinarySocket.send({ get_settings: 1 }, { forced: true }).then(function (response) {
            var jp_status = response.get_settings.jp_account_status;

            if (!jp_status) {
                BinaryPjax.loadPreviousUrl();
                return;
            }

            $container = $('#knowledge-test-container');
            $header = $container.find('#knowledge-test-header');
            $message = $container.find('#knowledge-test-msg');
            $questions = $container.find('#knowledge-test-questions');
            $instructions = $container.find('#knowledge-test-instructions');

            // show knowledge test link in header after updated get_settings call
            Header.upgradeMessageVisibility();

            switch (jp_status.status) {
                case 'jp_knowledge_test_pending':
                    populateQuestions();
                    break;
                case 'jp_knowledge_test_fail':
                    {
                        if (Date.now() >= jp_status.next_test_epoch * 1000) {
                            // show Knowledge Test cannot be taken
                            populateQuestions();
                        } else {
                            showDisallowedMsg(jp_status);
                        }
                        break;
                    }
                default:
                    {
                        window.location.href = Client.defaultRedirectUrl(); // needs to be loaded without pjax
                    }
            }
        });
    };

    var populateQuestions = function populateQuestions() {
        random_picks = randomPick20();
        random_picks.reduce(function (a, b) {
            return a.concat(b);
        }).forEach(function (question) {
            obj_random_picks[question.id] = question;
        });

        showQuestionsTable();
    };

    var randomPick20 = function randomPick20() {
        var questions = {};
        // retrieve questions text from html
        $container.find('#data-questions').find('> div').each(function () {
            // sections
            var category_name = +$(this).attr('data-section-id');
            questions['section' + category_name] = [];

            $(this).find('> div').each(function () {
                // questions
                var question_id = +$(this).attr('data-question-id');
                questions['section' + category_name].push({
                    category: category_name,
                    id: question_id,
                    question: $(this).attr('data-question-en'),
                    question_localized: $(this).text(),
                    correct_answer: answers[question_id],
                    tooltip: $(this).attr('data-tip')
                });
            });
        });

        var picked_questions = [];
        Object.keys(questions).forEach(function (section) {
            return picked_questions.push(randomPick4(questions[section]));
        });
        return picked_questions;
    };

    var randomPick4 = function randomPick4(obj_questions) {
        var availables = Object.keys(obj_questions);

        var random_picks_four = [];
        for (var i = 0; i < 4; i++) {
            var random_index = Math.floor(Math.random() * 100) % availables.length;
            random_picks_four.push(obj_questions[availables[random_index]]);
            availables.splice(random_index, 1);
        }

        return random_picks_four;
    };

    var answers = {
        /* eslint-disable */
        1: false, 2: true, 3: true, 4: true, 5: true, 6: true, 7: true, 8: true, 9: false, 10: true,
        11: false, 12: true, 13: false, 14: true, 15: true, 16: true, 17: false, 18: true, 19: true, 20: true,
        21: true, 22: false, 23: true, 24: false, 25: false, 26: true, 27: true, 28: true, 29: true, 30: true,
        31: false, 32: true, 33: false, 34: true, 35: false, 36: true, 37: true, 38: false, 39: true, 40: false,
        41: false, 42: true, 43: true, 44: true, 45: true, 46: true, 47: true, 48: false, 49: false, 50: true,
        51: false, 52: true, 53: true, 54: false, 55: true, 56: true, 57: true, 58: true, 59: true, 60: true,
        61: true, 62: false, 63: true, 64: true, 65: true, 66: false, 67: true, 68: true, 69: true, 70: true,
        71: true, 72: true, 73: true, 74: false, 75: false, 76: true, 77: false, 78: true, 79: true, 80: true,
        81: true, 82: true, 83: true, 84: true, 85: true, 86: true, 87: true, 88: false, 89: true, 90: true,
        91: true, 92: true, 93: true, 94: true, 95: false, 96: true, 97: true, 98: false, 99: true, 100: true
        /* eslint-enable */
    };

    var showQuestionsTable = function showQuestionsTable() {
        for (var j = 0; j < random_picks.length; j++) {
            var table = KnowledgeTestUI.createQuestionTable(random_picks[j]);
            $container.find('#section' + (j + 1) + '-question').append(table);
        }

        $questions.find('input[type=radio]').click(questionAnswerHandler);
        $container.find('#knowledge-test-submit').click(submitHandler);
        showMessage('{JAPAN ONLY}Please complete the following questions.', 1);
    };

    var questionAnswerHandler = function questionAnswerHandler(ev) {
        submitted[ev.target.name] = +ev.target.value === 1;
    };

    var submitHandler = function submitHandler() {
        if (submit_completed) return;

        var answered_qid = Object.keys(submitted).map(function (k) {
            return +k;
        });
        if (answered_qid.length !== 20) {
            $instructions.setVisibility(0);
            $message.addClass('notice-msg').text(localize('{JAPAN ONLY}You need to finish all 20 questions.'));

            var unanswered = random_picks.reduce(function (a, b) {
                return a.concat(b);
            }).find(function (q) {
                return answered_qid.indexOf(q.id) === -1;
            }).id;

            $.scrollTo('a[name="' + unanswered + '"]', 500, { offset: -10 });
            return;
        }

        // compute score
        var questions = [];
        Object.keys(submitted).forEach(function (k) {
            var question_info = obj_random_picks[k];
            var score = submitted[k] === question_info.correct_answer ? 1 : 0;
            result_score += score;
            question_info.answer = submitted[k];
            questions.push({
                category: question_info.category,
                id: question_info.id,
                question: question_info.question,
                answer: question_info.answer ? 1 : 0,
                pass: score
            });
        });
        sendResult(questions);
        submit_completed = true;
    };

    var sendResult = function sendResult(all_questions) {
        BinarySocket.send({
            jp_knowledge_test: 1,
            score: result_score,
            status: result_score >= passing_score ? 'pass' : 'fail',
            questions: all_questions
        }).then(function (response) {
            if (!response.error) {
                showResult(result_score, response.jp_knowledge_test.test_taken_epoch * 1000);
                $.scrollTo('body', 500);
                BinarySocket.send({ get_settings: 1 }, { forced: true }).then(function () {
                    Header.upgradeMessageVisibility();
                });
            } else if (response.error.code === 'TestUnavailableNow') {
                showMessage('{JAPAN ONLY}The test is unavailable now, test can only be taken again on next business day with respect of most recent test.');
            } else {
                $('#form-msg').html(response.error.message).setVisibility(1);
                submit_completed = false;
            }
        });
    };

    var showResult = function showResult(score, time) {
        $header.text(localize('{JAPAN ONLY}Knowledge Test Result'));
        showMessage(score >= passing_score ? msg_pass : msg_fail);
        $container.append(KnowledgeTestUI.createResultUI(score, time));

        // affiiates measure of fulfillment (TCS-ASP)
        if (score >= passing_score && Cookies.get('affiliate_tracking')) {
            $message.append($('<img/>', { src: 'https://www.tcs-asp.net/aresult?LC=BINARY1&NK=' + Client.get('loginid') }).setVisibility(0));
        }
    };

    var showMessage = function showMessage(msg) {
        var set_visible = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

        $instructions.setVisibility(set_visible);
        $questions.setVisibility(set_visible);
        $message.text(localize(msg));
    };

    var showDisallowedMsg = function showDisallowedMsg(jp_status) {
        return showMessage(localize('{JAPAN ONLY}Dear customer, you are not allowed to take knowledge test until [_1]. Last test taken at [_2].', [toJapanTimeIfNeeded(+jp_status.next_test_epoch), toJapanTimeIfNeeded(+jp_status.last_test_epoch)]));
    };

    return {
        onLoad: onLoad
    };
}();

module.exports = KnowledgeTest;

/***/ }),
/* 267 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var moment = __webpack_require__(9);
var localize = __webpack_require__(2).localize;
var urlForStatic = __webpack_require__(8).urlForStatic;

var KnowledgeTestUI = function () {
    var center_text_class = 'center-text';

    var createTrueFalseBox = function createTrueFalseBox(question, show_answer) {
        var qid = question.id;
        var true_id = qid + 'true';
        var false_id = qid + 'false';

        var $true_button = $('<input />', {
            type: 'radio',
            name: qid,
            id: true_id,
            value: '1'
        });

        var $true_el = $true_button.add('<label for=' + true_id + '>&#8203</label>');
        var $true_td = $('<td />', { class: center_text_class }).append($true_el);

        var $false_button = $('<input />', {
            type: 'radio',
            name: qid,
            id: false_id,
            value: '0'
        });
        var $false_el = $false_button.add('<label for=' + false_id + '>&#8203</label>');
        var $false_td = $('<td />', { class: center_text_class }).append($false_el);

        if (show_answer) {
            if (question.correct_answer) {
                $true_button.prop('checked', true);
            } else {
                $false_button.prop('checked', true);
            }
            $true_button.attr('disabled', true);
            $false_button.attr('disabled', true);
        }

        return [$true_td, $false_td];
    };

    var createQuestionRow = function createQuestionRow(question_no, question, show_answer) {
        var $question_row = $('<tr></tr>', { id: question_no, class: 'question' });
        var $question_data = $('<td></td>').text(localize(question.question_localized));
        var $question_link = $('<a></a>', {
            name: question.id,
            class: 'no-underline show_mobile',
            'data-balloon': question.tooltip,
            'data-balloon-length': 'medium',
            'data-balloon-pos': 'up'
        });
        var $question_icon = $('<img>', { src: urlForStatic('/images/common/question_1.png') });
        $question_data.append($question_link.append($question_icon));

        var true_false = createTrueFalseBox(question, show_answer);

        return $question_row.append($question_data).append(true_false[0]).append(true_false[1]);
    };

    var createQuestionTable = function createQuestionTable(questions, show_answer) {
        var $header = $('<tr></tr>');
        var $question_col_header = $('<th></th>', { id: 'question-header', class: 'question-col' }).text(localize('Questions'));

        var $true_col_header = $('<th></th>', { id: 'true-header', class: 'true-col' }).text(localize('True'));

        var $false_col_header = $('<th></th>', { id: 'fasle-header', class: 'false-col' }).text(localize('False'));

        $header.append($question_col_header).append($true_col_header).append($false_col_header);

        var $table_container = $('<table></table>', { id: 'knowledge-test' });

        $table_container.append($header);
        var qr = void 0;
        questions.forEach(function (question, question_no) {
            qr = createQuestionRow(question_no, question, show_answer);
            $table_container.append(qr);
        });

        return $table_container;
    };

    var createResultUI = function createResultUI(score) {
        var $result_table = $('<table></table>', { class: 'kv-pairs' });
        var $score_row = $('<tr/>').append($('<td/>', { text: localize('Score') })).append($('<td/>', { text: score }));

        var date = moment();
        var submit_date = '' + moment.utc(date).format('YYYY') + localize('Year') + moment.utc(date).format('MM') + localize('Month') + moment.utc(date).format('DD') + localize('Day') + ' (' + localize('Weekday') + ')';

        var $date_row = $('<tr/>').append($('<td/>', { text: localize('Date') })).append($('<td/>', { text: submit_date }));

        $result_table.append($score_row).append($date_row);

        return $result_table;
    };

    return {
        createQuestionTable: createQuestionTable,
        createResultUI: createResultUI
    };
}();

module.exports = KnowledgeTestUI;

/***/ }),
/* 268 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BinaryPjax = __webpack_require__(12);
var Client = __webpack_require__(3);
var BinarySocket = __webpack_require__(5);
var isCryptocurrency = __webpack_require__(7).isCryptocurrency;
var getMinWithdrawal = __webpack_require__(7).getMinWithdrawal;
var FormManager = __webpack_require__(18);
var elementTextContent = __webpack_require__(4).elementTextContent;
var getElementById = __webpack_require__(4).getElementById;
var localize = __webpack_require__(2).localize;
var State = __webpack_require__(6).State;
var createElement = __webpack_require__(1).createElement;
var getPropertyValue = __webpack_require__(1).getPropertyValue;

var AccountTransfer = function () {
    var form_id = 'frm_account_transfer';
    var form_id_hash = '#' + form_id;

    var messages = {
        parent: 'client_message',
        error: 'no_account',
        balance: 'not_enough_balance',
        deposit: 'no_balance',
        limit: 'limit_reached'
    };

    var el_transfer_from = void 0,
        el_transfer_to = void 0,
        el_reset_transfer = void 0,
        el_transfer_fee = void 0,
        el_success_form = void 0,
        client_balance = void 0,
        client_currency = void 0,
        client_loginid = void 0,
        withdrawal_limit = void 0;

    var populateAccounts = function populateAccounts(accounts) {
        client_loginid = Client.get('loginid');
        el_transfer_from = getElementById('lbl_transfer_from');
        el_transfer_to = getElementById('transfer_to');

        elementTextContent(el_transfer_from, client_loginid + ' ' + (client_currency ? '(' + client_currency + ')' : ''));

        var fragment_transfer_to = document.createElement('div');

        accounts.forEach(function (account) {
            if (Client.canTransferFunds(account)) {
                var option = document.createElement('option');
                option.appendChild(document.createTextNode('' + account.loginid + (account.currency ? ' (' + account.currency + ')' : '')));
                fragment_transfer_to.appendChild(option);
            }
        });

        if (!fragment_transfer_to.childElementCount) {
            showError();
            return;
        }
        if (fragment_transfer_to.childElementCount > 1) {
            el_transfer_to.innerHTML = fragment_transfer_to.innerHTML;
        } else {
            var label = createElement('label', { 'data-value': fragment_transfer_to.innerText });
            label.appendChild(document.createTextNode(fragment_transfer_to.innerText));
            label.id = 'transfer_to';

            el_transfer_to.parentNode.replaceChild(label, el_transfer_to);
            el_transfer_to = getElementById('transfer_to');
        }

        showForm();
        getElementById('transfer_info').setVisibility(1);

        if (Client.hasCurrencyType('crypto') && Client.hasCurrencyType('fiat')) {
            getElementById('transfer_fee').setVisibility(1);
        }
    };

    var hasError = function hasError(response) {
        var error = response.error;
        if (error) {
            var el_error = getElementById('error_message').getElementsByTagName('p')[0];
            elementTextContent(el_error, error.message);
            if (el_error.parentNode) {
                el_error.parentNode.setVisibility(1);
            }
            return true;
        }
        return false;
    };

    var showError = function showError() {
        getElementById(messages.parent).setVisibility(1);
        getElementById(messages.error).setVisibility(1);
    };

    var getDecimals = function getDecimals() {
        return isCryptocurrency(client_currency) ? 8 : 2;
    };

    var showForm = function showForm() {
        elementTextContent(document.querySelector(form_id_hash + ' #currency'), client_currency);

        getElementById(form_id).setVisibility(1);

        FormManager.init(form_id_hash, [{ selector: '#amount', validations: [['req', { hide_asterisk: true }], ['number', { type: 'float', decimals: getDecimals(), min: getMinWithdrawal(client_currency), max: Math.min(+withdrawal_limit, +client_balance), format_money: true }]] }, { request_field: 'transfer_between_accounts', value: 1 }, { request_field: 'account_from', value: client_loginid }, { request_field: 'account_to', value: function value() {
                return (el_transfer_to.value || el_transfer_to.getAttribute('data-value') || '').split(' (')[0];
            } }, { request_field: 'currency', value: client_currency }]);

        FormManager.handleSubmit({
            form_selector: form_id_hash,
            fnc_response_handler: responseHandler,
            enable_button: true
        });
    };

    var responseHandler = function responseHandler(response) {
        if (response.error) {
            var el_error = getElementById('form_error');
            elementTextContent(el_error, response.error.message);
            el_error.setVisibility(1);
            // Auto hide error after 5 seconds.
            setTimeout(function () {
                return el_error.setVisibility(0);
            }, 5000);
        } else {
            BinarySocket.send({ transfer_between_accounts: 1 }).then(function (data) {
                return populateReceipt(response, data);
            });
        }
    };

    var populateReceipt = function populateReceipt(response_submit_success, response) {
        getElementById(form_id).setVisibility(0);

        elementTextContent(getElementById('from_loginid'), client_loginid);
        elementTextContent(getElementById('to_loginid'), response_submit_success.client_to_loginid);

        response.accounts.forEach(function (account) {
            if (account.loginid === client_loginid) {
                elementTextContent(getElementById('from_currency'), account.currency);
                elementTextContent(getElementById('from_balance'), account.balance);
            } else if (account.loginid === response_submit_success.client_to_loginid) {
                elementTextContent(getElementById('to_currency'), account.currency);
                elementTextContent(getElementById('to_balance'), account.balance);
            }
        });

        el_transfer_fee.setVisibility(0);
        el_success_form.setVisibility(1);
        getElementById('transfer_info').setVisibility(0);
    };

    var onClickReset = function onClickReset() {
        el_success_form.setVisibility(0);
        getElementById('amount').value = '';
        onLoad();
    };

    var onLoad = function onLoad() {
        if (!Client.canTransferFunds()) {
            BinaryPjax.loadPreviousUrl();
            return;
        }

        el_transfer_fee = getElementById('transfer_fee');
        el_success_form = getElementById('success_form');
        el_reset_transfer = getElementById('reset_transfer');
        el_reset_transfer.addEventListener('click', onClickReset);

        BinarySocket.wait('balance').then(function (response) {
            client_balance = +getPropertyValue(response, ['balance', 'balance']);
            client_currency = Client.get('currency');
            var min_amount = getMinWithdrawal(client_currency);
            if (!client_balance || client_balance < min_amount) {
                getElementById(messages.parent).setVisibility(1);
                if (client_currency) {
                    elementTextContent(getElementById('min_required_amount'), client_currency + ' ' + min_amount);
                    getElementById(messages.balance).setVisibility(1);
                }
                getElementById(messages.deposit).setVisibility(1);
            } else {
                var req_transfer_between_accounts = BinarySocket.send({ transfer_between_accounts: 1 });
                var req_get_limits = BinarySocket.send({ get_limits: 1 });

                Promise.all([req_transfer_between_accounts, req_get_limits]).then(function () {
                    var response_transfer = State.get(['response', 'transfer_between_accounts']);
                    var response_limits = State.get(['response', 'get_limits']);

                    if (hasError(response_transfer)) {
                        return;
                    }
                    var accounts = response_transfer.accounts;
                    if (!accounts || !accounts.length) {
                        showError();
                        return;
                    }
                    if (hasError(response_limits)) {
                        return;
                    }
                    withdrawal_limit = +response_limits.get_limits.remainder;
                    if (withdrawal_limit < min_amount) {
                        getElementById(messages.limit).setVisibility(1);
                        getElementById(messages.parent).setVisibility(1);
                        return;
                    }
                    getElementById('range_hint').textContent = localize('Min') + ': ' + min_amount + ' ' + localize('Max') + ': ' + localize(client_balance <= withdrawal_limit ? 'Current balance' : 'Withdrawal limit');
                    populateAccounts(accounts);
                });
            }
        });
    };

    var onUnload = function onUnload() {
        if (el_reset_transfer) el_reset_transfer.removeEventListener('click', onClickReset);
    };

    return {
        onLoad: onLoad,
        onUnload: onUnload
    };
}();

module.exports = AccountTransfer;

/***/ }),
/* 269 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BinaryPjax = __webpack_require__(12);
var Client = __webpack_require__(3);
var Header = __webpack_require__(27);
var BinarySocket = __webpack_require__(5);
var isCryptocurrency = __webpack_require__(7).isCryptocurrency;
var getElementById = __webpack_require__(4).getElementById;
var urlFor = __webpack_require__(8).urlFor;
var getPropertyValue = __webpack_require__(1).getPropertyValue;

var Cashier = function () {
    var href = '';

    var showContent = function showContent() {
        Client.activateByClientType();
        Header.upgradeMessageVisibility(); // To handle the upgrade buttons visibility
    };

    var displayTopUpButton = function displayTopUpButton() {
        BinarySocket.wait('balance').then(function (response) {
            var currency = response.balance.currency;
            var balance = +response.balance.balance;
            var can_topup = currency !== 'JPY' && balance <= 1000 || currency === 'JPY' && balance <= 100000;
            var top_up_id = '#VRT_topup_link';
            var $a = $(top_up_id);
            if (!$a) {
                return;
            }
            var classes = ['toggle', 'button-disabled'];
            var new_el = { class: $a.attr('class').replace(classes[+can_topup], classes[1 - +can_topup]), html: $a.html(), id: $a.attr('id') };
            if (can_topup) {
                href = href || urlFor('/cashier/top_up_virtualws');
                new_el.href = href;
            }
            $a.replaceWith($('<a/>', new_el));
            $(top_up_id).parent().setVisibility(1);
        });
    };

    var onLoad = function onLoad() {
        if (Client.isJPClient()) {
            if (Client.get('residence') !== 'jp') {
                BinaryPjax.loadPreviousUrl();
            } else {
                $('.deposit').parent().addClass('button-disabled').attr('href', 'javascript:;');
            }
        }
        if (Client.isLoggedIn()) {
            BinarySocket.wait('authorize').then(function () {
                var is_virtual = Client.get('is_virtual');
                var is_crypto = isCryptocurrency(Client.get('currency'));
                if (is_virtual) {
                    displayTopUpButton();
                }
                var residence = Client.get('residence');
                if (residence) {
                    BinarySocket.send({ paymentagent_list: residence }).then(function (response) {
                        var list = getPropertyValue(response, ['paymentagent_list', 'list']);
                        if (list && list.length) {
                            $('#payment-agent-section').setVisibility(1);
                        }
                    });
                }
                $(is_crypto ? '.crypto_currency' : '.normal_currency').setVisibility(1);
                if (/^BCH/.test(Client.get('currency'))) {
                    getElementById('message_bitcoin_cash').setVisibility(1);
                }
            });
        }
        showContent();
    };

    return {
        onLoad: onLoad,
        PaymentMethods: { onLoad: function onLoad() {
                showContent();
            } }
    };
}();

module.exports = Cashier;

/***/ }),
/* 270 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var setShouldRedirect = __webpack_require__(179).setShouldRedirect;
var BinaryPjax = __webpack_require__(12);
var Client = __webpack_require__(3);
var BinarySocket = __webpack_require__(5);
var showPopup = __webpack_require__(121);
var Currency = __webpack_require__(7);
var FormManager = __webpack_require__(18);
var validEmailToken = __webpack_require__(56).validEmailToken;
var getElementById = __webpack_require__(4).getElementById;
var localize = __webpack_require__(2).localize;
var State = __webpack_require__(6).State;
var toTitleCase = __webpack_require__(17).toTitleCase;
var Url = __webpack_require__(8);
var template = __webpack_require__(1).template;

var DepositWithdraw = function () {
    var default_iframe_height = 700;

    var cashier_type = void 0,
        token = void 0,
        $iframe = void 0,
        $loading = void 0;

    var container = '#deposit_withdraw';

    var init = function init(cashier_password) {
        if (cashier_password) {
            showMessage('cashier_locked_message');
            setShouldRedirect(true);
            return;
        }

        if (!Client.get('currency')) {
            BinaryPjax.load(Url.urlFor('user/set-currency') + '#redirect_' + cashier_type);
            return;
        }

        if (cashier_type === 'deposit') {
            token = '';
            getCashierURL();
        } else if (cashier_type === 'withdraw') {
            checkToken();
        }
    };

    var checkToken = function checkToken() {
        token = Url.getHashValue('token');
        if (!token) {
            BinarySocket.send({
                verify_email: Client.get('email'),
                type: 'payment_withdraw'
            }).then(function (response_withdraw) {
                if ('error' in response_withdraw) {
                    showError('custom_error', response_withdraw.error.message);
                } else {
                    showMessage('check_email_message');
                }
            });
        } else if (!validEmailToken(token)) {
            showError('token_error');
        } else {
            getCashierURL();
        }
    };

    var getCashierType = function getCashierType() {
        var $heading = $(container).find('#heading');
        var action = Url.param('action');
        if (/^(withdraw|deposit)$/.test(action)) {
            cashier_type = action;
            $heading.text(localize(toTitleCase(action)) + ' ' + (Client.get('currency') || ''));
        }
    };

    var populateReq = function populateReq() {
        var req = { cashier: cashier_type };
        if (token) {
            req.verification_code = token;
        }
        if (/epg/.test(window.location.pathname)) req.provider = 'epg';

        return req;
    };

    var getCashierURL = function getCashierURL(bch_has_confirmed) {
        if (!/^BCH/.test(Client.get('currency')) || bch_has_confirmed || Client.get('cashier_confirmed')) {
            BinarySocket.send(populateReq()).then(function (response) {
                return handleCashierResponse(response);
            });
        } else {
            showPopup({
                url: Url.urlFor('cashier/confirmation'),
                popup_id: 'confirm_popup',
                form_id: '#frm_confirm',
                content_id: '#confirm_content',
                validations: [{ selector: '#chk_confirm', validations: [['req', { hide_asterisk: true }]] }],
                additionalFunction: function additionalFunction() {
                    var el_cancel = getElementById('cancel');
                    var el_popup = getElementById('confirm_popup');
                    el_cancel.addEventListener('click', function () {
                        if (el_popup) {
                            el_popup.remove();
                        }
                        BinaryPjax.load(Client.defaultRedirectUrl());
                    });
                },
                onAccept: function onAccept() {
                    Client.set('cashier_confirmed', 1);
                    getCashierURL(1);
                }
            });
        }
    };

    var hideAll = function hideAll(option) {
        $('#frm_withdraw, #frm_ukgc, #errors').setVisibility(0);
        if (option) {
            $(option).setVisibility(0);
        }
    };

    var showError = function showError(id, error) {
        hideAll();
        showMessage(id, error, 'errors');
    };

    var showMessage = function showMessage(id, message) {
        var parent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'messages';

        var $element = $('#' + id);
        if (message) {
            $element.text(message);
        }
        $element.siblings().setVisibility(0).end().setVisibility(1);
        $loading.remove();
        $(container).find('#' + parent).setVisibility(1);
    };

    var showPersonalDetailsError = function showPersonalDetailsError(details) {
        var msg_id = 'personal_details_message';
        var error_fields = void 0;
        if (details) {
            error_fields = {
                province: 'State/Province',
                country: 'Country',
                city: 'Town/City',
                street: 'First line of home address',
                pcode: 'Postal Code / ZIP',
                phone: 'Telephone',
                email: 'Email address'
            };
        }
        var $el = $('#' + msg_id);
        var err_msg = template($el.html(), [localize(details ? error_fields[details] : 'details')]);
        $el.html(err_msg);
        showMessage(msg_id);
    };

    var ukgcResponseHandler = function ukgcResponseHandler(response) {
        if ('error' in response) {
            showError('custom_error', response.error.message);
        } else {
            getCashierURL();
        }
    };

    var initUKGC = function initUKGC() {
        var ukgc_form_id = '#frm_ukgc';
        $loading.remove();
        $(ukgc_form_id).setVisibility(1);
        FormManager.init(ukgc_form_id, [{ request_field: 'ukgc_funds_protection', value: 1 }, { request_field: 'tnc_approval', value: 1 }]);
        FormManager.handleSubmit({
            form_selector: ukgc_form_id,
            fnc_response_handler: ukgcResponseHandler
        });
    };

    var handleCashierResponse = function handleCashierResponse(response) {
        hideAll('#messages');
        var error = response.error;
        if (error) {
            switch (error.code) {
                case 'ASK_EMAIL_VERIFY':
                    checkToken();
                    break;
                case 'ASK_TNC_APPROVAL':
                    showError('tnc_error');
                    break;
                case 'ASK_FIX_DETAILS':
                    showPersonalDetailsError(error.details);
                    break;
                case 'ASK_UK_FUNDS_PROTECTION':
                    initUKGC();
                    break;
                case 'ASK_AUTHENTICATE':
                    showMessage('not_authenticated_message');
                    break;
                case 'ASK_FINANCIAL_RISK_APPROVAL':
                    showError('financial_risk_error');
                    break;
                case 'ASK_JP_KNOWLEDGE_TEST':
                    showError('knowledge_test_error');
                    break;
                case 'JP_NOT_ACTIVATION':
                    showError('activation_error');
                    break;
                case 'ASK_AGE_VERIFICATION':
                    showError('age_error');
                    break;
                case 'ASK_SELF_EXCLUSION_MAX_TURNOVER_SET':
                    showError('limits_error');
                    break;
                default:
                    showError('custom_error', error.message);
            }
        } else {
            if (/^BCH/.test(Client.get('currency'))) {
                getElementById('message_bitcoin_cash').setVisibility(1);
            }

            $iframe = $(container).find('#cashier_iframe');

            if (Currency.isCryptocurrency(Client.get('currency'))) {
                $iframe.height(default_iframe_height);
            } else {
                // Automatically adjust iframe height based on contents
                window.addEventListener('message', setFrameHeight, false);
            }

            $iframe.attr('src', response.cashier).parent().setVisibility(1);

            setTimeout(function () {
                // wait for iframe contents to load before removing loading bar
                $loading.remove();
            }, 1000);
        }
    };

    var setFrameHeight = function setFrameHeight(e) {
        if (!/www\.binary\.com/i.test(e.origin)) {
            $iframe.height(+e.data || default_iframe_height);
        }
    };

    var onLoad = function onLoad() {
        $loading = $('#loading_cashier');
        getCashierType();
        var req_cashier_password = BinarySocket.send({ cashier_password: 1 });
        var req_get_account_status = BinarySocket.send({ get_account_status: 1 });

        Promise.all([req_cashier_password, req_get_account_status]).then(function () {
            // cannot use State.getResponse because we want to check error which is outside of response[msg_type]
            var response_cashier_password = State.get(['response', 'cashier_password']);
            var response_get_account_status = State.get(['response', 'get_account_status']);
            if ('error' in response_cashier_password) {
                showError('custom_error', response_cashier_password.error.code === 'RateLimit' ? localize('You have reached the rate limit of requests per second. Please try later.') : response_cashier_password.error.message);
            } else if (response_cashier_password.cashier_password === 1) {
                showMessage('cashier_locked_message'); // Locked by client
            } else if (!response_get_account_status.error && /cashier_locked/.test(response_get_account_status.get_account_status.status)) {
                showError('custom_error', localize('Your cashier is locked.')); // Locked from BO
            } else {
                var limit = State.getResponse('get_limits.remainder');
                if (cashier_type === 'withdraw' && typeof limit !== 'undefined' && +limit < Currency.getMinWithdrawal(Client.get('currency'))) {
                    showError('custom_error', localize('You have reached the withdrawal limit.'));
                } else {
                    BinarySocket.wait('get_settings').then(function () {
                        init(response_cashier_password.cashier_password);
                    });
                }
            }
        });
    };

    var onUnload = function onUnload() {
        window.removeEventListener('message', setFrameHeight);
    };

    return {
        onLoad: onLoad,
        onUnload: onUnload
    };
}();

module.exports = DepositWithdraw;

/***/ }),
/* 271 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BinaryPjax = __webpack_require__(12);
var Client = __webpack_require__(3);
var BinarySocket = __webpack_require__(5);
var urlForStatic = __webpack_require__(8).urlForStatic;

var PaymentAgentList = function () {
    var $pa_list_container = void 0,
        $agent_template = void 0;

    var onLoad = function onLoad() {
        $(function () {
            $('#accordion').accordion({
                heightStyle: 'content',
                collapsible: true,
                active: false
            });
        });

        $pa_list_container = $('#pa_list');
        $agent_template = $pa_list_container.find('#accordion').html();

        var residence = Client.get('residence');
        if (!residence || residence.length === 0) {
            BinaryPjax.loadPreviousUrl();
            return;
        }

        sendRequest(residence, true);
    };

    var sendRequest = function sendRequest(country) {
        BinarySocket.send({
            paymentagent_list: country,
            currency: Client.get('currency')
        }).then(function (response) {
            if (response.paymentagent_list) {
                populateAgentsList(response.paymentagent_list.list);
            }
        });
    };

    // -----------------------
    // ----- Agents List -----
    // -----------------------
    var populateAgentsList = function populateAgentsList(list) {
        if (!list || list.length === 0) {
            showEmptyListMsg();
            return;
        }

        var $accordion = $('<div/>', { id: 'accordion' });

        list.map(function (agent) {
            var supported_banks = '';
            if (agent.supported_banks && agent.supported_banks.length > 0) {
                var banks = agent.supported_banks.split(',');
                banks.map(function (bank) {
                    supported_banks += bank.length === 0 ? '' : '<img src="' + urlForStatic('images/pages/payment_agent/banks/' + bank.toLowerCase() + '.png') + '" alt="' + bank + '" title="' + bank + '" />';
                });
            }

            $accordion.append($agent_template.replace(/%name/g, agent.name).replace(/%currency/g, agent.currencies).replace(/%minmax/g, agent.min_withdrawal + ' / ' + agent.max_withdrawal).replace(/%summary/g, agent.summary).replace(/%deposit_commission/g, agent.deposit_commission).replace(/%withdrawal_commission/g, agent.withdrawal_commission).replace(/%url/g, agent.url).replace(/%email/g, agent.email).replace(/%telephone/g, agent.telephone).replace(/%further_information/g, agent.further_information).replace(/%supported_banks/g, supported_banks));
        });

        $('.barspinner').setVisibility(0);

        $pa_list_container.empty().append($accordion);

        $('#accordion').accordion({
            heightStyle: 'content',
            collapsible: true,
            active: false
        });
    };

    var showEmptyListMsg = function showEmptyListMsg() {
        $('.barspinner').setVisibility(0);
        $('#no_paymentagent').setVisibility(1);
    };

    return {
        onLoad: onLoad
    };
}();

module.exports = PaymentAgentList;

/***/ }),
/* 272 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Client = __webpack_require__(3);
var BinarySocket = __webpack_require__(5);
var getDecimalPlaces = __webpack_require__(7).getDecimalPlaces;
var getPaWithdrawalLimit = __webpack_require__(7).getPaWithdrawalLimit;
var FormManager = __webpack_require__(18);
var validEmailToken = __webpack_require__(56).validEmailToken;
var localize = __webpack_require__(2).localize;
var getHashValue = __webpack_require__(8).getHashValue;

var PaymentAgentWithdraw = function () {
    var view_ids = {
        error: '#viewError',
        notice: '#viewNotice',
        success: '#viewSuccess',
        confirm: '#viewConfirm',
        form: '#viewForm'
    };
    var field_ids = {
        ddl_agents: '#ddlAgents',
        txt_amount: '#txtAmount',
        txt_desc: '#txtDescription'
    };

    var $views = void 0,
        agent_name = void 0,
        currency = void 0;

    // -----------------------
    // ----- Agents List -----
    // -----------------------
    var populateAgentsList = function populateAgentsList(response) {
        var $ddl_agents = $(field_ids.ddl_agents);
        $ddl_agents.empty();
        var pa_list = (response.paymentagent_list || {}).list;
        if (pa_list.length > 0) {
            checkToken($ddl_agents, pa_list);
        } else {
            showPageError(localize('Payment Agent services are not available in your country or in your preferred currency.'));
        }
    };

    var checkToken = function checkToken($ddl_agents, pa_list) {
        var token = getHashValue('token');
        if (!token) {
            BinarySocket.send({ verify_email: Client.get('email'), type: 'paymentagent_withdraw' });
            setActiveView(view_ids.notice);
        } else if (!validEmailToken(token)) {
            showPageError('token_error');
        } else {
            insertListOption($ddl_agents, localize('Please select a payment agent'), '');
            for (var i = 0; i < pa_list.length; i++) {
                insertListOption($ddl_agents, pa_list[i].name, pa_list[i].paymentagent_loginid);
            }
            setActiveView(view_ids.form);

            var form_id = '#' + $(view_ids.form).find('form').attr('id');
            var min = getPaWithdrawalLimit(currency, 'min');
            var max = getPaWithdrawalLimit(currency, 'max');

            $(form_id).find('label[for="txtAmount"]').text(localize('Amount') + ' ' + currency);
            FormManager.init(form_id, [{ selector: field_ids.ddl_agents, validations: ['req'], request_field: 'paymentagent_loginid' }, { selector: field_ids.txt_amount, validations: ['req', ['number', { type: 'float', decimals: getDecimalPlaces(currency), min: min, max: max }], ['custom', { func: function func() {
                        return +Client.get('balance') >= +$(field_ids.txt_amount).val();
                    }, message: localize('Insufficient balance.') }]], request_field: 'amount' }, { selector: field_ids.txt_desc, validations: ['general'], request_field: 'description' }, { request_field: 'currency', value: currency }, { request_field: 'paymentagent_withdraw', value: 1 }, { request_field: 'dry_run', value: 1 }], true);

            FormManager.handleSubmit({
                form_selector: form_id,
                fnc_response_handler: withdrawResponse,
                fnc_additional_check: setAgentName,
                enable_button: true
            });
        }
    };

    var insertListOption = function insertListOption($ddl_object, item_text, item_value) {
        $ddl_object.append($('<option/>', { value: item_value, text: item_text }));
    };

    // ----------------------------
    // ----- Withdraw Process -----
    // ----------------------------
    var withdrawResponse = function withdrawResponse(response) {
        var request = response.echo_req;
        switch (response.paymentagent_withdraw) {
            case 2:
                {
                    // dry_run success: showing the confirmation page
                    setActiveView(view_ids.confirm);

                    $('#lblAgentName').text(agent_name);
                    $('#lblCurrency').text(request.currency);
                    $('#lblAmount').text(request.amount);

                    FormManager.init(view_ids.confirm, [{ request_field: 'paymentagent_loginid', value: request.paymentagent_loginid }, { request_field: 'amount', value: request.amount }, { request_field: 'description', value: request.description }, { request_field: 'currency', value: request.currency }, { request_field: 'paymentagent_withdraw', value: 1 }], true);

                    FormManager.handleSubmit({
                        form_selector: view_ids.confirm,
                        fnc_response_handler: withdrawResponse
                    });

                    $(view_ids.confirm + ' #btnBack').click(function () {
                        setActiveView(view_ids.form);
                    });
                    break;
                }
            case 1:
                // withdrawal success
                setActiveView(view_ids.success);
                $('#successMessage').css('display', '').attr('class', 'success-msg').html($('<ul/>', { class: 'checked' }).append($('<li/>', { text: localize('Your request to withdraw [_1] [_2] from your account [_3] to Payment Agent [_4] account has been successfully processed.', [request.currency, request.amount, Client.get('loginid'), agent_name]) })));
                break;

            default:
                // error
                if (response.echo_req.dry_run === 1) {
                    setActiveView(view_ids.form);
                    $('#formMessage').setVisibility(1).html(response.error.message);
                } else if (response.error.code === 'InvalidToken') {
                    showPageError(localize('Your token has expired or is invalid. Please click [_1]here[_2] to restart the verification process.', ['<a href="javascript:;" onclick="var url = location.href.split(\'#\')[0]; window.history.replaceState({ url }, document.title, url); window.location.reload();">', '</a>']));
                } else {
                    showPageError(response.error.message);
                }
                break;
        }
    };

    // -----------------------------
    // ----- Message Functions -----
    // -----------------------------
    var showPageError = function showPageError(err_msg, id) {
        var $error = $(view_ids.error);
        $error.find(' > p').setVisibility(0);
        if (id) {
            $error.find('#' + id).setVisibility(1);
        } else {
            $error.find('#custom-error').html(err_msg).setVisibility(1);
        }
        setActiveView(view_ids.error);
    };

    // ----- View Control -----
    var setActiveView = function setActiveView(view_id) {
        $views.setVisibility(0);
        $(view_id).setVisibility(1);
    };

    var onLoad = function onLoad() {
        BinarySocket.wait('get_account_status').then(function (data) {
            $views = $('#paymentagent_withdrawal').find('.viewItem');
            $views.setVisibility(0);

            if (/(withdrawal|cashier)_locked/.test(data.get_account_status.status)) {
                showPageError('', 'withdrawal-locked-error');
            } else {
                currency = Client.get('currency');
                BinarySocket.send({
                    paymentagent_list: Client.get('residence'),
                    currency: currency
                }).then(function (response) {
                    return populateAgentsList(response);
                });
            }
        });
    };

    var setAgentName = function setAgentName() {
        agent_name = $(field_ids.ddl_agents).find('option:selected').text();
        return true;
    };

    return {
        onLoad: onLoad
    };
}();

module.exports = PaymentAgentWithdraw;

/***/ }),
/* 273 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var getAppId = __webpack_require__(51).getAppId;
var getSocketURL = __webpack_require__(51).getSocketURL;

var Endpoint = function () {
    var onLoad = function onLoad() {
        var $server_url = $('#server_url');
        var $app_id = $('#app_id');
        $server_url.val(getSocketURL().split('/')[2]);
        $app_id.val(getAppId());

        $('#frm_endpoint').on('submit', function (e) {
            e.preventDefault();
            var server_url = $server_url.val().trim().toLowerCase();
            var app_id = $app_id.val().trim();
            if (server_url) localStorage.setItem('config.server_url', server_url);
            if (app_id && !isNaN(app_id)) localStorage.setItem('config.app_id', parseInt(app_id));
            window.location.reload();
        });

        $('#reset_endpoint').on('click', function () {
            localStorage.removeItem('config.server_url');
            localStorage.removeItem('config.app_id');
            window.location.reload();
        });
    };

    return {
        onLoad: onLoad
    };
}();

module.exports = Endpoint;

/***/ }),
/* 274 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var MBContract = __webpack_require__(77);
var MBDefaults = __webpack_require__(36);
var isJPClient = __webpack_require__(3).isJPClient;
var formatCurrency = __webpack_require__(7).formatCurrency;
var localize = __webpack_require__(2).localize;
var State = __webpack_require__(6).State;

/*
 * Handles currency display
 *
 * It process 'socket.send({payout_currencies:1})` response
 * and display them
 */
var MBDisplayCurrencies = function MBDisplayCurrencies() {
    var $currency = $('.trade_form #currency');
    var $list = $currency.find('.list');
    var $current = $currency.find('.current');
    var currencies = State.getResponse('payout_currencies');
    var is_jp_client = isJPClient();
    var def_value = void 0;

    if (!$currency.length) return;
    $list.empty();
    if (!is_jp_client) {
        var def_curr = MBDefaults.get('currency');
        def_value = def_curr && currencies.indexOf(def_curr) >= 0 ? def_curr : currencies[0];
        if (currencies.length > 1) {
            currencies.forEach(function (currency) {
                $list.append($('<div/>', { value: currency, html: formatCurrency(currency) }));
                if (def_value === currency) {
                    MBContract.setCurrentItem($currency, currency);
                }
            });
        }
        $current.html($('<span/>', { class: 'nav-caret' })).append(formatCurrency(def_value));
    } else {
        def_value = 'JPY';
        $current.html($('<span/>', { text: localize('Lots'), 'data-balloon': localize('Payout per lot = 1,000') }));
    }
    $currency.attr('value', def_value);
    MBDefaults.set('currency', def_value);
    // if there is no currency drop down, remove hover style from currency
    if (!$list.children().length) {
        if (!is_jp_client) {
            $currency.removeClass('gr-5').addClass('gr-3').siblings('#payout').removeClass('gr-7').addClass('gr-9');
        }
        $current.css({ 'background-color': 'white', 'border-right': 'none' }).hover(function () {
            $(this).css({ 'background-color': 'white', cursor: 'auto' });
        }).off('click').find('.nav-caret').addClass('invisible').end().find('.symbols:before').css({ 'margin-right': '2px' });
    }
};

module.exports = MBDisplayCurrencies;

/***/ }),
/* 275 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var MBContract = __webpack_require__(77);
var MBDefaults = __webpack_require__(36);
var MBNotifications = __webpack_require__(97);
var MBPrice = __webpack_require__(122);
var MBProcess = __webpack_require__(173);
var MBTick = __webpack_require__(123);
var MBSymbols = __webpack_require__(174);
var TradingAnalysis = __webpack_require__(88);
var debounce = __webpack_require__(31).debounce;
var Client = __webpack_require__(3);
var Currency = __webpack_require__(7);
var onlyNumericOnKeypress = __webpack_require__(169);
var localize = __webpack_require__(2).localize;
var State = __webpack_require__(6).State;
var getPropertyValue = __webpack_require__(1).getPropertyValue;

/*
 * TradingEvents object contains all the event handler function required for
 * websocket trading page
 *
 * We need it as object so that we can call TradingEvent.init() only on trading
 * page for pjax to work else it will fire on all pages
 *
 */
var MBTradingEvents = function () {
    var $form = void 0,
        hidden_class = void 0,
        border_class = void 0;

    var initiate = function initiate() {
        $form = $('.trade_form');
        hidden_class = 'invisible';
        border_class = 'primary-border-color';

        var is_jp_client = Client.isJPClient();

        $(document).on('click', function (e) {
            if ($(e.target).parents('#payout_list').length) return;
            makeListsInvisible();
        });

        $form.find('.current, .header-current').on('click', function (e) {
            e.stopPropagation();
            var $this = $(this);
            var $list = $this.siblings('.list');
            if (!$list.length) {
                $list = $this.siblings().find('.list'); // in case of .header-current
            }
            if ($list.hasClass(hidden_class)) {
                makeListsInvisible();
            }
            $list.toggleClass(hidden_class);
            $this.toggleClass(border_class).siblings().find('.current').toggleClass(border_class).end().end().parent().siblings('.header-current').toggleClass(border_class);
        });

        /*
         * attach event to underlying change, event need to request new contract details and price
         */
        var $underlying = $form.find('#underlying');
        if ($underlying.length) {
            $underlying.on('click', '.list > div', function () {
                var underlying = $(this).attr('value');
                MBContract.setCurrentItem($underlying, underlying, 1);
                MBDefaults.set('underlying', underlying);
                MBNotifications.hide('SYMBOL_INACTIVE');

                MBTick.clean();

                MBProcess.getContracts(underlying);
                // forget the old tick id i.e. close the old tick stream
                MBProcess.processForgetTicks().then(function () {
                    // get ticks for current underlying
                    MBTick.request(underlying);
                });
            });
        }

        var $category = $form.find('#category');
        if ($category.length) {
            $category.on('click', '.list > div', function () {
                var category = $(this).attr('value');
                MBContract.setCurrentItem($category, category);
                MBDefaults.set('category', category);
                MBContract.populatePeriods(1);
                MBProcess.processPriceRequest();
                TradingAnalysis.request();
            });
        }

        var $period = $form.find('#period');
        if ($period.length) {
            $period.on('click', '.list > div', function () {
                var period = $(this).attr('value');
                MBContract.setCurrentItem($period, period);
                MBDefaults.set('period', period);
                MBProcess.processPriceRequest();
                $('.remaining-time').removeClass('alert');
                MBContract.displayRemainingTime(true, is_jp_client);
            });
            if (!is_jp_client) {
                var $header_cur = $form.find('.header-current');
                $period.on('mouseover', function (e) {
                    e.stopPropagation();
                    $header_cur.addClass(border_class);
                }).on('mouseleave', function (e) {
                    e.stopPropagation();
                    if ($period.find('.list').hasClass(hidden_class)) {
                        $header_cur.removeClass(border_class);
                    }
                });
            }
        }

        var validatePayout = function validatePayout(payout_amount, $error_wrapper) {
            var market = getPropertyValue(MBSymbols.getAllSymbols(), [MBDefaults.get('underlying'), 'market']);
            if (!market) return false;

            var selected_currency = MBDefaults.get('currency');
            var max_client_amount = State.getResponse('landing_company.financial_company.currency_config.' + market + '.' + selected_currency + '.max_payout') || 5000;

            var is_valid = true;
            var error_msg = '';

            if (!payout_amount || isNaN(payout_amount)) {
                is_valid = false;
                error_msg = localize('Should be a valid number.');
            } else if (+payout_amount > max_client_amount) {
                is_valid = false;
                error_msg = localize('Should be less than [_1]', [max_client_amount]);
            }

            // if value has decimal places
            if (is_valid && +payout_amount % 1 !== 0) {
                var allowed_decimals = Currency.getDecimalPlaces(MBDefaults.get('currency'));

                // verify number of decimal places doesn't exceed the allowed decimal places according to the currency
                is_valid = payout_amount.toString().replace(/^-?\d*\.?|0+$/, '').length <= allowed_decimals;
                if (!is_valid) {
                    error_msg = localize('Up to [_1] decimal places are allowed.', [allowed_decimals]);
                }
            }

            if (!is_valid && $error_wrapper && error_msg) {
                var $err_payout = $('#err_payout');
                if ($err_payout.length) {
                    $err_payout.text(error_msg);
                } else {
                    $error_wrapper.append($('<p/>', { class: 'error-msg gr-row', id: 'err_payout', text: error_msg }));
                }
            }

            return is_valid;
        };

        var $payout = $form.find('#payout');
        if ($payout.length) {
            var $payout_list = $form.find('#payout_list');

            var appendActualPayout = function appendActualPayout(payout) {
                $payout.find('.current').append($('<div/>', { class: 'hint', text: localize('Payout') }).append($('<span/>', { id: 'actual_payout', html: Currency.formatMoney('JPY', payout * 1000) })));
            };

            var client_currency = Client.get('currency') || MBDefaults.get('currency');
            var is_crypto = Currency.isCryptocurrency(client_currency);
            var old_value = Currency.getMinPayout(client_currency);
            if (!$payout.attr('value')) {
                var amount = 'payout' + (is_crypto ? '_crypto' : '');
                var payout_def = MBDefaults.get(amount);
                if (!validatePayout(payout_def)) {
                    payout_def = old_value;
                }
                $payout.value = payout_def;
                MBDefaults.set(amount, payout_def);
                $payout.attr('value', payout_def);
                if (is_jp_client) {
                    $payout.find('.current').html(payout_def);
                    appendActualPayout(payout_def);
                }
            }
            if (is_jp_client) {
                $payout.find('.current').on('click', function () {
                    old_value = +this.childNodes[0].nodeValue;
                    var $list = $('#' + $(this).parent().attr('id') + '_list');
                    var $sublist = $list.find('.list');
                    if ($list.hasClass(hidden_class)) {
                        makeListsInvisible();
                    }
                    $list.toggleClass(hidden_class);
                    $sublist.toggleClass(hidden_class);
                    $category.toggleClass(hidden_class);
                    $period.toggleClass(hidden_class);
                });
            } else {
                var $panel = $('#panel');
                $payout.on('click', function () {
                    $(this).select();
                }).on('keypress', onlyNumericOnKeypress).on('input', debounce(function (e) {
                    var payout = e.target.value;
                    var currency = MBDefaults.get('currency');
                    if (validatePayout(payout, $panel)) {
                        $panel.find('#err_payout').remove();
                        $payout.removeClass('error');
                        e.target.setAttribute('value', payout);
                        MBDefaults.set('payout' + (Currency.isCryptocurrency(currency) ? '_crypto' : ''), payout);
                        MBProcess.processPriceRequest();
                    } else {
                        $payout.addClass('error');
                        MBPrice.showPriceOverlay();
                    }
                }));
            }
            if ($payout_list.length) {
                $payout_list.on('click', '> .list > div', debounce(function () {
                    var payout = +MBDefaults.get('payout' + (Currency.isCryptocurrency(MBDefaults.get('currency')) ? '_crypto' : ''));
                    var value = $(this).attr('value');
                    var new_payout = void 0;
                    if (/\+|-/.test(value)) {
                        new_payout = payout + parseInt(value);
                        if (new_payout < 1 && is_jp_client) {
                            new_payout = 1;
                        }
                    } else if (/ok|cancel/.test(value)) {
                        if (value === 'cancel') new_payout = old_value || 10;
                        makeListsInvisible();
                    } else {
                        new_payout = value;
                    }

                    if (validatePayout(new_payout)) {
                        $('.price-table').setVisibility(1);
                        MBDefaults.set('payout', new_payout);
                        $payout.attr('value', new_payout).find('.current').html(new_payout);
                        if (is_jp_client) {
                            appendActualPayout(new_payout);
                        }
                        MBProcess.processPriceRequest();
                    }
                }));
                $payout_list.find('div[unselectable]').on('selectstart mousedown', function () {
                    return false;
                });
            }
        }

        var $currency = $form.find('#currency');
        if ($currency.length) {
            $currency.on('click', '.list > div', function () {
                var currency = $(this).attr('value');
                MBContract.setCurrentItem($currency, currency);
                MBDefaults.set('currency', currency);
                if (is_jp_client) {
                    MBProcess.processPriceRequest();
                } else {
                    var _is_crypto = Currency.isCryptocurrency(currency);
                    var _amount = MBDefaults.get('payout' + (_is_crypto ? '_crypto' : ''));
                    if (!_amount) {
                        _amount = Currency.getMinPayout(currency);
                        MBDefaults.set('payout' + (_is_crypto ? '_crypto' : ''), _amount);
                    }
                    $payout.val(_amount).attr('value', _amount).trigger('input'); // payout will call processPriceRequest
                }
            });
        }

        var $trading_status = $('.trading-status');
        var $allow_trading = $trading_status.find('#allow');
        var $disallow_trading = $trading_status.find('#disallow');
        var setTradingStatus = function setTradingStatus(is_enabled) {
            if (is_enabled) {
                MBPrice.hidePriceOverlay();
                MBNotifications.hide('TRADING_DISABLED');
                $disallow_trading.removeClass('selected');
                $allow_trading.addClass('selected');
            } else {
                MBPrice.showPriceOverlay();
                $allow_trading.removeClass('selected');
                $disallow_trading.addClass('selected');
            }
        };
        if ($trading_status.length) {
            setTradingStatus(0);
            $trading_status.on('click', function (e) {
                var status = e.target.getAttribute('id');
                MBDefaults.set('disable_trading', status === 'disallow');
                setTradingStatus(status === 'allow');
            });
        }
    };

    var makeListsInvisible = function makeListsInvisible() {
        $form.find('.list, #payout_list').setVisibility(0).end().find('#period, #category').setVisibility(1);
        $form.find('.current, .header-current').removeClass(border_class);
    };

    return {
        init: initiate
    };
}();

module.exports = MBTradingEvents;

/***/ }),
/* 276 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var MBContract = __webpack_require__(77);
var MBDisplayCurrencies = __webpack_require__(274);
var MBDefaults = __webpack_require__(36);
var MBTradingEvents = __webpack_require__(275);
var MBPrice = __webpack_require__(122);
var MBProcess = __webpack_require__(173);
var cleanupChart = __webpack_require__(89).cleanupChart;
var BinaryPjax = __webpack_require__(12);
var Client = __webpack_require__(3);
var BinarySocket = __webpack_require__(5);
var getDecimalPlaces = __webpack_require__(7).getDecimalPlaces;
var JapanPortfolio = __webpack_require__(172);
var getElementById = __webpack_require__(4).getElementById;
var getLanguage = __webpack_require__(16).get;
var localize = __webpack_require__(2).localize;
var State = __webpack_require__(6).State;
var urlFor = __webpack_require__(8).urlFor;
var findParent = __webpack_require__(1).findParent;

var MBTradePage = function () {
    var events_initialized = 0;
    State.remove('is_mb_trading');

    var onLoad = function onLoad() {
        State.set('is_mb_trading', true);
        BinarySocket.wait('authorize').then(init);
        if (!Client.isLoggedIn()) {
            BinarySocket.wait('website_status').then(function () {
                BinarySocket.send({ landing_company: State.getResponse('website_status.clients_country') });
            });
        }
    };

    var init = function init() {
        if (/^(malta|iom)$/.test(Client.get('landing_company_shortcode'))) {
            if (getLanguage() === 'JA') {
                $('#content').empty().html($('<div/>', { class: 'container' }).append($('<p/>', { class: 'notice-msg center-text', text: localize('This page is not available in the selected language.') })));
            } else {
                BinaryPjax.load(urlFor('trading'));
            }
            return;
        }
        if (Client.isJPClient()) {
            disableTrading();
            $('#panel').remove();
        } else {
            MBDefaults.set('disable_trading', 0);
            $('#ja-panel').remove();
            showCurrency(Client.get('currency'));
        }

        BinarySocket.wait('landing_company', 'active_symbols').then(function () {
            if (events_initialized === 0) {
                events_initialized = 1;
                MBTradingEvents.init();
            }
        });

        BinarySocket.send({ payout_currencies: 1 }).then(function () {
            MBDisplayCurrencies();
            MBProcess.getSymbols();
        });

        State.set('is_chart_allowed', true);
        State.set('ViewPopup.onDisplayed', MBPrice.hidePriceOverlay);
        $('.container').css('max-width', '1200px');
    };

    var showCurrency = function showCurrency(currency) {
        if (currency) {
            var el_payout_amount = getElementById('payout_amount');
            if (!new RegExp(currency).test(el_payout_amount.textContent)) {
                el_payout_amount.textContent += ' (' + currency + ')';
            }

            if (getDecimalPlaces(currency) > 2) {
                var el_category = getElementById('category');
                var payout_wrapper = findParent(el_payout_amount, '.gr-3');
                var category_wrapper = findParent(el_category, '.gr-9');
                if (payout_wrapper && category_wrapper) {
                    payout_wrapper.classList.remove('gr-3');
                    category_wrapper.classList.remove('gr-9');
                    payout_wrapper.classList.add('gr-4');
                    category_wrapper.classList.add('gr-8');
                }
            }
        }
    };

    var disableTrading = function disableTrading() {
        MBDefaults.set('disable_trading', 1);
        $('#allow').removeClass('selected');
        $('#disallow').addClass('selected');
    };

    var reload = function reload() {
        window.location.reload();
    };

    var onUnload = function onUnload() {
        cleanupChart();
        State.set('is_chart_allowed', false);
        JapanPortfolio.hide();
        State.remove('is_mb_trading');
        events_initialized = 0;
        MBContract.onUnload();
        MBPrice.onUnload();
        MBProcess.onUnload();
        BinarySocket.clear('active_symbols');
        State.remove('ViewPopup.onDisplayed');
        $('.container').css('max-width', '');
    };

    var onDisconnect = function onDisconnect() {
        MBPrice.showPriceOverlay();
        cleanupChart();
        onLoad();
    };

    return {
        onLoad: onLoad,
        reload: reload,
        onUnload: onUnload,
        onDisconnect: onDisconnect
    };
}();

module.exports = MBTradePage;

/***/ }),
/* 277 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var AssetIndex = function () {
    var market_columns = void 0;

    // Search and Remove (to decrease the next search count)
    var getSymbolInfo = function getSymbolInfo(q_symbol, active_symbols) {
        return active_symbols.filter(function (sy, id) {
            if (sy.symbol === q_symbol) {
                active_symbols.splice(id, 1);
                return true;
            }
            return false;
        });
    };

    /*
     * This method generates headers for all tables of each market
     * should include headers existed in all assets of each market and its submarkets
     */
    var getAssetIndexData = function getAssetIndexData(asset_index, active_symbols) {
        if (!asset_index || !active_symbols) return null;

        market_columns = {};

        // index of items in asset_index response
        var idx = {
            symbol: 0,
            display_name: 1,
            cells: 2,
            sym_info: 3,
            values: 4,
            cell_props: {
                cell_name: 0,
                cell_display_name: 1,
                cell_from: 2,
                cell_to: 3
            }
        };

        for (var i = 0; i < asset_index.length; i++) {
            var asset_item = asset_index[i];
            var symbol_info = getSymbolInfo(asset_item[idx.symbol], active_symbols)[0];
            if (symbol_info) {
                var market = symbol_info.market;

                asset_item.push(symbol_info);

                // Generate market columns to use in all this market's submarket tables
                if (!(market in market_columns)) {
                    market_columns[market] = {
                        header: [''],
                        columns: ['']
                    };
                }

                var asset_cells = asset_item[idx.cells];
                var values = {};
                for (var j = 0; j < asset_cells.length; j++) {
                    var col = asset_cells[j][idx.cell_props.cell_display_name];

                    values[col] = [asset_cells[j][idx.cell_props.cell_from], asset_cells[j][idx.cell_props.cell_to]].join(' - ');

                    var market_cols = market_columns[market];
                    if (market_cols.columns.indexOf(col) === -1) {
                        market_cols.header.push(asset_cells[j][idx.cell_props.cell_display_name]);
                        market_cols.columns.push(col);
                    }
                }
                asset_item.push(values);
            }
        }
        return asset_index;
    };

    return {
        getAssetIndexData: getAssetIndexData,
        getMarketColumns: function getMarketColumns() {
            return market_columns;
        }
    };
}();

module.exports = AssetIndex;

/***/ }),
/* 278 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var AssetIndex = __webpack_require__(277);
var BinaryPjax = __webpack_require__(12);
var isJPClient = __webpack_require__(3).isJPClient;
var BinarySocket = __webpack_require__(5);
var Table = __webpack_require__(76);
var showLoadingImage = __webpack_require__(1).showLoadingImage;

var AssetIndexUI = function () {
    var $container = void 0,
        $tabs = void 0,
        $contents = void 0,
        active_symbols = void 0,
        asset_index = void 0,
        market_columns = void 0;

    var onLoad = function onLoad() {
        if (isJPClient()) {
            BinaryPjax.loadPreviousUrl();
            return;
        }

        $container = $('#asset-index');
        asset_index = market_columns = undefined;
        active_symbols = undefined;

        if ($container.contents().length) return;

        showLoadingImage($container[0]);

        if (!asset_index) {
            sendRequest();
        }
        $container.tabs();
    };

    var populateTable = function populateTable() {
        if (!active_symbols || !asset_index) return;

        $('#errorMsg').setVisibility(0);
        asset_index = AssetIndex.getAssetIndexData(asset_index, active_symbols);
        market_columns = AssetIndex.getMarketColumns();
        $tabs = $('<ul/>');
        $contents = $('<div/>');

        for (var i = 0; i < asset_index.length; i++) {
            var asset_item = asset_index[i];
            var symbol_info = asset_item[3];
            if (symbol_info) {
                var $submarket_table = getSubmarketTable(asset_item, symbol_info);
                $submarket_table.find('tbody').append(createSubmarketTableRow(asset_item, symbol_info));
            }
        }

        $container.empty().append($tabs).append($contents.children());

        if ($container.is(':ui-tabs')) {
            $container.tabs('destroy');
        }
        $container.tabs();
    };

    var getSubmarketTable = function getSubmarketTable(asset_item, symbol_info) {
        var market_id = 'market-' + symbol_info.market;
        var submarket_id = 'submarket-' + symbol_info.submarket;

        var $table = $contents.find('#' + submarket_id);
        if ($table.length === 0) {
            // Create the table for this submarket
            var $market = $contents.find('#' + market_id);
            if ($market.length === 0) {
                // Create the market and tab elements
                $market = $('<div/>', { id: market_id });
                $tabs.append($('<li/>').append($('<a/>', { href: '#' + market_id, text: symbol_info.market_display_name, id: 'outline' })));
            }
            $table = createEmptyTable(asset_item, symbol_info, submarket_id);
            $market.append($table);
            $contents.append($market);
        }

        return $table;
    };

    var createSubmarketTableRow = function createSubmarketTableRow(asset_item, symbol_info) {
        var cells = [symbol_info.display_name];
        var columns = ['asset'];

        var market_cols = market_columns[symbol_info.market];
        var asset_cells = asset_item[4];
        for (var i = 1; i < market_cols.columns.length; i++) {
            var prop = market_cols.columns[i];
            if (prop.length > 0) {
                cells.push(prop in asset_cells ? asset_cells[prop] : '--');
                columns.push(prop);
            }
        }

        return Table.createFlexTableRow(cells, columns, 'data');
    };

    var createEmptyTable = function createEmptyTable(asset_item, symbol_info, submarket_id) {
        var market = symbol_info.market;

        var metadata = {
            id: submarket_id,
            cols: market_columns[market].columns
        };

        var $submarket_table = Table.createFlexTable([], metadata, market_columns[market].header);

        var $submarket_header = $('<tr/>', { class: 'flex-tr' }).append($('<th/>', { class: 'flex-tr-child submarket-name', colspan: market_columns[market].columns.length, text: symbol_info.submarket_display_name }));
        $submarket_table.find('thead').prepend($submarket_header);

        return $submarket_table;
    };

    var sendRequest = function sendRequest() {
        if (!active_symbols) {
            BinarySocket.wait('authorize').then(function () {
                BinarySocket.send({ active_symbols: 'brief' }).then(function (response) {
                    AssetIndexUI.setActiveSymbols(response);
                });
            });
        }
        BinarySocket.send({ asset_index: 1 }).then(function (response) {
            asset_index = response.asset_index;
            if (active_symbols) populateTable();
        });
    };

    return {
        onLoad: onLoad,
        setActiveSymbols: function setActiveSymbols(response) {
            active_symbols = response.active_symbols.slice(0); // clone
            if (asset_index) populateTable();
        }
    };
}();

module.exports = AssetIndexUI;

/***/ }),
/* 279 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var loadScript = __webpack_require__(229);
var getLanguage = __webpack_require__(16).get;

var EconomicCalendar = function () {
    var is_loaded = void 0;

    var onLoad = function onLoad() {

        var curr_language = getLanguage().toLowerCase();

        if (!is_loaded) {
            loadScript.get('https://c.mql5.com/js/widgets/calendar/widget.v3.js', function () {
                populateCalendar(curr_language);
                is_loaded = true;
            });
        } else {
            populateCalendar(curr_language);
        }
    };

    var populateCalendar = function populateCalendar(lang) {
        new economicCalendar({ width: '100%', height: '500px', mode: 2, lang: lang }); // eslint-disable-line new-cap, no-new, no-undef
        var loader = $('#economicCalendarWidget').find('.barspinner');
        if (loader) loader.remove();
    };

    return {
        onLoad: onLoad
    };
}();

module.exports = EconomicCalendar;

/***/ }),
/* 280 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var TradingTimes = function () {
    var getSubmarketInfo = function getSubmarketInfo(active_symbols, submarket_display_name) {
        return active_symbols.filter(function (sy) {
            return sy.submarket_display_name === submarket_display_name;
        });
    };

    var getSymbolInfo = function getSymbolInfo(q_symbol, active_symbols) {
        return active_symbols.filter(function (sy) {
            return sy.symbol === q_symbol;
        });
    };

    return {
        getSubmarketInfo: getSubmarketInfo,
        getSymbolInfo: getSymbolInfo
    };
}();

module.exports = TradingTimes;

/***/ }),
/* 281 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var moment = __webpack_require__(9);
var TradingTimes = __webpack_require__(280);
var isJPClient = __webpack_require__(3).isJPClient;
var BinarySocket = __webpack_require__(5);
var Table = __webpack_require__(76);
var DatePicker = __webpack_require__(87);
var dateValueChanged = __webpack_require__(4).dateValueChanged;
var localize = __webpack_require__(2).localize;
var showLoadingImage = __webpack_require__(1).showLoadingImage;
var toISOFormat = __webpack_require__(17).toISOFormat;

var TradingTimesUI = function () {
    var $date = void 0,
        $container = void 0,
        columns = void 0,
        active_symbols = void 0,
        trading_times = void 0;

    var onLoad = function onLoad() {
        $date = $('#trading-date');
        $container = $('#trading-times');
        columns = ['Asset', 'Opens', 'Closes', 'Settles', 'UpcomingEvents'];
        active_symbols = trading_times = undefined;

        if ($container.contents().length) return;

        showLoadingImage($container[0]);

        if (!trading_times) {
            sendRequest('today', !(active_symbols && active_symbols.length));
        }

        var date = moment.utc();
        $date.attr('data-value', toISOFormat(date));
        DatePicker.init({
            selector: '#trading-date',
            minDate: 0,
            maxDate: 364
        });
        $date.val(localize('Today'));
        $date.change(function () {
            if (!dateValueChanged(this, 'date')) {
                return false;
            }
            $container.empty();
            showLoadingImage($container[0]);
            trading_times = null;
            sendRequest($date.attr('data-value'), !active_symbols);
            return true;
        });

        $container.tabs();
    };

    var populateTable = function populateTable() {
        if (!active_symbols || !trading_times) return;

        $('#errorMsg').setVisibility(0);

        var is_japan_trading = isJPClient();

        var markets = trading_times.markets;

        var $ul = $('<ul/>', { class: is_japan_trading ? 'invisible' : '' });
        var $contents = $('<div/>');

        for (var m = 0; m < markets.length; m++) {
            var tab_id = 'market_' + (m + 1);

            // contents
            var $market = $('<div/>', { id: tab_id });
            $market.append(createMarketTables(markets[m], is_japan_trading));
            if ($market.find('table tr').length) {
                $contents.append($market);

                // tabs
                if (!is_japan_trading) {
                    $ul.append($('<li/>').append($('<a/>', { href: '#' + tab_id, text: markets[m].name, id: 'outline' })));
                }
            }
        }

        $container.empty().append($ul).append($contents.children());

        if ($container.is(':ui-tabs')) {
            $container.tabs('destroy');
        }
        $container.tabs();
    };

    var createMarketTables = function createMarketTables(market, is_japan_trading) {
        var $market_tables = $('<div/>');

        // submarkets of this market
        var submarkets = market.submarkets;
        var should_populate = void 0;
        for (var s = 0; s < submarkets.length; s++) {
            should_populate = true;
            // display only "Major Pairs" for Japan
            if (is_japan_trading) {
                var submarket_info = TradingTimes.getSubmarketInfo(active_symbols, submarkets[s].name);
                if (submarket_info.length === 0 || submarket_info[0].submarket !== 'major_pairs') {
                    should_populate = false;
                }
            }

            if (should_populate) {
                // submarket table
                var $submarket_table = createEmptyTable(market.name + '-' + s);

                // submarket name
                $submarket_table.find('thead').prepend(createSubmarketHeader(submarkets[s].name)).find('th.opens, th.closes').addClass('nowrap');

                // symbols of this submarket
                var symbols = submarkets[s].symbols;
                for (var sy = 0; sy < symbols.length; sy++) {
                    if (Object.keys(TradingTimes.getSymbolInfo(symbols[sy].symbol, active_symbols)).length !== 0) {
                        $submarket_table.find('tbody').append(createSubmarketTableRow(market.name, submarkets[s].name, symbols[sy]));
                    }
                }

                if ($submarket_table.find('tbody tr').length) {
                    $market_tables.append($submarket_table);
                }
            }
        }

        return $market_tables;
    };

    var createSubmarketHeader = function createSubmarketHeader(submarket_name) {
        return $('<tr/>', { class: 'flex-tr' }).append($('<th/>', { class: 'flex-tr-child submarket-name', colspan: columns.length, text: submarket_name }));
    };

    var createSubmarketTableRow = function createSubmarketTableRow(market_name, submarket_name, symbol) {
        var $table_row = Table.createFlexTableRow([symbol.name, '', // Opens
        '', // Closes
        symbol.times.settlement, ''], columns, 'data');
        $table_row.children('.opens').html(symbol.times.open.join('<br />'));
        $table_row.children('.closes').html(symbol.times.close.join('<br />'));
        $table_row.children('.upcomingevents').html(createEventsText(symbol.events));

        return $table_row;
    };

    var createEventsText = function createEventsText(events) {
        var result = '';
        for (var i = 0; i < events.length; i++) {
            result += '' + (i > 0 ? '<br />' : '') + localize(events[i].descrip) + ': ' + localize(events[i].dates);
        }
        return result.length > 0 ? result : '--';
    };

    var createEmptyTable = function createEmptyTable(table_id) {
        var header = [localize('Asset'), localize('Opens'), localize('Closes'), localize('Settles'), localize('Upcoming Events')];

        var metadata = {
            id: table_id,
            cols: columns
        };

        return Table.createFlexTable([], metadata, header);
    };

    var sendRequest = function sendRequest(date, should_request_active_symbols) {
        var req = { active_symbols: 'brief' };
        if (isJPClient()) {
            req.landing_company = 'japan';
        }
        if (should_request_active_symbols) {
            BinarySocket.wait('authorize').then(function () {
                BinarySocket.send(req, { msg_type: 'active_symbols' }).then(function (response) {
                    TradingTimesUI.setActiveSymbols(response);
                });
            });
        }
        BinarySocket.send({ trading_times: date || 'today' }).then(function (response) {
            trading_times = response.trading_times;
            if (active_symbols) populateTable();
        });
    };

    return {
        onLoad: onLoad,
        setActiveSymbols: function setActiveSymbols(response) {
            active_symbols = response.active_symbols.slice(0); // clone
            if (trading_times) populateTable();
        }
    };
}();

module.exports = TradingTimesUI;

/***/ }),
/* 282 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var CreateDropdown = __webpack_require__(25).selectDropdown;
var getHighstock = __webpack_require__(31).requireHighstock;
var Symbols = __webpack_require__(79);
var BinarySocket = __webpack_require__(5);
var localize = __webpack_require__(2).localize;

var DigitInfo = function () {
    var spots = [];
    var stream_id = null;
    // To avoid too many greens and reds
    var prev_min_index = -1;
    var prev_max_index = -1;

    var chart = void 0;

    var chart_config = {
        chart: {
            renderTo: 'last_digit_histo',
            defaultSeriesType: 'column',
            backgroundColor: '#eee',
            borderWidth: 1,
            borderColor: '#ccc',
            plotBackgroundColor: '#fff',
            plotBorderWidth: 1,
            plotBorderColor: '#ccc',
            height: 225 // This is "unresponsive", but so is leaving it empty where it goes to 400px.
        },
        title: { text: '' },
        credits: { enabled: false },
        exporting: { enabled: false },
        legend: {
            enabled: false
        },
        tooltip: {
            borderWidth: 1,
            formatter: function formatter() {
                var total = $('#tick_count').val();
                var percentage = this.y / total * 100;
                return '<strong>' + localize('Digit') + ':</strong> ' + this.x + '<br/><strong>' + localize('Percentage') + ':</strong> ' + percentage.toFixed(1) + '%';
            }
        },
        plotOptions: {
            column: {
                shadow: false,
                borderWidth: 0.5,
                borderColor: '#666',
                pointPadding: 0,
                groupPadding: 0.0,
                color: '#e1f0fb'
            },
            series: {
                dataLabels: {
                    enabled: true,
                    style: {
                        textShadow: false
                    },
                    formatter: function formatter() {
                        var total = $('#tick_count').val();
                        var percentage = this.point.y / total * 100;
                        return percentage.toFixed(2) + '%';
                    }
                }
            }
        },
        xAxis: {
            categories: ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],
            lineWidth: 0,
            lineColor: '#999',
            tickLength: 10,
            tickColor: '#ccc'
        },
        yAxis: {
            title: { text: '' },
            maxPadding: 0,
            gridLineColor: '#e9e9e9',
            tickWidth: 1,
            tickLength: 3,
            tickColor: '#ccc',
            lineColor: '#ccc',
            endOnTick: true,
            opposite: false,
            labels: {
                align: 'left',
                x: 0,
                enabled: false,
                formatter: function formatter() {
                    var total = $('#tick_count').val();
                    var percentage = parseInt(this.value / total * 100);
                    return percentage + '%';
                }
            }
        }
    };

    var addContent = function addContent(underlying) {
        var domain = document.domain.split('.').slice(-2).join('.');
        var underlyings = [];
        var symbols = Symbols.getAllSymbols();
        Object.keys(symbols).forEach(function (key) {
            if (/^(R_|RD)/.test(key)) {
                underlyings.push(key);
            }
        });
        underlyings = underlyings.sort();
        var elem = '';
        for (var i = 0; i < underlyings.length; i++) {
            elem += '<option value="' + underlyings[i] + '">' + localize(symbols[underlyings[i]]) + '</option>';
        }
        $('#digit_underlying').html($(elem)).val(underlying);
        $('#digit_domain').text(domain.charAt(0).toUpperCase() + domain.slice(1));
        $('#digit_info_underlying').text($('#digit_underlying option:selected').text());
        CreateDropdown('#digit_underlying');
        CreateDropdown('#tick_count');
    };

    var onLatest = function onLatest() {
        var getLatest = function getLatest() {
            var $digit_underlying_option = $('#digit_underlying option:selected');
            var symbol = $digit_underlying_option.val();
            var count = $('#tick_count').val();
            $('#digit_info_underlying').text($digit_underlying_option.text());
            $('#digit_info_count').text(count);
            var request = {
                ticks_history: symbol,
                end: 'latest',
                count: count
            };
            if (chart.series[0].name !== symbol) {
                if ($('#underlying').find('option:selected').val() !== $('#digit_underlying').val()) {
                    request.subscribe = 1;
                    request.style = 'ticks';
                }
                if (stream_id !== null) {
                    BinarySocket.send({ forget: stream_id });
                    stream_id = null;
                }
            }
            BinarySocket.send(request, { callback: function callback(response) {
                    var type = response.msg_type;
                    if (type === 'tick') {
                        updateChart(response);
                    } else if (type === 'history') {
                        showChart(response.echo_req.ticks_history, response.history.prices);
                    }
                } });
        };
        $('#digit_underlying, #tick_count').off('change').on('change', getLatest);
    };

    var showChart = function showChart(underlying, underlying_spots) {
        if (underlying_spots.length !== +$('#tick_count').val()) return;
        getHighstock(function (Highcharts) {
            var new_spots = underlying_spots;
            if (typeof new_spots === 'undefined' || new_spots.length <= 0) {
                return;
            }
            var dec = new_spots[0].split('.')[1].length;
            for (var i = 0; i < new_spots.length; i++) {
                var val = parseFloat(new_spots[i]).toFixed(dec);
                new_spots[i] = val.substr(val.length - 1);
            }

            var getTitle = function getTitle() {
                return {
                    text: localize($('#last_digit_title').html(), [new_spots.length, $('#digit_underlying option:selected').text()])
                };
            };

            spots = new_spots;
            if (chart) chart.destroy();
            addContent(underlying); // this creates #last_digit_title
            chart_config.xAxis.title = getTitle();
            chart = new Highcharts.Chart(chart_config);
            chart.addSeries({ name: underlying, data: [] });
            onLatest();
            update();
        });
    };

    var update = function update(symbol, latest_spot) {
        if (typeof chart === 'undefined') {
            return null;
        }

        var series = chart.series[0]; // Where we put the final data.

        if (typeof latest_spot !== 'undefined' && series.name === symbol) {
            spots.unshift(latest_spot.slice(-1)); // Only last digit matters
            spots.pop();
        }

        // Always recompute and draw, even if theres no new data.
        // This is especially useful on first reuqest, but maybe in other ways.
        var filtered_spots = [];
        var filterFunc = function filterFunc(el) {
            return +el === digit;
        };
        var digit = 10;
        var min_max_counter = [];
        while (digit--) {
            var val = spots.filter(filterFunc).length;
            filtered_spots[digit] = val;
            if (typeof min_max_counter[val] === 'undefined') {
                min_max_counter[val] = 0;
            }
            min_max_counter[val]++;
        }
        var min = Math.min.apply(null, filtered_spots);
        var max = Math.max.apply(null, filtered_spots);
        var min_index = filtered_spots.indexOf(min);
        var max_index = filtered_spots.indexOf(max);
        // changing color
        if (min_max_counter[min] >= 1) {
            filtered_spots[min_index] = { y: min, color: '#CC0000' };
            if (prev_min_index === -1) {
                prev_min_index = min_index;
            } else if (prev_min_index !== min_index) {
                if (_typeof(filtered_spots[prev_min_index]) === 'object') {
                    filtered_spots[prev_min_index] = { y: filtered_spots[prev_min_index].y, color: '#e1f0fb' };
                } else {
                    filtered_spots[prev_min_index] = { y: filtered_spots[prev_min_index], color: '#e1f0fb' };
                }
                prev_min_index = min_index;
            }
        }

        if (min_max_counter[max] >= 1) {
            filtered_spots[max_index] = { y: max, color: '#2E8836' };
            if (prev_max_index === -1) {
                prev_max_index = max_index;
            } else if (prev_max_index !== max_index) {
                if (_typeof(filtered_spots[prev_max_index]) === 'object') {
                    filtered_spots[prev_max_index] = { y: filtered_spots[prev_max_index].y, color: '#e1f0fb' };
                } else {
                    filtered_spots[prev_max_index] = { y: filtered_spots[prev_max_index], color: '#e1f0fb' };
                }
                prev_max_index = max_index;
            }
        }
        return series.setData(filtered_spots);
    };

    var updateChart = function updateChart(tick) {
        if (stream_id) {
            if (chart.series[0].name === tick.tick.symbol) {
                stream_id = tick.tick.id || null;
                update(tick.tick.symbol, tick.tick.quote);
            } else {
                BinarySocket.send({ forget: tick.tick.id.toString() });
            }
        } else {
            update(tick.tick.symbol, tick.tick.quote);
        }
    };

    return {
        showChart: showChart,
        updateChart: updateChart
    };
}();

module.exports = DigitInfo;

/***/ }),
/* 283 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var HighchartUI = __webpack_require__(284);
var getHighstock = __webpack_require__(31).requireHighstock;
var MBContract = __webpack_require__(77);
var MBDefaults = __webpack_require__(36);
var Callputspread = __webpack_require__(98);
var Defaults = __webpack_require__(23);
var GetTicks = __webpack_require__(99);
var Lookback = __webpack_require__(59);
var Reset = __webpack_require__(78);
var ViewPopupUI = __webpack_require__(131);
var isJPClient = __webpack_require__(3).isJPClient;
var BinarySocket = __webpack_require__(5);
var addComma = __webpack_require__(7).addComma;
var localize = __webpack_require__(2).localize;
var State = __webpack_require__(6).State;
var getPropertyValue = __webpack_require__(1).getPropertyValue;

var Highchart = function () {
    var chart = void 0,
        chart_promise = void 0,
        options = void 0,
        response_id = void 0,
        contract = void 0,
        request = void 0,
        min_point = void 0,
        max_point = void 0,
        lines_drawn = void 0,
        start_time = void 0,
        purchase_time = void 0,
        now_time = void 0,
        end_time = void 0,
        entry_tick_time = void 0,
        is_sold = void 0,
        sell_time = void 0,
        sell_spot_time = void 0,
        is_settleable = void 0,
        exit_tick_time = void 0,
        exit_time = void 0,
        underlying = void 0,
        margin = void 0,
        is_initialized = void 0,
        is_chart_delayed = void 0,
        is_chart_subscribed = void 0,
        stop_streaming = void 0,
        is_contracts_for_send = void 0,
        is_history_send = void 0,
        is_entry_tick_barrier_selected = void 0,
        is_response_id_set = void 0,
        prev_barriers = void 0; // For checking if barrier was updated

    var initOnce = function initOnce() {
        chart = options = response_id = contract = request = min_point = max_point = '';
        lines_drawn = new Set();

        is_initialized = is_chart_delayed = is_chart_subscribed = stop_streaming = is_response_id_set = is_contracts_for_send = is_history_send = is_entry_tick_barrier_selected = false;
    };

    var initializeValues = function initializeValues() {
        start_time = parseInt(contract.date_start);
        purchase_time = parseInt(contract.purchase_time);
        now_time = parseInt(contract.current_spot_time);
        end_time = parseInt(contract.date_expiry);
        entry_tick_time = parseInt(contract.entry_tick_time);
        is_sold = contract.is_sold;
        sell_time = parseInt(contract.sell_time);
        sell_spot_time = parseInt(contract.sell_spot_time);
        is_settleable = contract.is_settleable;
        exit_tick_time = parseInt(contract.exit_tick_time);
        exit_time = parseInt(is_sold && sell_time < end_time ? sell_spot_time : exit_tick_time || end_time);
        underlying = contract.underlying;
        prev_barriers = [];
    };

    // initialize the chart only once with ticks or candles data
    var initChart = function initChart(init_options) {
        var data = [];
        var type = '';
        var i = void 0;

        var pushTicks = function pushTicks(time, price) {
            // we need to add the marker as we are pushing the data points
            // since for large arrays, data doesn't get pushed to series[0].data
            // and we can't update markers if data is empty
            var int_time = parseInt(time);
            var is_match_entry = int_time === entry_tick_time;
            var is_match_exit = int_time === exit_tick_time;
            var tick_type = is_match_entry ? 'entry' : 'exit';
            data.push({
                x: int_time * 1000,
                y: price * 1,
                marker: is_match_entry || is_match_exit ? HighchartUI.getMarkerObject(tick_type) : ''
            });
        };

        var history = '';
        var candles = '';
        if (init_options.history) {
            // indicates line chart
            type = 'line';
            history = init_options.history;
            var times = history.times;
            var prices = history.prices;
            if (is_chart_delayed) {
                for (i = 0; i < times.length; ++i) {
                    pushTicks(times[i], prices[i]);
                }
            } else if (min_point && max_point) {
                var current_time = void 0;
                for (i = 0; i < times.length; ++i) {
                    current_time = parseInt(times[i]);
                    // only display the first tick before entry spot and one tick after exit spot
                    // as well as the set of ticks between them
                    if (current_time >= min_point && current_time <= max_point) {
                        pushTicks(current_time, prices[i]);
                    }
                }
            }
        } else if (init_options.candles) {
            // indicates candle chart
            candles = init_options.candles;
            type = 'candlestick';
            data = candles.map(function (c) {
                return [c.epoch * 1000, c.open * 1, c.high * 1, c.low * 1, c.close * 1];
            });
        }

        // element where chart is to be displayed
        var el = document.getElementById('analysis_live_chart');
        if (!el) {
            chart = null;
            return null;
        }

        var is_jp_client = isJPClient();
        HighchartUI.setLabels(is_chart_delayed, contract.contract_type);

        var chart_options = {
            is_jp_client: is_jp_client,
            type: type,
            data: data,
            height: el.parentElement.offsetHeight,
            title: localize(init_options.title),
            decimals: history ? history.prices[0] : candles[0].open,
            entry_time: entry_tick_time ? entry_tick_time * 1000 : start_time * 1000,
            exit_time: exit_time ? exit_time * 1000 : null,
            user_sold: isSoldBeforeExpiry()
        };
        if (Callputspread.isCallputspread(contract.contract_type)) {
            $.extend(chart_options, Callputspread.getChartOptions(contract));
        }
        HighchartUI.setChartOptions(chart_options);

        return getHighstock(function (Highcharts) {
            Highcharts.setOptions(HighchartUI.getHighchartOptions(is_jp_client));
            if (!el) chart = null;else {
                chart = Highcharts.StockChart(el, HighchartUI.getChartOptions());
                is_initialized = true;

                if (Callputspread.isCallputspread(contract.contract_type)) {
                    Callputspread.init(chart, contract);
                }
            }
        });
    };

    // type 'x' is used to draw lines such as start and end times
    // type 'y' is used to draw lines such as barrier
    var addPlotLine = function addPlotLine(params, type) {
        chart[type + 'Axis'][0].addPlotLine(HighchartUI.getPlotlineOptions(params, type));
        if (isSoldBeforeExpiry()) {
            HighchartUI.replaceExitLabelWithSell(chart.subtitle.element);
        }
    };

    // Remove plotLines by id
    var removePlotLine = function removePlotLine(id) {
        var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'y';

        chart[type + 'Axis'][0].removePlotLine(id);
    };

    var handleResponse = function handleResponse(response) {
        var type = response.msg_type;
        var error = response.error;

        if (/history|candles|tick|ohlc/.test(type) && !error) {
            options = { title: contract.display_name };
            options[type] = response[type];
            var history = response.history;
            var candles = response.candles;
            var tick = response.tick;
            var ohlc = response.ohlc;
            response_id = response[type].id;
            // send view popup the response ID so view popup can forget the calls if it's closed before contract ends
            if (response_id && !is_response_id_set) {
                if (State.get('is_trading') || State.get('is_mb_trading')) {
                    var page_underlying = State.get('is_mb_trading') ? MBDefaults.get('underlying') : Defaults.get('underlying');
                    if (page_underlying !== (tick || ohlc).symbol) {
                        ViewPopupUI.storeSubscriptionID(response_id, true);
                        ViewPopupUI.setOnCloseFunction();
                    } else {
                        ViewPopupUI.setOnCloseFunction(GetTicks.request);
                    }
                } else {
                    ViewPopupUI.storeSubscriptionID(response_id, true);
                    ViewPopupUI.setOnCloseFunction();
                }
                is_response_id_set = true;
            }
            if (history || candles) {
                var length = (history ? history.times : candles).length;
                if (length === 0) {
                    HighchartUI.showError('missing');
                    return;
                }
                if (history) {
                    var history_times = history.times;
                    getMinHistory(history_times);
                    getMaxHistory(history_times);
                } else if (candles) {
                    getMinCandle(candles);
                    getMaxCandle(candles);
                }
                // only initialize chart if it hasn't already been initialized
                if (!chart && !is_initialized) {
                    chart_promise = initChart(options);
                    if (!chart_promise || typeof chart_promise.then !== 'function') return;
                    chart_promise.then(function () {
                        if (!chart) return;

                        if (purchase_time !== start_time) {
                            drawLineX({
                                value: purchase_time,
                                label: localize('Purchase Time'),
                                color: '#7cb5ec'
                            });
                        }

                        // second condition is used to make sure contracts that have purchase time
                        // but are sold before the start time don't show start time
                        if (!is_sold || is_sold && sell_time && sell_time > start_time) {
                            drawLineX({ value: start_time });
                        }

                        if (Reset.isReset(contract.contract_type)) {
                            drawResetTimeLine();
                        }
                    });
                }
            } else if ((tick || ohlc) && !stop_streaming) {
                if (chart && chart.series) {
                    updateChart(options);
                }
            }
            if (chart_promise && typeof chart_promise.then === 'function') {
                if (entry_tick_time && !is_entry_tick_barrier_selected) {
                    chart_promise.then(selectEntryTickBarrier);
                }
                if (is_sold || is_settleable) {
                    chart_promise.then(function () {
                        updateZone('exit');
                        endContract();
                    });
                }
            }
        } else if (type === 'ticks_history' && error) {
            HighchartUI.showError('', error.message);
        }
    };

    var showChart = function showChart(proposal_contract, update) {
        contract = proposal_contract;
        initializeValues();
        if (!update) {
            initOnce();
        }
        if (!chart && !is_history_send) {
            requestData(update || '');
        } else if (chart && entry_tick_time && !is_entry_tick_barrier_selected) {
            selectEntryTickBarrier();
        }
        if (chart && (is_sold || is_settleable)) {
            updateZone('exit');
            endContract();
        }
    };

    var requestData = function requestData(update) {
        var calculate_granularity = calculateGranularity();
        var granularity = calculate_granularity[0];
        var duration = calculate_granularity[1];

        margin = granularity === 0 ? Math.max(300, 30 * duration / (60 * 60) || 0) : 3 * granularity;

        request = {
            ticks_history: underlying,
            start: ((purchase_time || start_time) - margin).toFixed(0), /* load more ticks first */
            end: end_time ? (end_time + margin).toFixed(0) : 'latest',
            style: granularity === 0 ? 'ticks' : 'candles',
            count: 4999, /* maximum number of ticks possible */
            adjust_start_time: 1
        };

        if (is_sold && sell_time < end_time) {
            request.end = sell_spot_time ? (parseInt(sell_spot_time) + margin).toFixed(0) : 'latest';
        }

        // switch start and end if start is after end
        if (!isNaN(request.end) && request.start > request.end) {
            request.end = [request.start, request.start = request.end][0];
        }

        if (granularity !== 0) {
            request.granularity = granularity;
        }

        if (!is_settleable && !sell_spot_time && window.time.valueOf() / 1000 < end_time && !is_chart_subscribed) {
            request.subscribe = 1;
        }

        var contracts_response = State.get('is_mb_trading') ? MBContract.getContractsResponse() : State.get(['response', 'contracts_for']);
        var stored_delay = sessionStorage.getItem('license.' + underlying);

        if (contracts_response && contracts_response.echo_req.contracts_for === underlying) {
            delayedChart(contracts_response);
        } else if (stored_delay) {
            handleDelay(stored_delay);
            sendTickRequest();
        } else if (!is_contracts_for_send && update === '') {
            BinarySocket.send({ contracts_for: underlying }).then(function (response) {
                var error = response.error;
                if (!error || error.code && error.code === 'InvalidSymbol') {
                    delayedChart(response);
                }
            });
            is_contracts_for_send = true;
        }
    };

    var delayedChart = function delayedChart(contracts_response) {
        if (contracts_response.contracts_for && contracts_response.contracts_for.feed_license) {
            var license = contracts_response.contracts_for.feed_license;
            handleDelay(license);
            saveFeedLicense(contracts_response.echo_req.contracts_for, license);
        }
        sendTickRequest();
    };

    var sendTickRequest = function sendTickRequest() {
        if (!entry_tick_time && !is_chart_delayed && start_time && window.time.unix() >= parseInt(start_time)) {
            HighchartUI.showError('', localize('Waiting for entry tick.'));
        } else if (!is_history_send) {
            is_history_send = true;
            if (request.subscribe) is_chart_subscribed = true;
            // BinarySocket.send(request, { callback: handleResponse });
            GetTicks.request('', request, handleResponse);
        }
    };

    var handleDelay = function handleDelay(feed_license) {
        if (feed_license !== 'realtime') {
            if (!is_settleable) {
                request.end = 'latest';
            }
            delete request.subscribe;
            is_chart_delayed = true;
        }
    };

    // update the color zones with the correct entry_tick_time and draw barrier
    var selectEntryTickBarrier = function selectEntryTickBarrier() {
        if (chart && entry_tick_time && !is_entry_tick_barrier_selected) {
            is_entry_tick_barrier_selected = true;
            drawBarrier();
            updateZone('entry');
            selectTick(entry_tick_time, 'entry');
        }
    };

    var updateZone = function updateZone(type) {
        if (chart && type && !isSoldBeforeExpiry()) {
            var value = type === 'entry' ? entry_tick_time : exit_time;
            chart.series[0].zones[type === 'entry' ? 0 : 1].value = value * 1000;
        }
    };

    var drawResetTimeLine = function drawResetTimeLine() {
        var _contract = contract,
            reset_time = _contract.reset_time; // use epoch to draw non-ticks reset_time

        if (!reset_time) return;
        drawLineX({
            value: parseInt(reset_time),
            color: '#000'
        });
    };

    var drawBarrier = function drawBarrier() {
        if (chart.yAxis[0].plotLinesAndBands.length === 0) {
            var _contract2 = contract,
                barrier = _contract2.barrier,
                contract_type = _contract2.contract_type,
                entry_spot = _contract2.entry_spot,
                high_barrier = _contract2.high_barrier,
                low_barrier = _contract2.low_barrier;

            if (barrier) {
                prev_barriers[0] = barrier; // Batman like the kids who "Cache".
                if (Lookback.isLookback(contract_type)) {
                    var label = Lookback.getBarrierLabel(contract_type);
                    addPlotLine({ id: 'barrier', value: +barrier, label: localize('' + label) + ' (' + addComma(barrier) + ')', dashStyle: 'Dot' }, 'y');
                } else if (Reset.isReset(contract_type)) {
                    if (Reset.isNewBarrier(entry_spot, barrier)) {
                        addPlotLine({ id: 'barrier', value: +entry_spot, label: localize('Barrier') + ' (' + addComma(entry_spot) + ')', dashStyle: 'Dot', textBottom: contract_type !== 'RESETCALL', x: -60, align: 'right' }, 'y');
                        addPlotLine({ id: 'reset_barrier', value: +barrier, label: localize('Reset Barrier') + ' (' + addComma(barrier) + ')', dashStyle: 'Solid', textBottom: contract_type === 'RESETCALL', x: -60, align: 'right' }, 'y');
                    } else {
                        addPlotLine({ id: 'barrier', value: +entry_spot, label: localize('Barrier') + ' (' + addComma(entry_spot) + ')', dashStyle: 'Dot', x: -60, align: 'right' }, 'y');
                    }
                } else {
                    addPlotLine({ id: 'barrier', value: +barrier, label: localize('Barrier') + ' (' + addComma(barrier) + ')', dashStyle: 'Dot' }, 'y');
                }
            } else if (high_barrier && low_barrier) {
                prev_barriers[1] = high_barrier;
                prev_barriers[0] = low_barrier;
                if (Lookback.isLookback(contract_type)) {
                    var _Lookback$getBarrierL = Lookback.getBarrierLabel(contract_type),
                        _Lookback$getBarrierL2 = _slicedToArray(_Lookback$getBarrierL, 2),
                        high_label = _Lookback$getBarrierL2[0],
                        low_label = _Lookback$getBarrierL2[1];

                    addPlotLine({ id: 'high_barrier', value: +high_barrier, label: localize('' + high_label) + ' (' + addComma(high_barrier) + ')', dashStyle: 'Dot' }, 'y');
                    addPlotLine({ id: 'low_barrier', value: +low_barrier, label: localize('' + low_label) + ' (' + addComma(low_barrier) + ')', dashStyle: 'Dot', textBottom: true }, 'y');
                } else {
                    addPlotLine({ id: 'high_barrier', value: +high_barrier, label: localize('High Barrier') + ' (' + addComma(high_barrier) + ')', dashStyle: 'Dot' }, 'y');
                    addPlotLine({ id: 'low_barrier', value: +low_barrier, label: localize('Low Barrier') + ' (' + addComma(low_barrier) + ')', dashStyle: 'Dot', textBottom: true }, 'y');
                }
            }
        }
    };

    // Update barriers if needed.
    var updateBarrier = function updateBarrier() {
        var _contract3 = contract,
            barrier = _contract3.barrier,
            high_barrier = _contract3.high_barrier,
            low_barrier = _contract3.low_barrier;
        // Update barrier only if it doesn't equal previous value

        if (barrier && barrier !== prev_barriers[0]) {
            // Batman: Good boy!
            prev_barriers[0] = barrier;
            removePlotLine('barrier', 'y');
            drawBarrier();
        } else if (high_barrier && low_barrier && (high_barrier !== prev_barriers[1] || low_barrier !== prev_barriers[0])) {
            prev_barriers[1] = high_barrier;
            prev_barriers[0] = low_barrier;
            removePlotLine('high_barrier', 'y');
            removePlotLine('low_barrier', 'y');
            drawBarrier();
        }
    };

    // set an orange circle on the entry/exit tick
    var selectTick = function selectTick(value, tick_type) {
        if (chart && value && tick_type && (options.tick || options.history) && chart.series[0].data.length !== 0) {
            var data = chart.series[0].data;
            if (!data || data.length === 0) return;
            var current_data = void 0;
            for (var i = data.length - 1; i >= 0; i--) {
                current_data = data[i];
                if (current_data && current_data.x && value * 1000 === current_data.x) {
                    current_data.update({ marker: HighchartUI.getMarkerObject(tick_type) });
                }
            }
        }
    };

    // calculate where to display the minimum value of the x-axis of the chart for line chart
    var getMinHistory = function getMinHistory(history_times) {
        var history_times_length = history_times.length;
        var history_times_int = void 0;
        for (var i = 0; i < history_times_length; i++) {
            history_times_int = parseInt(history_times[i]);
            if (entry_tick_time && history_times_int === entry_tick_time || purchase_time && start_time > purchase_time && history_times_int === purchase_time || history_times_int < purchase_time && parseInt(history_times[i === history_times_length - 1 ? i : i + 1]) > purchase_time) {
                // set the chart to display from the tick before entry_tick_time or purchase_time
                min_point = parseInt(history_times[i === 0 ? i : i - 1]);
                break;
            }
        }
        if (!min_point) min_point = parseInt(history_times[0]);
    };

    // calculate where to display the maximum value of the x-axis of the chart for line chart
    var getMaxHistory = function getMaxHistory(history_times) {
        var end = end_time;
        if (sell_time && sell_time < end_time) {
            end = sell_time;
        } else if (exit_tick_time) {
            end = exit_tick_time;
        }

        var history_times_length = history_times.length;
        if (is_settleable || is_sold) {
            var i = history_times.findIndex(function (time) {
                return +time > end;
            });
            max_point = i > 0 ? +history_times[i] : end_time;
        }
        setMaxForDelayedChart(history_times, history_times_length);
    };

    // calculate where to display the minimum value of the x-axis of the chart for candle
    var getMinCandle = function getMinCandle(candles) {
        var candle_before_time = function candle_before_time(value) {
            return value && current_candle && parseInt(current_candle.epoch) <= value && candles[i === candles_length - 1 ? i : i + 1].epoch > value;
        };
        var i = void 0,
            current_candle = void 0;
        var candles_length = candles.length;
        for (i = 1; i < candles_length; i++) {
            current_candle = candles[i];
            if (candle_before_time(entry_tick_time) || candle_before_time(purchase_time)) {
                // set the chart to display from the candle before entry_tick_time or purchase_time
                min_point = parseInt(candles[i - 1].epoch);
                break;
            }
        }
    };

    // calculate where to display the maximum value of the x-axis of the chart for candle
    var getMaxCandle = function getMaxCandle(candles) {
        var end = sell_spot_time && sell_time < end_time ? sell_spot_time : end_time;
        var candle_length = candles.length;
        var current_candle = void 0,
            next_candle = void 0;
        if (is_settleable || is_sold) {
            for (var i = candle_length - 2; i >= 0; i--) {
                current_candle = candles[i];
                next_candle = candles[i + 1];
                if (!current_candle) return;
                if (parseInt(next_candle.epoch) < end) {
                    max_point = end_time;
                    break;
                }
                if (parseInt(current_candle.epoch) <= end && parseInt(next_candle.epoch) > end) {
                    max_point = parseInt(next_candle.epoch);
                    break;
                }
            }
        }
        setMaxForDelayedChart(candles, candle_length);
    };

    var setMaxForDelayedChart = function setMaxForDelayedChart(array, array_length) {
        if (is_chart_delayed) {
            var last_epoch = parseInt(array[array_length - 1].epoch);
            if (last_epoch > start_time) {
                max_point = last_epoch;
            } else {
                max_point = start_time;
            }
        }
        if (!max_point) max_point = end_time;
    };

    var drawLineX = function drawLineX(properties) {
        if (chart && properties.value && !lines_drawn.has(properties.value)) {
            addPlotLine({
                value: properties.value * 1000,
                label: properties.label || '',
                textLeft: properties.text_left === 'textLeft',
                dashStyle: properties.dash_style || '',
                color: properties.color || ''
            }, 'x');
            lines_drawn.add(properties.value);
        }
    };

    // draw the last line, mark the exit tick, and forget the streams
    var endContract = function endContract() {
        if (chart && !stop_streaming) {
            drawLineX({
                value: isSoldBeforeExpiry() ? sell_time : end_time,
                text_left: 'textLeft',
                dash_style: 'Dash'
            });
            if (exit_tick_time) {
                selectTick(exit_tick_time, 'exit');
            }
            if (!contract.sell_spot && !contract.exit_tick) {
                if ($('#waiting_exit_tick').length === 0) {
                    $('#trade_details_message').append($('<div/>', { id: 'waiting_exit_tick', text: localize('Waiting for exit tick.') }));
                }
            } else {
                $('#waiting_exit_tick').remove();
            }
            setStopStreaming();
        }
    };

    var setStopStreaming = function setStopStreaming() {
        if (chart && (is_sold || is_settleable) && (isSoldBeforeExpiry() ? sell_time : end_time)) {
            var data = getPropertyValue(getPropertyValue(chart, ['series'])[0], ['options', 'data']);
            if (data && data.length > 0) {
                var last_data = data[data.length - 1];
                var i = 2;
                while (last_data.y === null) {
                    last_data = data[data.length - i];
                    i++;
                }
                var last = parseInt(last_data.x || last_data[0]);
                if (last > end_time * 1000 || last > (sell_time || sell_spot_time) * 1000) {
                    stop_streaming = true;
                }
            }
        }
    };

    var calculateGranularity = function calculateGranularity() {
        var duration = Math.min(exit_time, now_time) - (purchase_time || start_time);
        var granularity = void 0;
        // days * hours * minutes * seconds
        if (duration <= 60 * 60) granularity = 0; // less than 1 hour
        else if (duration <= 2 * 60 * 60) granularity = 120; // 2 hours
            else if (duration <= 6 * 60 * 60) granularity = 600; // 6 hours
                else if (duration <= 24 * 60 * 60) granularity = 900; // 1 day
                    else if (duration <= 5 * 24 * 60 * 60) granularity = 3600; // 5 days
                        else if (duration <= 30 * 24 * 60 * 60) granularity = 14400; // 30 days
                            else granularity = 86400; // more than 30 days

        return [granularity, duration];
    };

    // add new data points to the chart
    var updateChart = function updateChart(update_options) {
        var granularity = calculateGranularity()[0];
        var series = chart.series[0];
        if (granularity === 0) {
            var data = update_options.tick;
            chart.series[0].addPoint({ x: data.epoch * 1000, y: data.quote * 1 });
            updateBarrier();
        } else {
            var c = update_options.ohlc;
            var last = series.data[series.data.length - 1];
            if (!c || !last) return;
            var ohlc = [c.open_time * 1000, c.open * 1, c.high * 1, c.low * 1, c.close * 1];

            if (last.x !== ohlc[0]) {
                series.addPoint(ohlc, true, true);
            } else {
                last.update(ohlc, true);
            }
        }
        if (Reset.isReset(contract.contract_type)) {
            drawResetTimeLine();
        }
    };

    var saveFeedLicense = function saveFeedLicense(save_contract, license) {
        var regex = new RegExp('license.' + contract);
        var match_found = false;

        for (var i = 0; i < sessionStorage.length; i++) {
            if (regex.test(sessionStorage.key(i))) {
                match_found = true;
                break;
            }
        }

        if (!match_found) {
            sessionStorage.setItem('license.' + save_contract, license);
        }
    };

    var isSoldBeforeExpiry = function isSoldBeforeExpiry() {
        return sell_time && sell_time < end_time || !sell_time && sell_spot_time && sell_spot_time < end_time;
    };

    return {
        showChart: showChart
    };
}();

module.exports = Highchart;

/***/ }),
/* 284 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isCallputspread = __webpack_require__(98).isCallputspread;
var isReset = __webpack_require__(78).isReset;
var addComma = __webpack_require__(7).addComma;
var localize = __webpack_require__(2).localize;

var HighchartUI = function () {
    var common_time_style = 'margin-bottom: 3px; margin-left: 10px; height: 0; width: 20px; border: 0; border-bottom: 2px; border-color: #e98024; display: inline-block;';
    var common_spot_style = 'margin-left: 10px; display: inline-block; border-radius: 6px;';

    var txt_legend = void 0,
        chart_options = void 0;

    var labels = {
        start_time: '<div style="' + common_time_style + ' border-style: solid;"></div> ' + localize('Start time') + ' ',
        entry_spot: '<div style="' + common_spot_style + ' border: 3px solid orange; width: 4px; height: 4px;"></div> ' + localize('Entry spot') + ' ',
        reset_time: '<div style="' + common_time_style + ' border-color: #000; border-style: solid;"></div> ' + localize('Reset time') + ' ',
        exit_spot: '<div style="' + common_spot_style + ' background-color: orange; width:10px; height: 10px;"></div> ' + localize('Exit spot') + ' ',
        end_time: '<div style="' + common_time_style + ' border-style: dashed;"></div> ' + localize('End time') + ' ',
        delay: '<span class="chart-delay"> ' + localize('Charting for this underlying is delayed') + ' </span>',
        payout_range: '<span class="chart-payout-range"> ' + localize('Payout range') + ' </span>'
    };

    var setLabels = function setLabels(chart_delayed, contract_type) {
        // display a guide for clients to know how we are marking entry and exit spots
        txt_legend = (chart_delayed ? labels.delay : '') + labels.start_time + (history ? labels.entry_spot + labels.exit_spot : '') + (isReset(contract_type) ? labels.reset_time : '') + labels.end_time + (isCallputspread(contract_type) ? labels.payout_range : '');
    };

    var setChartOptions = function setChartOptions(params) {
        var display_decimals = params.decimals.split('.')[1].length || 3;
        chart_options = {
            chart: {
                backgroundColor: null, /* make background transparent */
                height: Math.max(params.height, 450),
                renderTo: params.el,
                animation: false,
                marginLeft: 30,
                marginRight: params.marginRight || 30,
                events: {
                    redraw: params.redrawHandler
                }
            },
            title: {
                text: params.title,
                style: { fontSize: '16px' }
            },
            credits: { enabled: false },
            tooltip: {
                xDateFormat: params.is_jp_client ? '%Y/%m/%d, %H:%M:%S' : '%A, %b %e, %H:%M:%S GMT',
                valueDecimals: display_decimals
            },
            subtitle: {
                text: txt_legend,
                useHTML: true
            },
            xAxis: {
                labels: { overflow: 'justify', format: '{value:%H:%M:%S}' }
            },
            yAxis: {
                opposite: false,
                labels: {
                    align: 'left',
                    formatter: function formatter() {
                        return addComma(this.value.toFixed(display_decimals));
                    }
                },
                maxPadding: 0.05,
                minPadding: 0.05
            },
            series: [{
                type: params.type,
                name: params.title,
                data: params.data,
                // zones are used to display color of the line
                zones: [{
                    // make the line grey until it reaches entry time or start time if entry spot time is not yet known
                    value: params.entry_time,
                    color: '#ccc'
                }, {
                    // make the line default color until exit time is reached
                    value: params.exit_time,
                    color: ''
                }, {
                    // make the line grey again after trade ended
                    color: '#ccc'
                }],
                zoneAxis: 'x',
                cropThreshold: Infinity,
                softThreshold: false,
                turboThreshold: Infinity,
                connectNulls: true
            }],
            exporting: { enabled: false },
            plotOptions: {
                line: {
                    marker: { radius: 2, enabled: true }
                },
                candlestick: {
                    lineColor: 'black',
                    color: 'red',
                    upColor: 'green',
                    upLineColor: 'black',
                    shadow: true
                }
            },
            rangeSelector: { enabled: false }
        };
        if (params.user_sold) {
            chart_options.series[0].zones.pop();
        }
    };

    var getHighchartOptions = function getHighchartOptions(is_jp_client) {
        return {
            // use comma as separator instead of space
            lang: { thousandsSep: ',' },
            global: {
                timezoneOffset: is_jp_client ? -9 * 60 : 0 // Converting chart time to JST.
            }
        };
    };

    var replaceExitLabelWithSell = function replaceExitLabelWithSell(subtitle) {
        var subtitle_length = subtitle.childNodes.length;
        var textnode = document.createTextNode(' ' + localize('Sell time') + ' ');
        for (var i = 0; i < subtitle_length; i++) {
            var item = subtitle.childNodes[i];
            if (/End time/.test(item.nodeValue)) {
                subtitle.replaceChild(textnode, item);
            }
        }
    };

    var getPlotlineOptions = function getPlotlineOptions(params, type) {
        var is_plotx = type === 'x';
        var options = {
            value: params.value,
            id: params.id || (is_plotx ? params.value : params.label),
            label: { text: params.label || '' },
            color: params.color || (is_plotx ? '#e98024' : 'green'),
            zIndex: is_plotx ? 2 : 1,
            width: params.width || 2,
            dashStyle: params.dashStyle || 'Solid'
        };

        if (is_plotx) {
            options.label.x = params.textLeft ? -15 : 5;
        } else {
            options.label.x = params.x || 0;
            options.label.y = params.textBottom ? 15 : -5;
            options.label.align = params.align || 'center';
        }

        return options;
    };

    var showError = function showError(type, message) {
        $('#analysis_live_chart').html($('<p/>', { class: 'error-msg', text: type === 'missing' ? localize('Ticks history returned an empty array.') : message }));
    };

    var getMarkerObject = function getMarkerObject(type) {
        var color = type === 'entry' ? 'white' : 'orange';
        return { fillColor: color, lineColor: 'orange', lineWidth: 3, radius: 4, states: { hover: { fillColor: color, lineColor: 'orange', lineWidth: 3, radius: 4 } } };
    };

    return {
        setLabels: setLabels,
        setChartOptions: setChartOptions,
        getHighchartOptions: getHighchartOptions,
        replaceExitLabelWithSell: replaceExitLabelWithSell,
        getPlotlineOptions: getPlotlineOptions,
        showError: showError,
        getMarkerObject: getMarkerObject,
        getChartOptions: function getChartOptions() {
            return chart_options;
        }
    };
}();

module.exports = HighchartUI;

/***/ }),
/* 285 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.init = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(117);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(228);

var _reactDom2 = _interopRequireDefault(_reactDom);

var _defaults = __webpack_require__(23);

var _defaults2 = _interopRequireDefault(_defaults);

var _common_functions = __webpack_require__(4);

var _localize = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Contracts = function (_React$Component) {
    _inherits(Contracts, _React$Component);

    function Contracts(props) {
        _classCallCheck(this, Contracts);

        var _this = _possibleConstructorReturn(this, (Contracts.__proto__ || Object.getPrototypeOf(Contracts)).call(this, props));

        _initialiseProps.call(_this);

        var contracts = props.contracts,
            contracts_tree = props.contracts_tree,
            selected = props.selected;

        var formname = selected || _defaults2.default.get('formname');
        _this.references = {};
        _this.el_contract = (0, _common_functions.getElementById)('contract');
        _this.el_contract.value = formname;
        _this.state = {
            contracts: contracts,
            contracts_tree: contracts_tree,
            formname: formname,
            open: false
        };
        return _this;
    }

    _createClass(Contracts, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            document.body.addEventListener('click', this.handleClickOutside);
        }
    }, {
        key: 'componentWillUnmount',
        value: function componentWillUnmount() {
            document.body.removeEventListener('click', this.handleClickOutside);
        }
        /* eslint-disable no-undef */

    }, {
        key: 'render',

        /* eslint-enable no-undef */
        value: function render() {
            var _this2 = this;

            var _state = this.state,
                contracts = _state.contracts,
                contracts_tree = _state.contracts_tree,
                open = _state.open,
                formname = _state.formname;

            var is_mobile = window.innerWidth <= 767;
            return _react2.default.createElement(
                'div',
                { className: 'contracts' },
                _react2.default.createElement(
                    'div',
                    {
                        className: 'contract_current ' + (contracts_tree.length <= 1 ? 'disabled' : ''),
                        onClick: this.openDropDown
                    },
                    _react2.default.createElement(
                        'span',
                        { className: 'type' },
                        this.getCurrentType(),
                        _react2.default.createElement('span', { className: 'arrow_down ' + (contracts_tree.length <= 1 ? 'invisible' : '') })
                    ),
                    _react2.default.createElement(
                        'span',
                        { className: 'contract' },
                        this.getCurrentContract()
                    )
                ),
                _react2.default.createElement(
                    'div',
                    {
                        className: 'contracts_dropdown ' + (open ? '' : 'hidden'),
                        ref: this.saveRef.bind(null, 'wrapper')
                    },
                    _react2.default.createElement(
                        'div',
                        { className: 'mobile_close invisible ' + (open && is_mobile ? '' : 'disabled') },
                        _react2.default.createElement(
                            'span',
                            null,
                            (0, _localize.localize)('Select Trade Type')
                        ),
                        _react2.default.createElement('span', { className: 'close', onClick: this.closeDropDown })
                    ),
                    _react2.default.createElement(
                        'div',
                        { className: 'list' },
                        contracts_tree.map(function (contract, idx) {
                            if ((typeof contract === 'undefined' ? 'undefined' : _typeof(contract)) === 'object') {
                                return _react2.default.createElement(
                                    'div',
                                    { className: 'contract', key: idx },
                                    _react2.default.createElement(
                                        'div',
                                        { className: 'contract_type' },
                                        contracts[contract[0]]
                                    ),
                                    _react2.default.createElement(
                                        'div',
                                        { className: 'contract_subtypes' },
                                        contract[1].map(function (subtype, i) {
                                            return _react2.default.createElement(
                                                'div',
                                                {
                                                    className: 'sub ' + (subtype === formname ? 'active' : ''),
                                                    key: i,
                                                    onClick: _this2.onContractClick.bind(null, subtype)
                                                },
                                                contracts[subtype]
                                            );
                                        })
                                    )
                                );
                            }
                            return _react2.default.createElement(
                                'div',
                                { className: 'contract', key: idx },
                                _react2.default.createElement(
                                    'div',
                                    { className: 'contract_type' },
                                    contracts[contract]
                                ),
                                _react2.default.createElement(
                                    'div',
                                    { className: 'contract_subtypes' },
                                    _react2.default.createElement(
                                        'div',
                                        {
                                            className: 'sub ' + (contract === formname ? 'active' : ''),
                                            onClick: _this2.onContractClick.bind(null, contract)
                                        },
                                        contracts[contract]
                                    )
                                )
                            );
                        })
                    )
                )
            );
        }
    }]);

    return Contracts;
}(_react2.default.Component);
/* eslint-disable react/no-render-return-value*/


var _initialiseProps = function _initialiseProps() {
    var _this3 = this;

    this.handleClickOutside = function (e) {
        if (_this3.references.wrapper && !_this3.references.wrapper.contains(e.target) && _this3.state.open) {
            _this3.closeDropDown();
        }
    };

    this.openDropDown = function () {
        if (_this3.state.contracts_tree.length <= 1) return;
        _this3.positionDropDown();
        _this3.setState({ open: true });
    };

    this.closeDropDown = function () {
        _this3.setState({ open: false });
        var el_dropdown = _this3.references.wrapper;
        // reposition dropdown after the animation is finished.
        setTimeout(function () {
            return el_dropdown.removeAttribute('style');
        }, 500);
    };

    this.positionDropDown = function () {
        var el_dropdown = _this3.references.wrapper;
        var pos = el_dropdown.getBoundingClientRect();

        if (pos.x + pos.width + 10 > window.innerWidth) {
            // 10 is padding right for the element
            el_dropdown.style.left = window.innerWidth - (pos.x + pos.width + 10) + 'px';
        } else if (pos.x + pos.width + 10 !== window.innerWidth) {
            el_dropdown.removeAttribute('style');
        }
    };

    this.saveRef = function (name, node) {
        _this3.references[name] = node;
    };

    this.getCurrentType = function () {
        var _state2 = _this3.state,
            formname = _state2.formname,
            contracts = _state2.contracts;

        var type = '';
        _this3.state.contracts_tree.forEach(function (e) {
            if ((typeof e === 'undefined' ? 'undefined' : _typeof(e)) === 'object') {
                e[1].forEach(function (subtype) {
                    if (subtype === formname) {
                        type = e[0];
                    }
                });
            } else if (e === formname) {
                type = e;
            }
        });

        return contracts[type];
    };

    this.getCurrentContract = function () {
        var _state3 = _this3.state,
            formname = _state3.formname,
            contracts = _state3.contracts;

        var max_char = window.innerWidth <= 767 ? 10 : 15;
        if ((contracts[formname] || '').length > max_char) {
            return contracts[formname].substr(0, max_char) + '...';
        }
        return contracts[formname];
    };

    this.onContractClick = function (formname) {
        _this3.closeDropDown();
        if (formname === _this3.state.formname) {
            return;
        }
        // Notify for changes on contract.
        _this3.el_contract.value = formname;
        var event = new Event('change');
        _this3.el_contract.dispatchEvent(event);

        _this3.setState({ formname: formname });
    };
};

var init = exports.init = function init(contracts, contracts_tree, selected) {
    return _reactDom2.default.render(_react2.default.createElement(Contracts, { contracts: contracts, contracts_tree: contracts_tree, selected: selected }), (0, _common_functions.getElementById)('contract_component'));
};
/* eslint-enable react/no-render-return-value */

exports.default = init;

/***/ }),
/* 286 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Defaults = __webpack_require__(23);
var Currency = __webpack_require__(7);
var State = __webpack_require__(6).State;

/*
 * Handles currency display
 *
 * It process 'socket.send({payout_currencies:1})` response
 * and display them
 */
var displayCurrencies = function displayCurrencies() {
    var $currency = $('.currency');

    if (!$currency.length) {
        return;
    }

    var currencies = State.getResponse('payout_currencies');

    if (currencies && currencies.length > 1) {
        $currency.html(Currency.getCurrencyList(currencies).html());
        Defaults.set('currency', $currency.val());
    } else {
        $currency.replaceWith($('<span/>', { id: $currency.attr('id'), class: $currency.attr('class'), value: currencies[0], html: Currency.formatCurrency(currencies[0]) }));
        Defaults.set('currency', currencies[0]);
    }
};

module.exports = displayCurrencies;

/***/ }),
/* 287 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var moment = __webpack_require__(9);
var TradingAnalysis = __webpack_require__(88);
var Barriers = __webpack_require__(124);
var CommonTrading = __webpack_require__(31);
var CommonIndependent = __webpack_require__(47);
var Defaults = __webpack_require__(23);
var Durations = __webpack_require__(125);
var GetTicks = __webpack_require__(99);
var Notifications = __webpack_require__(176);
var Price = __webpack_require__(100);
var Process = __webpack_require__(177);
var Purchase = __webpack_require__(178);
var Tick = __webpack_require__(60);
var BinarySocket = __webpack_require__(5);
var getDecimalPlaces = __webpack_require__(7).getDecimalPlaces;
var isCryptocurrency = __webpack_require__(7).isCryptocurrency;
var onlyNumericOnKeypress = __webpack_require__(169);
var TimePicker = __webpack_require__(171);
var GTM = __webpack_require__(54);
var dateValueChanged = __webpack_require__(4).dateValueChanged;
var isVisible = __webpack_require__(4).isVisible;
var getElementById = __webpack_require__(4).getElementById;
var localize = __webpack_require__(2).localize;

/*
 * TradingEvents object contains all the event handler function for
 * websocket trading page
 *
 * We need it as object so that we can call TradingEvent.init() only on trading
 * page for pjax to work else it will fire on all pages
 *
 */
var TradingEvents = function () {
    var initiate = function initiate() {
        var attachTimePicker = function attachTimePicker(selector, check_end_time) {
            var min_time = void 0,
                max_time = void 0;
            if ($date_start && $date_start.val()) {
                var date_start_val = $date_start.val();
                var moment_date_start = moment.unix(date_start_val).utc();
                var moment_now = (window.time || moment.utc()).clone();

                if (check_end_time) {
                    var min_max_time = CommonIndependent.getMinMaxTimeEnd($date_start, $time_start, moment_now);

                    min_time = min_max_time.minTime;
                    max_time = min_max_time.maxTime;
                } else if (moment_date_start.isSame(moment_now, 'day')) {
                    // for start time picker only disable past times of today
                    min_time = moment_now.clone();
                }
            }
            var initObj = { selector: selector };
            if (min_time) {
                initObj.minTime = min_time.clone();
            }
            if (max_time) {
                initObj.maxTime = max_time.clone();
            }
            TimePicker.init(initObj);
        };

        var contract_input = getElementById('contract');
        contract_input.addEventListener('change', function () {
            /*
             * attach event to form list, so when client click on different form we need to update form
             * and request for new Contract details to populate the form and request price accordingly
             */
            Process.processContractForm();
            TradingAnalysis.request();
        });

        var el_equal = getElementById('callputequal');
        el_equal.addEventListener('change', function (e) {
            Defaults.set('is_equal', +e.target.checked);
            Process.processContractForm();
            TradingAnalysis.request();
        });

        /*
         * attach event to underlying change, event need to request new contract details and price
         */
        getElementById('underlying').addEventListener('change', function (e) {
            if (e.target) {
                CommonTrading.showFormOverlay();
                CommonTrading.showPriceOverlay();
                var underlying = e.target.value;
                Defaults.remove('barrier', 'barrier_high', 'barrier_low');
                Defaults.set('underlying', underlying);

                Tick.clean();

                CommonTrading.updateWarmChart();

                getContracts(underlying);

                // get ticks for current underlying
                GetTicks.request(underlying);

                CommonTrading.displayTooltip();
            }
        });

        var getContracts = function getContracts(underlying) {
            BinarySocket.send({ contracts_for: underlying }).then(function (response) {
                Notifications.hide('CONNECTION_ERROR');
                Process.processContract(response);
            });
        };

        /*
         * bind event to change in duration amount, request new price
         */
        var triggerOnDurationChange = function triggerOnDurationChange(e) {
            if (e.target.value % 1 !== 0) {
                e.target.value = Math.floor(e.target.value);
            }
            Defaults.set('duration_amount', e.target.value);
            Durations.selectAmount(e.target.value);
            Price.processPriceRequest();
            CommonTrading.submitForm(getElementById('websocket_form'));
        };
        var duration_amount_element = getElementById('duration_amount');
        var input_event_triggered = false; // For triggering one of the two events.
        if (duration_amount_element) {
            duration_amount_element.addEventListener('keypress', onlyNumericOnKeypress);
            // jquery needed for datepicker
            $('#duration_amount').on('input', CommonTrading.debounce(function (e) {
                triggerOnDurationChange(e);
                Durations.validateMinDurationAmount();
                input_event_triggered = true;
            })).on('change', CommonTrading.debounce(function (e) {
                // using Defaults, to update the value by datepicker if it was emptied by keyboard (delete)
                Durations.validateMinDurationAmount();
                if (input_event_triggered === false || !Defaults.get('duration_amount')) {
                    triggerOnDurationChange(e);
                } else {
                    input_event_triggered = false;
                }
            }));
        }

        /*
         * attach event to expiry time change, event need to populate duration
         * and request new price
         */
        getElementById('expiry_type').addEventListener('change', function (e) {
            Defaults.set('expiry_type', e.target.value);
            if (Process.onExpiryTypeChange(e.target.value)) Price.processPriceRequest();
        });

        /*
         * bind event to change in duration units, populate duration and request price
         */
        getElementById('duration_units').addEventListener('change', function (e) {
            Defaults.remove('barrier', 'barrier_high', 'barrier_low');
            Process.onDurationUnitChange(e.target.value);
            Process.processContractForm();
        });

        /*
         * bind event to change in endtime date and time
         */
        // need to use jquery as datepicker is used, if we switch to some other
        // datepicker we can move back to javascript
        Durations.expiryDateOnChange($('#expiry_date'));

        var end_time_element = getElementById('expiry_time');
        /*
         * attach datepicker and timepicker to end time durations
         * have to use jquery
         */
        attachTimePicker('#expiry_time');
        $('#expiry_time').on('focus click', function () {
            attachTimePicker('#expiry_time', 1);
        }).on('change input blur', function () {
            if (!dateValueChanged(this, 'time')) {
                return false;
            }
            Durations.setTime(end_time_element.value, 1);
            return true;
        });

        /*
         * attach event to change in amount, request new price only
         */
        var amount_element = getElementById('amount');
        amount_element.addEventListener('keypress', onlyNumericOnKeypress);
        amount_element.addEventListener('input', CommonTrading.debounce(function (e) {
            e.target.value = e.target.value.replace(/[^0-9.]/g, '');
            var currency = Defaults.get('currency');
            if (isStandardFloat(e.target.value)) {
                e.target.value = parseFloat(e.target.value).toFixed(getDecimalPlaces(currency));
            }
            Defaults.set('amount' + (isCryptocurrency(currency) ? '_crypto' : ''), e.target.value);
            Price.processPriceRequest();
            CommonTrading.submitForm(getElementById('websocket_form'));
        }));

        /*
         * attach event to change in amount, request new price only
         */
        var multiplier_element = document.getElementById('multiplier');
        if (multiplier_element) {
            multiplier_element.addEventListener('keypress', onlyNumericOnKeypress);

            multiplier_element.addEventListener('input', CommonTrading.debounce(function (e) {
                e.target.value = e.target.value.replace(/^0*(\d\.?)/, '$1');
                Defaults.set('multiplier', e.target.value);
                Price.processPriceRequest();
                CommonTrading.submitForm(document.getElementById('websocket_form'));
            }));
        }

        var timepicker_initialized = false;
        var initTimePicker = function initTimePicker() {
            if (timepicker_initialized) return;
            timepicker_initialized = true;
            attachTimePicker('#time_start');
            $time_start.on('focus click', function () {
                attachTimePicker('#time_start');
            }).on('change input blur', function () {
                if (!dateValueChanged(this, 'time')) {
                    return false;
                }
                Defaults.set('time_start', time_start_element.value);
                var make_price_request = 1;
                if (Defaults.get('expiry_date')) {
                    // if time changed, proposal will be sent there if not we should send it here
                    make_price_request = Durations.selectEndDate(moment(Defaults.get('expiry_date'))) ? -1 : 1;
                }
                if (make_price_request > 0) {
                    Price.processPriceRequest();
                }
                return true;
            });
        };

        /*
         * attach event to start time, display duration based on
         * whether start time is forward starting or not and request
         * new price
         */
        var date_start_element = CommonIndependent.getStartDateNode();
        if (date_start_element) {
            date_start_element.addEventListener('change', function (e) {
                Defaults.set('date_start', e.target.value);
                // don't show asset open hours if value is now because there is no time picker
                CommonIndependent.showAssetOpenHours(e.target.value === 'now' ? '' : $(e.target));
                initTimePicker();
                var r = Durations.onStartDateChange(e.target.value);
                if (r >= 0) {
                    Price.processPriceRequest();
                }
            });
        }

        var time_start_element = getElementById('time_start');
        var $date_start = $('#date_start');
        var $time_start = $('#time_start');
        if (date_start_element.value !== 'now') {
            initTimePicker();
        }

        /*
         * attach event to change in amount type that is whether its
         * payout or stake and request new price
         */
        getElementById('amount_type').addEventListener('change', function (e) {
            Defaults.set('amount_type', e.target.value);
            Price.processPriceRequest();
        });

        /*
         * attach event to change in submarkets. We need to disable
         * underlyings that are not in selected seubmarkets
         */
        getElementById('submarket').addEventListener('change', function (e) {
            if (e.target) {
                var elem = getElementById('underlying');
                var underlyings = elem.children;

                for (var i = 0, len = underlyings.length; i < len; i++) {
                    underlyings[i].disabled = e.target.value !== 'all' && e.target.value !== underlyings[i].className;
                }

                // as submarket change has modified the underlying list so we need to manually
                // fire change event for underlying
                document.querySelectorAll('#underlying option:enabled')[0].selected = 'selected';
                var event = new Event('change');
                elem.dispatchEvent(event);
            }
        });

        /*
         * attach an event to change in currency
         */
        $('.currency').on('change', function (e) {
            var currency = e.target.value;
            Defaults.set('currency', currency);
            var amount = isCryptocurrency(currency) ? 'amount_crypto' : 'amount';
            if (Defaults.get(amount)) $('#amount').val(Defaults.get(amount));
            Price.processPriceRequest();
        });

        /*
         * attach event to purchase buttons to buy the current contract
         */
        var $purchase_button = $('.purchase_button');
        $purchase_button.on('click dblclick', function () {
            if (isVisible(getElementById('confirmation_message_container')) || /disabled/.test(this.parentNode.classList)) {
                return;
            }
            var id = this.getAttribute('data-purchase-id');
            var ask_price = this.getAttribute('data-ask-price');

            var params = { buy: id, price: ask_price, passthrough: {} };
            Object.keys(this.attributes).forEach(function (attr) {
                if (attr && this.attributes[attr] && this.attributes[attr].name && !/data-balloon/.test(this.attributes[attr].name)) {
                    // do not send tooltip data
                    var m = this.attributes[attr].name.match(/data-(.+)/);

                    if (m && m[1] && m[1] !== 'purchase-id' && m[1] !== 'passthrough') {
                        params.passthrough[m[1]] = this.attributes[attr].value;
                    }
                }
            }, this);
            if (id && ask_price) {
                $purchase_button.parent().addClass('button-disabled');
                $(this).text(localize('Purchase request sent'));
                BinarySocket.send(params).then(function (response) {
                    Purchase.display(response);
                    GTM.pushPurchaseData(response);
                });
                Price.incrFormId();
                Price.processForgetProposals();
            }
        });

        /*
         * attach event to close icon for purchase container
         */
        $('#close_confirmation_container').on('click dblclick', function (e) {
            if (e.target && isVisible(getElementById('confirmation_message_container'))) {
                e.preventDefault();
                CommonTrading.hideOverlayContainer();
                Price.processPriceRequest();
            }
        });

        /*
         * attach an event to change in barrier
         */
        $('#barrier').on('keypress', function (ev) {
            onlyNumericOnKeypress(ev, [43, 45, 46]);
        }).on('input', CommonTrading.debounce(function (e) {
            Barriers.validateBarrier();
            Defaults.set('barrier', e.target.value);
            Price.processPriceRequest();
            CommonTrading.submitForm(getElementById('websocket_form'));
        }, 1000));

        /*
         * attach an event to change in low barrier
         */
        var low_barrier_element = getElementById('barrier_low');
        low_barrier_element.addEventListener('input', CommonTrading.debounce(function (e) {
            Barriers.validateBarrier();
            Defaults.set('barrier_low', e.target.value);
            Price.processPriceRequest();
            CommonTrading.submitForm(getElementById('websocket_form'));
        }));
        low_barrier_element.addEventListener('keypress', function (ev) {
            onlyNumericOnKeypress(ev, [43, 45, 46]);
        });

        /*
         * attach an event to change in high barrier
         */
        var high_barrier_element = getElementById('barrier_high');
        high_barrier_element.addEventListener('input', CommonTrading.debounce(function (e) {
            Barriers.validateBarrier();
            Defaults.set('barrier_high', e.target.value);
            Price.processPriceRequest();
            CommonTrading.submitForm(getElementById('websocket_form'));
        }));
        high_barrier_element.addEventListener('keypress', function (ev) {
            onlyNumericOnKeypress(ev, [43, 45, 46]);
        });

        /*
         * attach an event to change in digit prediction input
         */
        getElementById('prediction').addEventListener('change', CommonTrading.debounce(function (e) {
            Defaults.set('prediction', e.target.value);
            Price.processPriceRequest();
            CommonTrading.submitForm(getElementById('websocket_form'));
        }));

        getElementById('selected_tick').addEventListener('change', CommonTrading.debounce(function (e) {
            Defaults.set('selected_tick', e.target.value);
            Price.processPriceRequest();
            CommonTrading.submitForm(getElementById('websocket_form'));
        }));

        // Verify number of decimal places doesn't exceed the allowed decimal places according to the currency
        var isStandardFloat = function isStandardFloat(value) {
            return !isNaN(value) && value % 1 !== 0 && (+parseFloat(value)).toFixed(10).replace(/^-?\d*\.?|0+$/g, '').length > getDecimalPlaces(Defaults.get('currency'));
        };

        getElementById('trading_init_progress').addEventListener('click', CommonTrading.debounce(function () {
            CommonTrading.reloadPage();
        }));
    };

    return {
        init: initiate
    };
}();

module.exports = TradingEvents;

/***/ }),
/* 288 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.init = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();
// Should be remove in the future


var _react = __webpack_require__(117);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(228);

var _reactDom2 = _interopRequireDefault(_reactDom);

var _symbols = __webpack_require__(79);

var _symbols2 = _interopRequireDefault(_symbols);

var _defaults = __webpack_require__(23);

var _defaults2 = _interopRequireDefault(_defaults);

var _common_functions = __webpack_require__(4);

var _localize = __webpack_require__(2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function scrollToPosition(element, to, duration) {
    var requestAnimationFrame = window.requestAnimationFrame || function () {
        return setTimeout(arguments.length <= 0 ? undefined : arguments[0], 10);
    };
    if (duration <= 0) {
        element.scrollTop = to;
        return;
    }
    var difference = to - element.scrollTop;
    var per_tick = difference / duration * 10;
    requestAnimationFrame(function () {
        element.scrollTop += per_tick;
        if (element.scrollTop === to) return;
        scrollToPosition(element, to, duration - 10);
    }, 20);
}

var List = function List(_ref) {
    var arr = _ref.arr,
        saveRef = _ref.saveRef,
        underlying = _ref.underlying,
        onUnderlyingClick = _ref.onUnderlyingClick;
    return arr.map(function (_ref2, idx) {
        var _ref3 = _slicedToArray(_ref2, 2),
            market_code = _ref3[0],
            obj = _ref3[1];

        return _react2.default.createElement(
            'div',
            {
                className: 'market',
                key: idx,
                id: market_code + '_market',
                ref: saveRef.bind(null, market_code)
            },
            _react2.default.createElement(
                'div',
                { className: 'market_name' },
                obj.name
            ),
            Object.entries(obj.submarkets).sort(function (a, b) {
                return submarketSort(a[0], b[0]);
            }).map(function (_ref4, idx_2) {
                var _ref5 = _slicedToArray(_ref4, 2),
                    key = _ref5[0],
                    submarket = _ref5[1];

                return _react2.default.createElement(
                    'div',
                    { className: 'submarket', key: idx_2 },
                    _react2.default.createElement(
                        'div',
                        { className: 'submarket_name' },
                        submarket.name
                    ),
                    _react2.default.createElement(
                        'div',
                        { className: 'symbols' },
                        Object.entries(submarket.symbols).map(function (_ref6) {
                            var _ref7 = _slicedToArray(_ref6, 2),
                                u_code = _ref7[0],
                                symbol = _ref7[1];

                            return _react2.default.createElement(
                                'div',
                                {
                                    className: 'symbol_name ' + (u_code === underlying ? 'active' : ''),
                                    key: u_code,
                                    id: u_code,
                                    onClick: onUnderlyingClick.bind(null, u_code, market_code)
                                },
                                symbol.display
                            );
                        })
                    )
                );
            })
        );
    });
};

var submarket_order = {
    forex: 0,
    major_pairs: 1,
    minor_pairs: 2,
    smart_fx: 3,
    indices: 4,
    asia_oceania: 5,
    europe_africa: 6,
    americas: 7,
    otc_index: 8,
    stocks: 9,
    au_otc_stock: 10,
    ge_otc_stock: 11,
    india_otc_stock: 12,
    uk_otc_stock: 13,
    us_otc_stock: 14,
    commodities: 15,
    metals: 16,
    energy: 17,
    volidx: 18,
    random_index: 19,
    random_daily: 20,
    random_nightly: 21
};

var submarketSort = function submarketSort(a, b) {
    if (submarket_order[a] > submarket_order[b]) {
        return 1;
    } else if (submarket_order[a] < submarket_order[b]) {
        return -1;
    }
    return 0;
};

var Markets = function (_React$Component) {
    _inherits(Markets, _React$Component);

    function Markets(props) {
        _classCallCheck(this, Markets);

        var _this = _possibleConstructorReturn(this, (Markets.__proto__ || Object.getPrototypeOf(Markets)).call(this, props));

        _initialiseProps.call(_this);

        var market_symbol = _defaults2.default.get('market');
        _this.markets = _symbols2.default.markets();

        _this.underlyings = _symbols2.default.getAllSymbols() || {};
        var underlying_symbol = _defaults2.default.get('underlying');
        if (!underlying_symbol || !_this.underlyings[underlying_symbol]) {
            var submarket = Object.keys(_this.markets[market_symbol].submarkets).sort(submarketSort)[0];
            underlying_symbol = Object.keys(_this.markets[market_symbol].submarkets[submarket].symbols).sort()[0];
        }
        var markets_arr = Object.entries(_this.markets).sort(function (a, b) {
            return submarketSort(a[0], b[0]);
        });
        _this.markets_all = markets_arr.slice();
        if (!(market_symbol in _this.markets)) {
            market_symbol = Object.keys(_this.markets).find(function (m) {
                return _this.markets[m].submarkets[market_symbol];
            });
            _defaults2.default.set('market', market_symbol);
        }
        _this.el_underlying = (0, _common_functions.getElementById)('underlying');
        _this.references = {};
        _this.state = {
            open: false,
            market: {
                symbol: market_symbol,
                name: _this.markets[market_symbol].name
            },
            underlying: {
                symbol: underlying_symbol,
                name: _this.underlyings[underlying_symbol]
            },
            markets: markets_arr,
            active_market: market_symbol,
            query: ''
        };
        _this.el_underlying.value = underlying_symbol;
        return _this;
    }

    _createClass(Markets, [{
        key: 'componentDidMount',
        value: function componentDidMount() {
            document.body.addEventListener('click', this.handleClickOutside);
        }
    }, {
        key: 'componentWillUnmount',
        value: function componentWillUnmount() {
            document.body.removeEventListener('click', this.closeDropdown);
        }

        /* eslint-disable no-undef */


        /* eslint-disable no-shadow */

    }, {
        key: 'render',

        /* eslint-enable no-shadow */
        /* eslint-enable no-undef */
        value: function render() {
            var _state = this.state,
                active_market = _state.active_market,
                markets = _state.markets,
                underlying = _state.underlying,
                query = _state.query,
                market = _state.market,
                open = _state.open;
            var getCurrentUnderlying = this.getCurrentUnderlying,
                openDropdown = this.openDropdown,
                closeDropdown = this.closeDropdown,
                searchSymbols = this.searchSymbols,
                handleScroll = this.handleScroll,
                saveMarketRef = this.saveMarketRef,
                onUnderlyingClick = this.onUnderlyingClick,
                saveRef = this.saveRef,
                scrollToMarket = this.scrollToMarket;

            return _react2.default.createElement(
                'div',
                { className: 'markets' },
                _react2.default.createElement(
                    'div',
                    {
                        className: 'market_current',
                        onClick: openDropdown
                    },
                    _react2.default.createElement(
                        'span',
                        { className: 'market' },
                        market.name,
                        _react2.default.createElement('span', { className: 'arrow_down' })
                    ),
                    _react2.default.createElement(
                        'span',
                        { className: 'underlying' },
                        getCurrentUnderlying()
                    )
                ),
                _react2.default.createElement(
                    'div',
                    {
                        className: 'markets_dropdown ' + (open ? '' : 'hidden'),
                        ref: saveRef.bind(null, 'wrapper_ref')
                    },
                    _react2.default.createElement(
                        'div',
                        { className: 'asset-placeholder mobile' },
                        _react2.default.createElement(
                            'span',
                            null,
                            (0, _localize.localize)('Select Asset')
                        ),
                        _react2.default.createElement('span', { className: 'close', onClick: closeDropdown })
                    ),
                    _react2.default.createElement(
                        'div',
                        { className: 'search' },
                        _react2.default.createElement('input', {
                            type: 'text',
                            maxLength: 20,
                            onInput: searchSymbols,
                            placeholder: (0, _localize.localize)('Search...'),
                            value: query
                        }),
                        _react2.default.createElement('span', { className: 'icon' })
                    ),
                    _react2.default.createElement(
                        'div',
                        { className: 'markets_view' },
                        _react2.default.createElement(
                            'div',
                            { className: 'markets_column' },
                            _react2.default.createElement(
                                'div',
                                { className: 'desktop' },
                                markets.map(function (_ref8) {
                                    var _ref9 = _slicedToArray(_ref8, 2),
                                        key = _ref9[0],
                                        obj = _ref9[1];

                                    return _react2.default.createElement(
                                        'div',
                                        {
                                            className: 'market ' + (active_market === key ? 'active' : ''),
                                            key: key,
                                            onClick: scrollToMarket.bind(null, '' + key)
                                        },
                                        _react2.default.createElement('span', { className: 'icon ' + key + ' ' + (active_market === key ? 'active' : '') }),
                                        _react2.default.createElement(
                                            'span',
                                            null,
                                            obj.name
                                        )
                                    );
                                })
                            ),
                            _react2.default.createElement(
                                'div',
                                { className: 'mobile' },
                                _react2.default.createElement(
                                    'ul',
                                    null,
                                    markets.map(function (_ref10) {
                                        var _ref11 = _slicedToArray(_ref10, 1),
                                            key = _ref11[0];

                                        return _react2.default.createElement(
                                            'li',
                                            {
                                                onClick: scrollToMarket.bind(null, key),
                                                key: key,
                                                'data-market': key,
                                                className: active_market === key ? 'active' : ''
                                            },
                                            _react2.default.createElement('span', { className: 'icon ' + key + ' ' + (active_market === key ? 'active' : '') })
                                        );
                                    })
                                )
                            )
                        ),
                        _react2.default.createElement(
                            'div',
                            {
                                className: 'list',
                                ref: saveRef.bind(null, 'list'),
                                onScroll: handleScroll
                            },
                            _react2.default.createElement(List, {
                                arr: markets,
                                saveRef: saveMarketRef,
                                underlying: underlying.symbol,
                                onUnderlyingClick: onUnderlyingClick
                            })
                        )
                    )
                )
            );
        }
    }]);

    return Markets;
}(_react2.default.Component);

var _initialiseProps = function _initialiseProps() {
    var _this2 = this;

    this.closeDropdown = function () {
        _this2.setState({
            open: false,
            query: '',
            markets: _this2.markets_all
        });
    };

    this.getCurrentUnderlying = function () {
        var underlying = _this2.state.underlying.name;

        var max_char = window.innerWidth <= 767 ? 15 : 25;
        if (underlying.length > max_char) {
            return underlying.substr(0, max_char) + '...';
        }
        return underlying;
    };

    this.handleClickOutside = function (e) {
        if (_this2.references.wrapper_ref && !_this2.references.wrapper_ref.contains(e.target) && _this2.state.open) {
            _this2.closeDropdown();
        }
    };

    this.handleScroll = function (e) {
        var _references = _this2.references,
            market_nodes = _references.market_nodes,
            list = _references.list;

        var position = e.target.scrollTop + list.offsetTop;
        var arr = [];
        var curr_market = null;
        Object.entries(market_nodes).forEach(function (_ref12) {
            var _ref13 = _slicedToArray(_ref12, 2),
                key = _ref13[0],
                node = _ref13[1];

            if (node && node.offsetParent && node.offsetTop - 41 <= position) {
                arr.push(key);
            }
        });
        if (_this2.state.active_market !== arr[arr.length - 1]) {
            if (position <= 10) {
                curr_market = arr[0];
            } else {
                curr_market = arr[arr.length - 1];
            }
            _this2.setState({ active_market: curr_market });
        }

        _this2.stickyHeader(position);
    };

    this.openDropdown = function () {
        _this2.setState({ open: true });
        Object.values(_this2.references.market_nodes).forEach(function (node) {
            node.classList.remove('put_under');
            node.removeAttribute('style');
            node.children[0].classList.remove('sticky');
            node.children[0].removeAttribute('style');
        });
        _this2.references.list.scrollTop = 0;
        _this2.scrollToElement(_this2.state.underlying.symbol, 0, 70);
    };

    this.onUnderlyingClick = function (underlying_symbol, market_symbol) {
        _defaults2.default.set('underlying', underlying_symbol);
        _defaults2.default.set('market', market_symbol);

        _this2.setState({
            market: {
                symbol: market_symbol,
                name: _this2.markets[market_symbol].name
            },
            underlying: {
                symbol: underlying_symbol,
                name: _this2.underlyings[underlying_symbol]
            }
        });

        // Trigger change event.
        // TODO: move this block to componentDidUpdate
        _this2.el_underlying.value = underlying_symbol;
        _this2.el_underlying.setAttribute('data-text', _this2.underlyings[underlying_symbol]);
        var event = new Event('change');
        _this2.el_underlying.dispatchEvent(event);

        _this2.closeDropdown();
        /* Todo add notification for closed markets */
        // Notifications.show({ text: localize('All markets are closed now. Please try again later.'), uid: 'MARKETS_CLOSED' });
    };

    this.onTabChange = function (e) {
        var market = e.target.dataset.market;
        _this2.scrollToElement(market + '_market', 120, 0);
    };

    this.saveRef = function (node_name, node) {
        return _this2.references[node_name] = node;
    };

    this.scrollToElement = function (id) {
        var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 120;
        var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

        // handleScroll is triggered automatically which sets the active market.
        var list = _this2.references.list;

        var to_offset = (0, _common_functions.getElementById)(id).offsetTop - list.offsetTop - offset;
        scrollToPosition(list, to_offset, duration);
    };

    this.stickyHeader = function (position) {
        var curr = void 0,
            prev = void 0,
            next = void 0;
        var market_nodes = _this2.references.market_nodes;

        var market_keys = Object.keys(market_nodes);
        var TITLE_HEIGHT = 40;
        Object.values(market_nodes).forEach(function (node, idx) {
            if (node.dataset.offsetTop <= position && +node.dataset.offsetHeight + +node.dataset.offsetTop > position) {
                curr = node;
                prev = idx > 0 ? market_nodes[market_keys[idx - 1]] : null;
                next = idx < market_keys.length ? market_nodes[market_keys[idx + 1]] : null;
            }
        });

        var class_sticky = 'sticky';
        var class_under = 'put_under';
        var DEFAULT_TOP = _this2.references.list.offsetTop;

        if (curr) {
            curr.children[0].removeAttribute('style');
            curr.removeAttribute('style');
            curr.children[0].classList.remove(class_under);
            var diff = +curr.dataset.offsetHeight + +curr.dataset.offsetTop - position;
            if (diff > 0 && diff < TITLE_HEIGHT) {
                curr.children[0].style.top = DEFAULT_TOP - (TITLE_HEIGHT - diff) + 'px';
                curr.children[0].classList.add(class_under);
            }
            curr.children[0].classList.add(class_sticky);
            curr.style.paddingTop = TITLE_HEIGHT + 'px';
        }
        if (prev) {
            prev.removeAttribute('style');
            prev.children[0].removeAttribute('style');
            prev.children[0].classList.remove(class_under, class_sticky);
        }
        if (next) {
            next.children[0].classList.remove(class_sticky, class_under);
            next.removeAttribute('style');
        }
    };

    this.saveMarketRef = function (market, node) {
        if (!node) return;
        if (!_this2.references.market_nodes) _this2.references.market_nodes = {};
        _this2.references.market_nodes[market] = node;
        // Save offsets of elements for sticky headers.
        node.dataset.offsetTop = node.offsetTop;
        node.dataset.offsetHeight = node.offsetHeight;
    };

    this.searchSymbols = function (_ref14) {
        var query = _ref14.target.value;

        _this2.setState({ query: query });
        scrollToPosition(_this2.references.list, 0, 0);
        var markets_all = _this2.markets_all;
        if (!query) {
            _this2.setState({ markets: markets_all });
            return;
        }
        var filter_markets = [];
        markets_all.map(function (_ref15) {
            var _ref16 = _slicedToArray(_ref15, 2),
                key = _ref16[0],
                market = _ref16[1];

            var found_for_market = false; // To check market contains any matching underlying.
            var filter_submarkets = {};
            Object.entries(market.submarkets).map(function (_ref17) {
                var _ref18 = _slicedToArray(_ref17, 2),
                    key_2 = _ref18[0],
                    submarket = _ref18[1];

                var found_for_submarket = false; // Same as found for market
                var filter_symbols = {};
                Object.entries(submarket.symbols).map(function (_ref19) {
                    var _ref20 = _slicedToArray(_ref19, 2),
                        key_3 = _ref20[0],
                        symbol = _ref20[1];

                    var queries = query.split(',');
                    if (queries.reduce(function (a, b) {
                        return symbol.display.toLowerCase().includes(b.toLowerCase()) || a;
                    }, false)) {
                        filter_symbols[key_3] = symbol;
                        found_for_market = true;
                        found_for_submarket = true;
                    }
                });
                if (found_for_submarket) {
                    filter_submarkets[key_2] = JSON.parse(JSON.stringify(submarket));
                    filter_submarkets[key_2].symbols = filter_symbols;
                }
            });
            if (found_for_market) {
                var market_copy = JSON.parse(JSON.stringify(market));
                market_copy.submarkets = filter_submarkets;
                filter_markets.push([key, market_copy]);
            }
        });

        // nothing found
        if (!filter_markets.length) return;

        _this2.setState({ markets: filter_markets, active_market: filter_markets[0][0] });
    };

    this.scrollToMarket = function (key) {
        var list = _this2.references.list;

        var node = _this2.references.market_nodes[key];
        var offset = node.dataset.offsetTop - list.offsetTop;
        scrollToPosition(list, offset, 250);
    };
};

var init = exports.init = function init() {
    _reactDom2.default.render(_react2.default.createElement(Markets, null), (0, _common_functions.getElementById)('underlying_component'));
};

exports.default = init;

/***/ }),
/* 289 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Dropdown = __webpack_require__(25).selectDropdown;
var moment = __webpack_require__(9);
var CommonIndependent = __webpack_require__(47);
var Contract = __webpack_require__(58);
var Defaults = __webpack_require__(23);
var Durations = __webpack_require__(125);
var getElementById = __webpack_require__(4).getElementById;
var localize = __webpack_require__(2).localize;
var State = __webpack_require__(6).State;
var createElement = __webpack_require__(1).createElement;

/*
 * Handles start time display
 *
 * It process `Contract.startDates` in case of forward
 * starting contracts and populate the start time select
 * box
 */

var StartDates = function () {
    var has_now = 0;
    State.remove('is_start_dates_displayed');

    var compareStartDate = function compareStartDate(a, b) {
        var sort = 0;
        if (a.date !== b.date) {
            sort = a.date > b.date ? 1 : -1;
        }
        return sort;
    };

    var displayStartDates = function displayStartDates() {
        var start_dates = Contract.startDates();

        if (start_dates && start_dates.list && start_dates.list.length) {
            var target = CommonIndependent.getStartDateNode();
            var fragment = document.createDocumentFragment();
            var option = void 0,
                first = void 0,
                selected = void 0,
                day = void 0,
                $duplicated_option = void 0;

            getElementById('date_start_row').style.display = 'flex';

            while (target && target.firstChild) {
                target.removeChild(target.firstChild);
            }

            if (start_dates.has_spot) {
                option = createElement('option', { value: 'now', text: localize('Now') });
                fragment.appendChild(option);
                has_now = 1;
            } else {
                has_now = 0;
            }

            start_dates.list.sort(compareStartDate);
            var default_start = Defaults.get('date_start') || 'now';

            var rounding = 5 * 60 * 1000;
            var now = moment.utc();
            start_dates.list.forEach(function (start_date) {
                var date_open = moment.unix(start_date.open).utc();
                var date_close = moment.unix(start_date.close).utc();

                if (date_close.isAfter(now)) {
                    if (now.isAfter(date_open)) {
                        date_open = now;
                    }

                    date_open = moment.utc(Math.ceil(+date_open / rounding) * rounding);
                    day = date_open.format('ddd - DD MMM, YYYY');
                    $duplicated_option = $(fragment).find('option:contains(' + day + ')');
                    if ($duplicated_option.length) {
                        $duplicated_option.attr('data-sessions', $duplicated_option.attr('data-sessions') + ', ' + date_open.format('HH:mm') + '-' + date_close.format('HH:mm'));
                        if (+date_close.unix() > +$duplicated_option.attr('data-end')) {
                            $duplicated_option.attr('data-end', date_close.unix());
                        }
                    } else {
                        option = createElement('option', { value: date_open.unix(), 'data-end': date_close.unix(), 'data-sessions': date_open.format('HH:mm') + '-' + date_close.format('HH:mm'), text: day });
                        if (option.value >= default_start && !selected) {
                            selected = true;
                            option.setAttribute('selected', 'selected');
                        }
                        if (typeof first === 'undefined' && !has_now) {
                            first = date_open.unix();
                        }
                        fragment.appendChild(option);
                    }
                }
            });
            if (target) {
                target.appendChild(fragment);
                Dropdown('#date_start');
                Defaults.set('date_start', target.value);
                CommonIndependent.showAssetOpenHours(target.value === 'now' ? '' : $(target));
                $('#time_start_row').setVisibility(target.value !== 'now');
            }
            State.set('is_start_dates_displayed', true);
            if (first) {
                Durations.onStartDateChange(first);
            }
        } else {
            State.remove('is_start_dates_displayed');
            getElementById('date_start_row').style.display = 'none';
            getElementById('date_start').value = 'now';
            Defaults.remove('date_start');
        }
    };

    return {
        display: displayStartDates,
        disable: function disable() {
            CommonIndependent.getStartDateNode().setAttribute('disabled', 'disabled');
        },
        enable: function enable() {
            CommonIndependent.getStartDateNode().removeAttribute('disabled');
        }
    };
}();

module.exports = {
    StartDates: StartDates
};

/***/ }),
/* 290 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Dropdown = __webpack_require__(25).selectDropdown;
var TradingAnalysis = __webpack_require__(88);
var commonTrading = __webpack_require__(31);
var cleanupChart = __webpack_require__(89).cleanupChart;
var displayCurrencies = __webpack_require__(286);
var Defaults = __webpack_require__(23);
var TradingEvents = __webpack_require__(287);
var Price = __webpack_require__(100);
var Process = __webpack_require__(177);
var ViewPopup = __webpack_require__(90);
var BinaryPjax = __webpack_require__(12);
var Client = __webpack_require__(3);
var Header = __webpack_require__(27);
var BinarySocket = __webpack_require__(5);
var Guide = __webpack_require__(263);
var State = __webpack_require__(6).State;

var TradePage = function () {
    var events_initialized = 0;
    State.remove('is_trading');

    var onLoad = function onLoad() {
        BinarySocket.wait('authorize').then(function () {
            init();
        });
    };

    var init = function init() {
        if (Client.isJPClient()) {
            BinaryPjax.load('multi_barriers_trading');
            return;
        }
        State.set('is_trading', true);
        Price.clearFormId();
        if (events_initialized === 0) {
            events_initialized = 1;
            TradingEvents.init();
        }

        BinarySocket.wait('authorize').then(function () {
            if (Client.get('is_virtual')) {
                Header.upgradeMessageVisibility(); // To handle the upgrade buttons visibility
            }
            Client.activateByClientType('trading_socket_container');
            BinarySocket.send({ payout_currencies: 1 }).then(function () {
                displayCurrencies();
                Dropdown('#currency', true);
                if (document.getElementById('multiplier_currency').tagName === 'SELECT') {
                    Dropdown('#multiplier_currency', true);
                }
                Process.processActiveSymbols();

                var $currency = $('.currency');

                // if currency symbol is span, restore back from custom dropdown
                if ($currency.is('span') && $currency.parent('div.select').length) {
                    $currency.parent().replaceWith(function () {
                        var curr_element = $currency;
                        return curr_element;
                    });
                    if ($currency.next().attr('id') === $currency.attr('id')) $currency.next().eq(0).remove();
                }
            });
        });

        if (document.getElementById('websocket_form')) {
            commonTrading.addEventListenerForm();
        }

        // Walk-through Guide
        Guide.init({
            script: 'trading'
        });
        TradingAnalysis.bindAnalysisTabEvent();

        ViewPopup.viewButtonOnClick('#contract_confirmation_container');
    };

    var reload = function reload() {
        sessionStorage.removeItem('underlying');
        window.location.reload();
    };

    var onUnload = function onUnload() {
        State.remove('is_trading');
        events_initialized = 0;
        Process.forgetTradingStreams();
        BinarySocket.clear();
        Defaults.clear();
        cleanupChart();
        commonTrading.clean();
        BinarySocket.clear('active_symbols');
        TradingAnalysis.onUnload();
    };

    var onDisconnect = function onDisconnect() {
        commonTrading.showPriceOverlay();
        commonTrading.showFormOverlay();
        cleanupChart();
        onLoad();
    };

    return {
        onLoad: onLoad,
        reload: reload,
        onUnload: onUnload,
        onDisconnect: onDisconnect
    };
}();

module.exports = TradePage;

/***/ }),
/* 291 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var DocumentUploader = __webpack_require__(344);
var Client = __webpack_require__(3);
var displayNotification = __webpack_require__(27).displayNotification;
var BinarySocket = __webpack_require__(5);
var localize = __webpack_require__(2).localize;
var toTitleCase = __webpack_require__(17).toTitleCase;
var Url = __webpack_require__(8);
var showLoadingImage = __webpack_require__(1).showLoadingImage;

var Authenticate = function () {
    var needs_action = false;

    var onLoad = function onLoad() {
        BinarySocket.send({ get_account_status: 1 }).then(function (response) {
            $('#loading_authenticate').remove();
            if (response.error) {
                $('#error_message').setVisibility(1).text(response.error.message);
            } else {
                var status = response.get_account_status.status;
                needs_action = /document_needs_action/.test(response.get_account_status.status);
                if (!/authenticated/.test(status)) {
                    init();
                    var $not_authenticated = $('#not_authenticated').setVisibility(1);
                    var link = 'https://marketing.binary.com/authentication/2017_Authentication_Process.pdf';
                    if (Client.isAccountOfType('financial')) {
                        $('#not_authenticated_financial').setVisibility(1);
                        link = 'https://marketing.binary.com/authentication/2017_MF_Authentication_Process.pdf';
                    }
                    $not_authenticated.find('.learn_more').setVisibility(1).find('a').attr('href', link);
                } else if (!/age_verification/.test(status)) {
                    $('#needs_age_verification').setVisibility(1);
                } else {
                    $('#fully_authenticated').setVisibility(1);
                }
            }
        });
    };

    var init = function init() {
        // Setup accordion
        $('.files').accordion({
            heightStyle: 'content',
            collapsible: true,
            active: false
        });
        var file_checks = {};
        // Setup Date picker
        $('.date-picker').datepicker({
            dateFormat: 'yy-mm-dd',
            changeMonth: true,
            changeYear: true,
            minDate: '+6m'
        });

        $('.file-picker').on('change', onFileSelected);

        /**
         * Listens for file changes.
         * @param {*} event
         */
        function onFileSelected(event) {
            if (!event.target.files || !event.target.files.length) {
                resetLabel(event);
                return;
            }
            // Change submit button state
            showSubmit();
            var $e = $(event.target);
            var file_name = event.target.files[0].name || '';
            var display_name = file_name.length > 10 ? file_name.slice(0, 5) + '..' + file_name.slice(-5) : file_name;

            $e.parent().find('label').off('click')
            // Prevent opening file selector.
            .on('click', function (e) {
                if ($(e.target).is('span.remove')) e.preventDefault();
            }).text(display_name).append($('<span/>', { class: 'remove' })).find('.remove').click(function () {
                return resetLabel(event);
            });
        };

        // Reset file-selector label
        var resetLabel = function resetLabel(event) {
            var $e = $(event.target);
            var default_text = toTitleCase($e.attr('id').split('_')[0]);
            if (default_text !== 'Add') {
                default_text = default_text === 'Back' ? localize('Reverse Side') : localize('Front Side');
            }
            fileTracker($e, false);
            // Remove previously selected file and set the label
            $e.val('').parent().find('label').text(default_text).append($('<span/>', { class: 'add' }));
            // Change submit button state
            showSubmit();
        };

        /**
         * Enables the submit button if any file is selected, also adds the event handler for the button.
         * Disables the button if it no files are selected.
         */
        var $button = void 0;
        var showSubmit = function showSubmit() {
            var file_selected = false;
            var $ele = $('#authentication-message > div#not_authenticated');
            $button = $ele.find('#btn_submit');
            var $files = $ele.find('input[type="file"]');

            // Check if any files are selected or not.
            $files.each(function (i, e) {
                if (e.files && e.files.length) {
                    file_selected = true;
                }
            });

            if (file_selected) {
                if ($button.hasClass('button')) return;
                $button.removeClass('button-disabled').addClass('button').off('click') // To avoid binding multiple click events
                .click(function () {
                    return submitFiles($files);
                });
            } else {
                if ($button.hasClass('button-disabled')) return;
                $button.removeClass('button').addClass('button-disabled').off('click');
            }
        };

        var disableButton = function disableButton() {
            if ($button.length && !$button.find('.barspinner').length) {
                var $btn_text = $('<span/>', { text: $button.find('span').text(), class: 'invisible' });
                showLoadingImage($button.find('span'), 'white');
                $button.find('span').append($btn_text);
            }
        };

        var enableButton = function enableButton() {
            if ($button.length && $button.find('.barspinner').length) {
                $button.find('>span').html($button.find('>span>span').text());
            }
        };

        /**
         * On submit button click
         */
        var submitFiles = function submitFiles($files) {
            // Disable submit button
            disableButton();
            var files = [];
            $files.each(function (i, e) {
                if (e.files && e.files.length) {
                    var $e = $(e);
                    var type = '' + ($e.attr('data-type') || '').replace(/\s/g, '_').toLowerCase();
                    var name = $e.attr('data-name');
                    var $inputs = $e.closest('.fields').find('input[type="text"]');
                    var file_obj = {
                        file: e.files[0],
                        type: type,
                        name: name
                    };
                    if ($inputs.length) {
                        file_obj.id_number = $($inputs[0]).val();
                        file_obj.exp_date = $($inputs[1]).val();
                    }
                    fileTracker($e, true);
                    files.push(file_obj);
                }
            });
            processFiles(files);
        };

        var processFiles = function processFiles(files) {
            var promises = [];
            var uploader = new DocumentUploader({ connection: BinarySocket.get() });

            readFiles(files).then(function (objects) {
                objects.forEach(function (obj) {
                    return promises.push(uploader.upload(obj));
                });
                Promise.all(promises).then(onResponse).catch(showError);
            }).catch(showError);
        };

        // Returns file promise.
        var readFiles = function readFiles(files) {
            var promises = [];
            files.forEach(function (f) {
                var fr = new FileReader();
                var promise = new Promise(function (resolve, reject) {
                    fr.onload = function () {
                        var format = (f.file.type.split('/')[1] || (f.file.name.match(/\.([\w\d]+)$/) || [])[1] || '').toUpperCase();
                        var obj = {
                            filename: f.file.name,
                            buffer: fr.result,
                            documentType: f.type,
                            documentFormat: format,
                            documentId: f.id_number || undefined,
                            expirationDate: f.exp_date || undefined,
                            passthrough: {
                                filename: f.file.name,
                                name: f.name
                            }
                        };

                        var error = { message: validate(obj) };
                        if (error && error.message) reject(error);

                        resolve(obj);
                    };

                    fr.onerror = function () {
                        reject('Unable to read file ' + f.file.name);
                    };
                    // Reading file.
                    fr.readAsArrayBuffer(f.file);
                });

                promises.push(promise);
            });

            return Promise.all(promises);
        };

        var fileTracker = function fileTracker($e, selected) {
            var doc_type = ($e.attr('data-type') || '').replace(/\s/g, '_').toLowerCase();
            var file_type = ($e.attr('id').match(/\D+/g) || [])[0];
            // Keep track of front and back sides of files.
            if (selected) {
                file_checks[doc_type] = file_checks[doc_type] || {};
                file_checks[doc_type][file_type] = true;
            } else if (file_checks[doc_type]) {
                file_checks[doc_type][file_type] = false;
            }
        };

        // Validate user input
        var validate = function validate(file) {
            var required_docs = ['passport', 'proofid', 'driverslicense'];
            var doc_name = {
                passport: localize('Passport'),
                proofid: localize('Identity card'),
                driverslicense: localize('Driving licence')
            };

            if (!(file.documentFormat || '').match(/^(PNG|JPG|JPEG|GIF|PDF)$/i)) {
                return localize('Invalid document format: "[_1]"', [file.documentFormat]);
            }
            if (file.buffer && file.buffer.byteLength >= 3 * 1024 * 1024) {
                return localize('File ([_1]) size exceeds the permitted limit. Maximum allowed file size: 3MB', [file.filename]);
            }
            if (!file.documentId && required_docs.indexOf(file.documentType.toLowerCase()) !== -1) {
                return localize('ID number is required for [_1].', [doc_name[file.documentType]]);
            }
            if (file.documentId && !/^[\w\s-]{0,30}$/.test(file.documentId)) {
                return localize('Only letters, numbers, space, underscore, and hyphen are allowed for ID number ([_1]).', [doc_name[file.documentType]]);
            }
            if (!file.expirationDate && required_docs.indexOf(file.documentType.toLowerCase()) !== -1) {
                return localize('Expiry date is required for [_1].', [doc_name[file.documentType]]);
            }
            // These checks will only be executed when the user uploads the files for the first time, otherwise skipped.
            if (!needs_action) {
                if (file_checks.proofid && file_checks.proofid.front_file ^ file_checks.proofid.back_file) {
                    // eslint-disable-line no-bitwise
                    return localize('Front and reverse side photos of [_1] are required.', [doc_name.proofid]);
                }
                if (file_checks.driverslicense && file_checks.driverslicense.front_file ^ file_checks.driverslicense.back_file) {
                    // eslint-disable-line no-bitwise
                    return localize('Front and reverse side photos of [_1] are required.', [doc_name.driverslicense]);
                }
            }

            return null;
        };

        var showError = function showError(e) {
            var $error = $('.error-msg');
            var message = e.message || e.message_to_client;
            enableButton();
            $error.setVisibility(1).text(message);
            setTimeout(function () {
                $error.empty().setVisibility(0);
            }, 3000);
        };

        var showSuccess = function showSuccess() {
            var msg = localize('We are reviewing your documents. For more details [_1]contact us[_2].', ['<a href="' + Url.urlFor('contact') + '">', '</a>']);
            displayNotification(msg, false, 'document_under_review');
            $('#not_authenticated, #not_authenticated_financial').setVisibility(0); // Just hide it
            $('#success-message').setVisibility(1);
        };

        var onResponse = function onResponse(res) {
            var dup_files = [];
            var successAny = false;
            res.forEach(function (file) {
                var passthrough = file.passthrough;
                if (!file.warning) {
                    successAny = true;
                } else {
                    dup_files.push(passthrough.filename + '(' + passthrough.name + ')');
                }
            });
            if (successAny) {
                showSuccess();
            } else {
                showError({ message: localize('Following file(s) were already uploaded: [_1]', ['[ ' + dup_files.join(', ') + ' ]']) });
            }
        };
    };

    return {
        onLoad: onLoad
    };
}();

module.exports = Authenticate;

/***/ }),
/* 292 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BinaryPjax = __webpack_require__(12);
var Client = __webpack_require__(3);
var BinarySocket = __webpack_require__(5);
var FormManager = __webpack_require__(18);
var localize = __webpack_require__(2).localize;
var State = __webpack_require__(6).State;

var ChangePassword = function () {
    var form_id = '#frm_change_password';

    var init = function init() {
        FormManager.init(form_id, [{ selector: '#old_password', validations: ['req', ['length', { min: 6, max: 25 }]] }, { selector: '#new_password', validations: ['req', 'password', ['not_equal', { to: '#old_password', name1: 'Current password', name2: 'New password' }]], re_check_field: '#repeat_password' }, { selector: '#repeat_password', validations: ['req', ['compare', { to: '#new_password' }]], exclude_request: 1 }, { request_field: 'change_password', value: 1 }]);
        FormManager.handleSubmit({
            form_selector: form_id,
            fnc_response_handler: handler
        });
    };

    var handler = function handler(response) {
        if ('error' in response) {
            $('#form_error').text(localize(response.error.message)).setVisibility(1);
        } else {
            $(form_id).setVisibility(0);
            $('#msg_success').setVisibility(1);
            setTimeout(function () {
                Client.sendLogoutRequest(true);
            }, 5000);
        }
    };

    var onLoad = function onLoad() {
        BinarySocket.wait('get_account_status').then(function () {
            var status = State.getResponse('get_account_status.status');
            if (!/social_signup/.test(status)) {
                init();
            } else {
                BinaryPjax.loadPreviousUrl();
            }
        });
    };

    return {
        onLoad: onLoad
    };
}();

module.exports = ChangePassword;

/***/ }),
/* 293 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var PaymentAgentTransferUI = __webpack_require__(294);
var Client = __webpack_require__(3);
var BinarySocket = __webpack_require__(5);
var getDecimalPlaces = __webpack_require__(7).getDecimalPlaces;
var FormManager = __webpack_require__(18);
var localize = __webpack_require__(2).localize;
var State = __webpack_require__(6).State;

var PaymentAgentTransfer = function () {
    var is_authenticated_payment_agent = void 0,
        common_request_fields = void 0,
        $form_error = void 0;

    var onLoad = function onLoad() {
        PaymentAgentTransferUI.initValues();
        BinarySocket.wait('get_settings', 'balance').then(function () {
            is_authenticated_payment_agent = State.getResponse('get_settings.is_authenticated_payment_agent');
            if (is_authenticated_payment_agent) {
                BinarySocket.send({
                    paymentagent_list: Client.get('residence'),
                    currency: Client.get('currency')
                }).then(function (response) {
                    var pa_values = response.paymentagent_list.list.filter(function (a) {
                        return a.paymentagent_loginid === Client.get('loginid');
                    })[0];
                    init(pa_values);
                });
            } else {
                setFormVisibility(false);
            }
        });
    };

    var init = function init(pa) {
        var form_id = '#frm_paymentagent_transfer';
        var $no_bal_err = $('#no_balance_error');
        var currency = Client.get('currency');

        $form_error = $('#form_error');

        if (!currency || +Client.get('balance') === 0) {
            $('#pa_transfer_loading').remove();
            $no_bal_err.setVisibility(1);
            return;
        }

        $no_bal_err.setVisibility(0);
        setFormVisibility(true);
        PaymentAgentTransferUI.updateFormView(currency);

        common_request_fields = [{ request_field: 'paymentagent_transfer', value: 1 }, { request_field: 'currency', value: currency }];

        FormManager.init(form_id, [{ selector: '#client_id', validations: ['req', ['regular', { regex: /^\w+\d+$/, message: 'Please enter a valid Login ID.' }]], request_field: 'transfer_to' }, { selector: '#amount', validations: ['req', ['number', { type: 'float', decimals: getDecimalPlaces(currency), min: pa ? pa.min_withdrawal : 10, max: pa ? pa.max_withdrawal : 2000 }], ['custom', { func: function func() {
                    return +Client.get('balance') >= +$('#amount').val();
                }, message: localize('Insufficient balance.') }]] }, { request_field: 'dry_run', value: 1 }].concat(common_request_fields));

        FormManager.handleSubmit({
            form_selector: form_id,
            fnc_response_handler: responseHandler,
            enable_button: 1
        });
    };

    var setFormVisibility = function setFormVisibility(is_visible) {
        if (is_visible) {
            $('#pa_transfer_loading').remove();
            PaymentAgentTransferUI.showForm();
            PaymentAgentTransferUI.showNotes();
        } else {
            PaymentAgentTransferUI.hideForm();
            PaymentAgentTransferUI.hideNotes();
            if (!is_authenticated_payment_agent) {
                $('#pa_transfer_loading').remove();
                $('#not_pa_error').setVisibility(1);
            }
        }
    };

    var responseHandler = function responseHandler(response) {
        var req = response.echo_req;
        var error = response.error;

        if (error) {
            if (req.dry_run === 1) {
                $form_error.text(error.message).setVisibility(1);
                return;
            }
            PaymentAgentTransferUI.showTransferError(error.message);
            return;
        }

        if (response.paymentagent_transfer === 2) {
            PaymentAgentTransferUI.hideFirstForm();
            PaymentAgentTransferUI.showConfirmation();
            PaymentAgentTransferUI.updateConfirmView(response.client_to_full_name, req.transfer_to.toUpperCase(), req.amount, req.currency);
            initConfirm(req);
            return;
        }

        if (response.paymentagent_transfer === 1) {
            PaymentAgentTransferUI.hideFirstForm();
            PaymentAgentTransferUI.showDone();
            PaymentAgentTransferUI.updateDoneView(Client.get('loginid'), req.transfer_to.toUpperCase(), req.amount, req.currency);
        }
    };

    var initConfirm = function initConfirm(req) {
        var confirm_form_id = '#frm_confirm_transfer';

        FormManager.init(confirm_form_id, [{ request_field: 'transfer_to', value: req.transfer_to }, { request_field: 'amount', value: req.amount }].concat(common_request_fields));

        FormManager.handleSubmit({
            form_selector: confirm_form_id,
            fnc_response_handler: responseHandler
        });

        $('#back_transfer').off('click').click(function () {
            PaymentAgentTransferUI.showForm();
            PaymentAgentTransferUI.showNotes();
            PaymentAgentTransferUI.hideConfirmation();
            PaymentAgentTransferUI.hideDone();
            $form_error.setVisibility(0);
        });
    };

    return {
        onLoad: onLoad
    };
}();

module.exports = PaymentAgentTransfer;

/***/ }),
/* 294 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var localize = __webpack_require__(2).localize;

var PaymentAgentTransferUI = function () {
    var $paymentagent_transfer = void 0,
        $confirm_transfer = void 0,
        $done_transfer = void 0,
        $notes_transfer = void 0;

    var initValues = function initValues() {
        $paymentagent_transfer = $('#frm_paymentagent_transfer');
        $confirm_transfer = $('#frm_confirm_transfer');
        $done_transfer = $('#pa_transfer_done');
        $notes_transfer = $('#paymentagent_transfer_notes');
    };

    var hideForm = function hideForm() {
        $paymentagent_transfer.setVisibility(0);
    };

    var showForm = function showForm() {
        $paymentagent_transfer.setVisibility(1);
    };

    var hideConfirmation = function hideConfirmation() {
        $confirm_transfer.setVisibility(0);
    };

    var showConfirmation = function showConfirmation() {
        $confirm_transfer.find('#msg_form').setVisibility(0).end().setVisibility(1);
    };

    var hideDone = function hideDone() {
        $done_transfer.setVisibility(0);
    };

    var showDone = function showDone() {
        $done_transfer.setVisibility(1);
    };

    var hideNotes = function hideNotes() {
        $notes_transfer.setVisibility(0);
    };

    var showNotes = function showNotes() {
        $notes_transfer.setVisibility(1);
    };

    var showTransferError = function showTransferError(err) {
        $confirm_transfer.find('#msg_form').text(localize(err)).setVisibility(1);
    };

    var updateFormView = function updateFormView(currency) {
        $paymentagent_transfer.find('label[for="amount"]').text(localize('Amount') + ' ' + currency);
    };

    var updateConfirmView = function updateConfirmView(username, loginid, amount, currency) {
        $confirm_transfer.find('#user_name').empty().text(username).end().find('#loginid').empty().text(loginid).end().find('#confirm_amount').empty().text(currency + ' ' + amount);
    };

    var updateDoneView = function updateDoneView(from_id, to_id, amount, currency) {
        var template_string = 'Your request to transfer [_1] [_2] from [_3] to [_4] has been successfully processed.';
        var confirm_msg = localize(template_string, [amount, currency, from_id, to_id]);
        $done_transfer.find(' > #confirm_msg').text(confirm_msg).setVisibility(1);
    };

    var hideFirstForm = function hideFirstForm() {
        hideForm();
        hideConfirmation();
        hideNotes();
    };

    return {
        initValues: initValues,
        hideForm: hideForm,
        showForm: showForm,
        hideConfirmation: hideConfirmation,
        showConfirmation: showConfirmation,
        hideDone: hideDone,
        showDone: showDone,
        hideNotes: hideNotes,
        showNotes: showNotes,
        showTransferError: showTransferError,
        updateFormView: updateFormView,
        updateConfirmView: updateConfirmView,
        updateDoneView: updateDoneView,
        hideFirstForm: hideFirstForm
    };
}();

module.exports = PaymentAgentTransferUI;

/***/ }),
/* 295 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var formatMoney = __webpack_require__(7).formatMoney;

var Portfolio = function () {
    var getBalance = function getBalance(balance, currency) {
        var float_balance = parseFloat(balance);
        return currency ? formatMoney(currency, float_balance) : float_balance;
    };

    var getPortfolioData = function getPortfolioData(c) {
        return {
            transaction_id: c.transaction_id,
            contract_id: c.contract_id,
            payout: parseFloat(c.payout),
            expiry_time: c.expiry_time,
            longcode: c.longcode,
            shortcode: c.shortcode,
            currency: c.currency,
            buy_price: c.buy_price,
            app_id: c.app_id
        };
    };

    var getProposalOpenContract = function getProposalOpenContract(proposal) {
        return {
            contract_id: proposal.contract_id,
            bid_price: parseFloat(proposal.bid_price || 0),
            is_sold: proposal.is_sold,
            is_valid_to_sell: proposal.is_valid_to_sell,
            currency: proposal.currency
        };
    };

    var getSum = function getSum(values, value_type) {
        // value_type is: indicative or buy_price
        var sum = 0;
        var keys = Object.keys(values);
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            if (values[key] && !isNaN(values[key][value_type])) {
                sum += parseFloat(values[key][value_type]);
            }
        }

        return sum;
    };

    return {
        getBalance: getBalance,
        getPortfolioData: getPortfolioData,
        getProposalOpenContract: getProposalOpenContract,
        getIndicativeSum: function getIndicativeSum(values) {
            return getSum(values, 'indicative');
        },
        getSumPurchase: function getSumPurchase(values) {
            return getSum(values, 'buy_price');
        }
    };
}();

module.exports = {
    Portfolio: Portfolio
};

/***/ }),
/* 296 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ProfitTableUI = __webpack_require__(298);
var ViewPopup = __webpack_require__(90);
var showLocalTimeOnHover = __webpack_require__(26).showLocalTimeOnHover;
var BinarySocket = __webpack_require__(5);
var DateTo = __webpack_require__(167);
var addTooltip = __webpack_require__(57).addTooltip;
var buildOauthApps = __webpack_require__(57).buildOauthApps;
var localize = __webpack_require__(2).localize;

var ProfitTableInit = function () {
    var batch_size = void 0,
        chunk_size = void 0,
        transactions_received = void 0,
        transaction_consumed = void 0,
        no_more_data = void 0,
        pending = void 0,
        current_batch = void 0;

    var tableExist = function tableExist() {
        return document.getElementById('profit-table');
    };

    var finishedConsumed = function finishedConsumed() {
        return transaction_consumed === transactions_received;
    };

    var onUnload = function onUnload() {
        current_batch = [];
        transaction_consumed = 0;
        transactions_received = 0;
        pending = false;

        ProfitTableUI.errorMessage(null);

        if (tableExist()) {
            ProfitTableUI.cleanTableContent();
        }
    };

    var getNextBatchTransactions = function getNextBatchTransactions() {
        getProfitTable({ offset: transactions_received, limit: batch_size });
        pending = true;
    };

    var getNextChunk = function getNextChunk() {
        var chunk = current_batch.splice(0, chunk_size);
        transaction_consumed += chunk.length;
        return chunk;
    };

    var profitTableHandler = function profitTableHandler(response) {
        if (response.error) {
            ProfitTableUI.errorMessage(response.error.message);
            return;
        }

        pending = false;
        var profit_table = response.profit_table;
        current_batch = profit_table.transactions;
        transactions_received += current_batch.length;

        if (current_batch.length < batch_size) {
            no_more_data = true;
        }

        if (!tableExist()) {
            ProfitTableUI.createEmptyTable().appendTo('#profit-table-container');
            ProfitTableUI.updateProfitTable(getNextChunk());

            // Show a message when the table is empty
            if (transactions_received === 0 && current_batch.length === 0) {
                $('#profit-table').find('tbody').append($('<tr/>', { class: 'flex-tr' }).append($('<td/>', { colspan: 8 }).append($('<p/>', { class: 'notice-msg center-text', text: localize('Your account has no trading activity.') }))));
            } else {
                $('#util_row').setVisibility(1);
            }
        }
    };

    var onScrollLoad = function onScrollLoad() {
        $(document).scroll(function () {
            var hidableHeight = function hidableHeight(percentage) {
                var total_hidable = $(document).height() - $(window).height();
                return Math.floor(total_hidable * percentage / 100);
            };

            var p_from_top = $(document).scrollTop();

            if (!tableExist() || p_from_top < hidableHeight(50)) {
                return;
            }

            if (finishedConsumed() && !no_more_data && !pending) {
                getNextBatchTransactions();
                return;
            }

            if (!finishedConsumed()) {
                ProfitTableUI.updateProfitTable(getNextChunk());
            }
        });
    };

    var getProfitTable = function getProfitTable(opts) {
        var req = { profit_table: 1, description: 1 };

        if (opts) $.extend(true, req, opts);

        var obj_date_to_from = DateTo.getDateToFrom();
        if (obj_date_to_from) $.extend(true, req, obj_date_to_from);

        BinarySocket.send(req).then(function (response) {
            profitTableHandler(response);
            showLocalTimeOnHover('td.buy-date,td.sell-date');
            $('.barspinner').setVisibility(0);
        });
    };

    var onLoad = function onLoad() {
        batch_size = 50;
        chunk_size = batch_size / 2;
        transactions_received = 0;
        transaction_consumed = 0;
        no_more_data = false;
        pending = false;
        current_batch = [];

        DateTo.attachDateToPicker(function () {
            ProfitTableUI.cleanTableContent();
            $('.barspinner').setVisibility(1);
            transactions_received = 0;
            getNextBatchTransactions();
        });
        BinarySocket.send({ oauth_apps: 1 }).then(function (response) {
            addTooltip(ProfitTableUI.setOauthApps(buildOauthApps(response)));
        });
        getNextBatchTransactions();
        onScrollLoad();
        ViewPopup.viewButtonOnClick('#profit-table-container');
    };

    return {
        onLoad: onLoad,
        onUnload: onUnload
    };
}();

module.exports = ProfitTableInit;

/***/ }),
/* 297 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var moment = __webpack_require__(9);
var Client = __webpack_require__(3);
var formatMoney = __webpack_require__(7).formatMoney;

var ProfitTable = function () {
    var getProfitTabletData = function getProfitTabletData(transaction) {
        var currency = Client.get('currency');
        var is_jp_client = Client.isJPClient();
        var buy_moment = moment.utc(transaction.purchase_time * 1000);
        var sell_moment = moment.utc(transaction.sell_time * 1000);
        var buy_price = parseFloat(transaction.buy_price);
        var sell_price = parseFloat(transaction.sell_price);

        return {
            buyDate: buy_moment.format('YYYY-MM-DD') + '\n' + buy_moment.format('HH:mm:ss') + ' GMT',
            ref: transaction.transaction_id,
            payout: +transaction.payout ? formatMoney(currency, parseFloat(transaction.payout), !is_jp_client) : '-',
            buyPrice: formatMoney(currency, buy_price, !is_jp_client),
            sellDate: sell_moment.format('YYYY-MM-DD') + '\n' + sell_moment.format('HH:mm:ss') + ' GMT',
            sellPrice: formatMoney(currency, sell_price, !is_jp_client),
            pl: formatMoney(currency, Number(sell_price - buy_price), !is_jp_client),
            desc: transaction.longcode,
            id: transaction.contract_id,
            app_id: transaction.app_id,
            shortcode: transaction.shortcode
        };
    };

    return {
        getProfitTabletData: getProfitTabletData
    };
}();

module.exports = ProfitTable;

/***/ }),
/* 298 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ProfitTable = __webpack_require__(297);
var Client = __webpack_require__(3);
var toJapanTimeIfNeeded = __webpack_require__(26).toJapanTimeIfNeeded;
var Table = __webpack_require__(76);
var formatMoney = __webpack_require__(7).formatMoney;
var showTooltip = __webpack_require__(57).showTooltip;
var localize = __webpack_require__(2).localize;

var ProfitTableUI = function () {
    var oauth_apps = {};
    var total_profit = 0;

    var currency = void 0;

    var profit_table_id = 'profit-table';
    var cols = ['buy-date', 'ref', 'payout', 'contract', 'buy-price', 'sell-date', 'sell-price', 'pl', 'details'];

    var createEmptyTable = function createEmptyTable() {
        var header = [localize('Date'), localize('Ref.'), localize('Potential Payout'), localize('Contract'), localize('Purchase Price'), localize('Sale Date'), localize('Sale Price'), localize('Profit/Loss'), localize('Details')];

        currency = Client.get('currency');

        header[7] += Client.isJPClient() || !currency ? '' : ' (' + currency + ')';

        var footer = [localize('Total Profit/Loss'), '', '', '', '', '', '', '', ''];

        var data = [];
        var metadata = {
            cols: cols,
            id: profit_table_id
        };
        var $table_container = Table.createFlexTable(data, metadata, header, footer);

        $table_container.children('table').children('tfoot').children('tr').attr('id', 'pl-day-total');

        return $table_container;
    };

    var updateFooter = function updateFooter(transactions) {
        total_profit += transactions.reduce(function (previous, current) {
            var buy_price = Number(parseFloat(current.buy_price));
            var sell_price = Number(parseFloat(current.sell_price));
            var pl = sell_price - buy_price;
            return previous + pl;
        }, 0);

        var sub_total_type = total_profit >= 0 ? 'profit' : 'loss';

        $('#pl-day-total').find(' > .pl').html(formatMoney(currency, Number(total_profit), !Client.isJPClient())).removeClass('profit loss').addClass(sub_total_type);
    };

    var createProfitTableRow = function createProfitTableRow(transaction) {
        var profit_table_data = ProfitTable.getProfitTabletData(transaction);
        var pl_type = Number(transaction.sell_price - transaction.buy_price) >= 0 ? 'profit' : 'loss';
        var is_jp_client = Client.isJPClient();

        var data = [is_jp_client ? toJapanTimeIfNeeded(parseInt(transaction.purchase_time)) : profit_table_data.buyDate, '<span ' + showTooltip(profit_table_data.app_id, oauth_apps[profit_table_data.app_id]) + '>' + profit_table_data.ref + '</span>', /binaryico/i.test(profit_table_data.shortcode) ? '-' : profit_table_data.payout, // TODO: remove ico exception when all ico contracts are removed
        '', profit_table_data.buyPrice, is_jp_client ? toJapanTimeIfNeeded(parseInt(transaction.sell_time)) : profit_table_data.sellDate, profit_table_data.sellPrice, profit_table_data.pl, ''];
        var $row = Table.createFlexTableRow(data, cols, 'data');

        $row.children('.pl').addClass(pl_type);
        $row.children('.contract').html(profit_table_data.desc + '<br>');
        $row.children('.buy-date, .sell-date').each(function () {
            $(this).wrapInner('<div class="new-width"></div>');
        });

        // TODO: remove ico exception when all ico contracts are removed
        if (!/binaryico/i.test(profit_table_data.shortcode)) {
            // create view button and append
            var $view_button = $('<button/>', { class: 'button open_contract_details', text: localize('View'), contract_id: profit_table_data.id });
            $row.children('.contract,.details').append($view_button);
        }

        return $row[0];
    };

    var updateProfitTable = function updateProfitTable(transactions) {
        Table.appendTableBody(profit_table_id, transactions, createProfitTableRow);
        updateFooter(transactions);
    };

    var clearTableContent = function clearTableContent() {
        Table.clearTableBody(profit_table_id);
        $('#' + profit_table_id).find('> tfoot').hide();
        total_profit = 0;
    };

    var errorMessage = function errorMessage(msg) {
        var $err = $('#profit-table-container').find('#error-msg');
        if (msg) {
            $err.setVisibility(1).text(msg);
        } else {
            $err.setVisibility(0).text('');
        }
    };

    return {
        createEmptyTable: createEmptyTable,
        updateProfitTable: updateProfitTable,
        errorMessage: errorMessage,
        cleanTableContent: clearTableContent,
        setOauthApps: function setOauthApps(values) {
            return oauth_apps = values;
        }
    };
}();

module.exports = ProfitTableUI;

/***/ }),
/* 299 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Client = __webpack_require__(3);
var BinarySocket = __webpack_require__(5);
var localize = __webpack_require__(2).localize;
var State = __webpack_require__(6).State;

var Settings = function () {
    var onLoad = function onLoad() {
        BinarySocket.wait('get_account_status').then(function () {
            var $class_real = $('.real');

            if (Client.get('is_virtual')) {
                $class_real.setVisibility(0);
            } else {
                $class_real.not(Client.isJPClient() ? '.ja-hide' : '').setVisibility(1);
            }

            var status = State.getResponse('get_account_status.status') || [];
            if (!/social_signup/.test(status)) {
                $('#change_password').setVisibility(1);
            }

            // Professional Client menu should only be shown to maltainvest accounts.
            if (Client.get('landing_company_shortcode') === 'maltainvest') {
                var text = 'You are categorised as a retail client. Apply to be treated as a professional trader.';
                if (status.indexOf('professional') !== -1) {
                    text = 'You are categorised as a professional client.';
                } else if (/professional_requested/.test(status)) {
                    text = 'Your application to be treated as a professional client is being processed.';
                }
                $('#professional_client').setVisibility(1).find('p').text(localize(text));
            }

            if (!State.getResponse('get_account_status.prompt_client_to_authenticate')) {
                $('#authenticate').setVisibility(0);
            }

            $('#settings_container').setVisibility(1);
        });
    };

    return {
        onLoad: onLoad
    };
}();

module.exports = Settings;

/***/ }),
/* 300 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BinaryPjax = __webpack_require__(12);
var isJPClient = __webpack_require__(3).isJPClient;
var showLocalTimeOnHover = __webpack_require__(26).showLocalTimeOnHover;
var BinarySocket = __webpack_require__(5);
var Dialog = __webpack_require__(75);
var FlexTableUI = __webpack_require__(120);
var FormManager = __webpack_require__(18);
var localize = __webpack_require__(2).localize;
var toTitleCase = __webpack_require__(17).toTitleCase;

var APIToken = function () {
    var error_class = 'errorfield';
    var form_id = '#token_form';
    var max_tokens = 30;

    var $table_container = void 0,
        $form = void 0;

    var onLoad = function onLoad() {
        if (isJPClient()) {
            BinaryPjax.loadPreviousUrl();
            return;
        }

        $table_container = $('#tokens_list');
        $form = $(form_id);

        BinarySocket.send({ api_token: 1 }).then(populateTokensList);

        var regex_msg = localize('Only [_1] are allowed.', [['letters', 'numbers', 'space', '_'].join(', ')]);
        FormManager.init(form_id, [{ selector: '#txt_name', request_field: 'new_token', validations: ['req', ['regular', { regex: /^[\w\s]+$/, message: regex_msg }], ['length', { min: 2, max: 32 }]] }, { selector: '[id*="chk_scopes_"]', request_field: 'new_token_scopes', validations: [['req', { message: localize('Please select at least one scope') }]], value: getScopes }, { request_field: 'api_token', value: 1 }]);
        FormManager.handleSubmit({
            form_selector: form_id,
            fnc_response_handler: newTokenResponse,
            enable_button: true
        });
    };

    var newTokenResponse = function newTokenResponse(response) {
        if (response.error) {
            showFormMessage(response.error.message, false);
            return;
        }
        showFormMessage('New token created.', true);
        $('#txt_name').val('');

        populateTokensList(response);
    };

    var getScopes = function getScopes() {
        return $form.find('[id*="chk_scopes_"]:checked').map(function () {
            return $(this).val();
        }).get();
    };

    // -----------------------
    // ----- Tokens List -----
    // -----------------------
    var populateTokensList = function populateTokensList(response) {
        if ('error' in response) {
            showErrorMessage(response.error.message);
            return;
        }

        clearMessages();

        var tokens = response.api_token.tokens;
        if (tokens.length === 0) {
            $table_container.setVisibility(0);
            return;
        } else if (tokens.length >= max_tokens) {
            $form.setVisibility(0);
            showErrorMessage(localize('The maximum number of tokens ([_1]) has been reached.', [max_tokens]));
        } else {
            $form.setVisibility(1);
        }

        $table_container.setVisibility(1).empty();

        var headers = ['Name', 'Token', 'Scopes', 'Last Used', 'Action'];
        FlexTableUI.init({
            id: 'tokens_table',
            container: $table_container,
            header: headers.map(localize),
            cols: headers.map(function (title) {
                return title.toLowerCase().replace(/\s/g, '-');
            }),
            data: tokens,
            formatter: formatToken,
            style: function style($row, token) {
                if (token.display_name === response.echo_req.new_token) {
                    $row.addClass('new');
                }
                $row.attr('id', token.token);
                createDeleteButton($row, token);
            }
        });
        showLocalTimeOnHover('td.last-used');
    };

    var createDeleteButton = function createDeleteButton($row, token) {
        var message = localize('Are you sure that you want to permanently delete the token');
        var $button = $('<button/>', { class: 'button btn_delete', text: localize('Delete') });
        $button.click(function (e) {
            e.preventDefault();
            e.stopPropagation();
            Dialog.confirm({
                id: 'delete_token_dialog',
                message: message + ': "' + token.display_name + '"?',
                onConfirm: function onConfirm() {
                    deleteToken(token.token);
                }
            });
        });
        $row.children('.action').html($button);
    };

    var formatToken = function formatToken(token) {
        var last_used = token.last_used ? token.last_used + ' GMT' : localize('Never Used');
        var scopes = token.scopes.map(function (scope) {
            return localize(toTitleCase(scope));
        }).join(', ');
        return [token.display_name, token.token, scopes, last_used, ''];
    };

    var deleteToken = function deleteToken(token) {
        BinarySocket.send({
            api_token: 1,
            delete_token: token
        }).then(function (response) {
            $('#' + response.echo_req.delete_token).removeClass('new').addClass('deleting').fadeOut(700, function () {
                $(this).remove();
                populateTokensList(response);
            });
        });
    };

    // -----------------------------
    // ----- Message Functions -----
    // -----------------------------
    var showErrorMessage = function showErrorMessage(msg) {
        $('#token_message').setVisibility(1).find('p').attr('class', error_class).html(localize(msg));
    };

    var showFormMessage = function showFormMessage(msg, is_success) {
        $('#msg_form').attr('class', is_success ? 'success-msg' : error_class).html(is_success ? '<ul class="checked"><li>' + localize(msg) + '</li></ul>' : localize(msg)).css('display', 'block').delay(3000).fadeOut(1000);
    };

    var clearMessages = function clearMessages() {
        $('#token_message').setVisibility(0);
    };

    return {
        onLoad: onLoad
    };
}();

module.exports = APIToken;

/***/ }),
/* 301 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var moment = __webpack_require__(9);
var BinaryPjax = __webpack_require__(12);
var Client = __webpack_require__(3);
var showLocalTimeOnHover = __webpack_require__(26).showLocalTimeOnHover;
var BinarySocket = __webpack_require__(5);
var Dialog = __webpack_require__(75);
var FlexTableUI = __webpack_require__(120);
var elementTextContent = __webpack_require__(4).elementTextContent;
var localize = __webpack_require__(2).localize;
var State = __webpack_require__(6).State;
var toTitleCase = __webpack_require__(17).toTitleCase;

var AuthorisedApps = function () {
    var can_revoke = false;

    var messages = {
        no_apps: 'You have not granted access to any applications.',
        revoke_confirm: 'Are you sure that you want to permanently revoke access to the application',
        revoke_access: 'Revoke access'
    };

    var element_ids = {
        container: 'applications-container',
        table: 'applications-table',
        loading: 'applications_loading',
        error: 'applications_error'
    };

    var elements = {};

    var onLoad = function onLoad() {
        if (Client.isJPClient()) {
            BinaryPjax.loadPreviousUrl();
            return;
        }
        Object.keys(element_ids).forEach(function (id) {
            elements[id] = document.getElementById(element_ids[id]);
        });
        updateApps();
    };

    var updateApps = function updateApps() {
        BinarySocket.send({ oauth_apps: 1 }).then(function (response) {
            if (response.error) {
                if (/InvalidToken/.test(response.error.code)) {
                    // if application revoked is current application, log client out
                    Client.sendLogoutRequest(true);
                } else {
                    displayError(response.error.message);
                }
            } else {
                var apps = response.oauth_apps.map(function (app) {
                    return {
                        name: app.name,
                        scopes: app.scopes,
                        last_used: app.last_used ? moment.utc(app.last_used) : null,
                        id: app.app_id
                    };
                });
                if (elements.loading) elements.loading.remove();
                createTable(apps);
                if (!apps.length) {
                    FlexTableUI.displayError(localize(messages.no_apps), 7);
                }
            }
        });
    };

    var formatApp = function formatApp(app) {
        var last_used = app.last_used ? app.last_used.format('YYYY-MM-DD HH:mm:ss') : localize('Never');
        var scopes = app.scopes.map(function (scope) {
            return localize(toTitleCase(scope));
        }).join(', ');
        var data = [app.name, scopes, last_used];
        if (can_revoke) {
            data.push(''); // for the "Revoke App" button
        }
        return data;
    };

    var createRevokeButton = function createRevokeButton(container, app) {
        var $button = $('<button/>', { class: 'button', text: localize(messages.revoke_access) });
        $button.on('click', function () {
            Dialog.confirm({
                id: 'apps_revoke_dialog',
                message: localize(messages.revoke_confirm) + ': \'' + app.name + '\'?',
                onConfirm: function onConfirm() {
                    BinarySocket.send({ revoke_oauth_app: app.id }).then(function (response) {
                        if (response.error) {
                            displayError(response.error.message);
                        } else {
                            updateApps();
                        }
                    });
                }
            });
        });
        return $button;
    };

    var createTable = function createTable(data) {
        if (elements.table) {
            return FlexTableUI.replace(data);
        }
        var headers = ['Name', 'Permissions', 'Last Used'];
        can_revoke = /admin/.test((State.getResponse('authorize') || {}).scopes);
        if (can_revoke) {
            headers.push('Action');
        }
        FlexTableUI.init({
            data: data,
            container: '#' + element_ids.container,
            header: headers.map(localize),
            id: element_ids.table,
            cols: headers.map(function (title) {
                return title.toLowerCase().replace(/\s/g, '-');
            }),
            style: function style($row, app) {
                if (can_revoke) {
                    $row.children('.action').first().append(createRevokeButton($row, app));
                }
            },
            formatter: formatApp
        });
        elements.table = document.getElementById(element_ids.table);
        return showLocalTimeOnHover('td.last_used');
    };

    var displayError = function displayError(message) {
        elementTextContent(elements.error, message);
    };

    var onUnload = function onUnload() {
        elementTextContent(elements.error, '');
        FlexTableUI.clear();
    };

    return {
        onLoad: onLoad,
        onUnload: onUnload
    };
}();

module.exports = AuthorisedApps;

/***/ }),
/* 302 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BinaryPjax = __webpack_require__(12);
var Client = __webpack_require__(3);
var Header = __webpack_require__(27);
var BinarySocket = __webpack_require__(5);
var Validation = __webpack_require__(56);
var getElementById = __webpack_require__(4).getElementById;
var isVisible = __webpack_require__(4).isVisible;
var localize = __webpack_require__(2).localize;
var State = __webpack_require__(6).State;
var isEmptyObject = __webpack_require__(1).isEmptyObject;
var showLoadingImage = __webpack_require__(1).showLoadingImage;

var FinancialAssessment = function () {
    var financial_assessment = {};
    var arr_validation = [];

    var form_selector = '#frm_assessment';

    var onLoad = function onLoad() {
        if (Client.isJPClient()) {
            BinaryPjax.loadPreviousUrl();
        }

        $(form_selector).on('submit', function (event) {
            event.preventDefault();
            submitForm();
        });

        getFinancialAssessment();
    };

    var getFinancialAssessment = function getFinancialAssessment() {
        BinarySocket.send({ get_financial_assessment: 1 }).then(function (response) {
            handleForm(response.get_financial_assessment);
        });
    };

    var displayHighRiskClassification = function displayHighRiskClassification() {
        $('#high_risk_classification').setVisibility(Client.getRiskAssessment());
    };

    var handleForm = function handleForm() {
        var response = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : State.getResponse('get_financial_assessment');

        hideLoadingImg(!isVisible(getElementById('msg_main')));

        financial_assessment = $.extend({}, response);

        if (isEmptyObject(financial_assessment)) {
            BinarySocket.wait('get_account_status').then(function () {
                displayHighRiskClassification();
            });
        }

        // display Trading Experience only for financial & MT5 financial accounts
        var is_mt5_financial = /real_vanuatu_(standard|advanced|mamm_advanced)/.test(localStorage.getItem('financial_assessment_redirect'));
        $('#trading_experience_form').setVisibility(is_mt5_financial || Client.isAccountOfType('financial'));

        Object.keys(financial_assessment).forEach(function (key) {
            var val = financial_assessment[key];
            $('#' + key).val(val);
        });

        arr_validation = [];
        $(form_selector).find('select').map(function () {
            var id = $(this).attr('id');
            arr_validation.push({ selector: '#' + id, validations: ['req'] });
            if (financial_assessment[id] === undefined) {
                // handle fields not previously set by client
                financial_assessment[id] = '';
            }
        });
        Validation.init(form_selector, arr_validation);
    };

    var submitForm = function submitForm() {
        var $btn_submit = $(form_selector + ' #btn_submit');
        $btn_submit.attr('disabled', 'disabled');

        if (Validation.validate(form_selector)) {
            var has_changed = false;
            Object.keys(financial_assessment).forEach(function (key) {
                var $key = $('#' + key);
                if ($key.length && $key.val() !== financial_assessment[key]) {
                    has_changed = true;
                }
            });
            if (Object.keys(financial_assessment).length === 0) has_changed = true;
            if (!has_changed) {
                showFormMessage('You did not change anything.', false);
                setTimeout(function () {
                    $btn_submit.removeAttr('disabled');
                }, 1000);
                return;
            }

            var data = { set_financial_assessment: 1 };
            showLoadingImage(getElementById('msg_form'));
            $(form_selector).find('select').each(function () {
                financial_assessment[$(this).attr('id')] = data[$(this).attr('id')] = $(this).val() || null;
            });
            BinarySocket.send(data).then(function (response) {
                $btn_submit.removeAttr('disabled');
                if (response.error) {
                    showFormMessage('Sorry, an error occurred while processing your request.', false);
                } else {
                    showFormMessage('Your changes have been updated successfully.', true);
                    // need to remove financial_assessment_not_complete from status if any
                    BinarySocket.send({ get_account_status: 1 }).then(function () {
                        Header.displayAccountStatus();
                        displayHighRiskClassification();
                    });
                    getFinancialAssessment();
                }
            });
        } else {
            setTimeout(function () {
                $btn_submit.removeAttr('disabled');
            }, 1000);
        }
    };

    var hideLoadingImg = function hideLoadingImg(show_form) {
        $('#assessment_loading').remove();
        if (show_form) {
            $(form_selector).setVisibility(1);
        }
    };

    var showFormMessage = function showFormMessage(msg, is_success) {
        var redirect_url = localStorage.getItem('financial_assessment_redirect');
        if (is_success && /metatrader/i.test(redirect_url)) {
            localStorage.removeItem('financial_assessment_redirect');
            $.scrollTo($('h1#heading'), 500, { offset: -10 });
            $(form_selector).setVisibility(0);
            $('#msg_main').setVisibility(1);
            BinarySocket.send({ get_account_status: 1 }).then(function (response_status) {
                if (+response_status.get_account_status.prompt_client_to_authenticate && Client.isAccountOfType('financial')) {
                    $('#msg_authenticate').setVisibility(1);
                }
            });
        } else {
            $('#msg_form').attr('class', is_success ? 'success-msg' : 'errorfield').html(is_success ? $('<ul/>', { class: 'checked', style: 'display: inline-block;' }).append($('<li/>', { text: localize(msg) })) : localize(msg)).css('display', 'block').delay(5000).fadeOut(1000);
        }
    };

    var onUnload = function onUnload() {
        localStorage.removeItem('financial_assessment_redirect');
    };

    return {
        onLoad: onLoad,
        onUnload: onUnload
    };
}();

module.exports = FinancialAssessment;

/***/ }),
/* 303 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var IPHistoryData = function () {
    var parseUA = function parseUA(user_agent) {
        // Table of UA-values (and precedences) from:
        //  https://developer.mozilla.org/en-US/docs/Browser_detection_using_the_user_agent
        // Regexes stolen from:
        //  https://github.com/biggora/express-useragent/blob/master/lib/express-useragent.js
        var lookup = [{ name: 'Edge', regex: /Edge\/([\d\w.-]+)/i }, { name: 'SeaMonkey', regex: /seamonkey\/([\d\w.-]+)/i }, { name: 'Opera', regex: /(?:opera|opr)\/([\d\w.-]+)/i }, { name: 'Chromium', regex: /(?:chromium|crios)\/([\d\w.-]+)/i }, { name: 'Chrome', regex: /chrome\/([\d\w.-]+)/i }, { name: 'Safari', regex: /version\/([\d\w.-]+)/i }, { name: 'IE', regex: /msie\s([\d.]+[\d])/i }, { name: 'IE', regex: /trident\/\d+\.\d+;.*[rv:]+(\d+\.\d)/i }, { name: 'Firefox', regex: /firefox\/([\d\w.-]+)/i }];
        for (var i = 0; i < lookup.length; i++) {
            var info = lookup[i];
            var match = user_agent.match(info.regex);
            if (match !== null) {
                return {
                    name: info.name,
                    version: match[1]
                };
            }
        }
        return null;
    };

    var parse = function parse(activity) {
        return {
            time: activity.time,
            action: activity.action,
            success: activity.status === 1,
            browser: parseUA(activity.environment.match('User_AGENT=(.+) LANG')[1]),
            ip_addr: activity.environment.split(' ')[2].split('=')[1]
        };
    };

    return {
        parse: parse,
        parseUserAgent: parseUA
    };
}();

module.exports = IPHistoryData;

/***/ }),
/* 304 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var IPHistoryData = __webpack_require__(303);
var IPHistoryUI = __webpack_require__(306);
var BinarySocket = __webpack_require__(5);

var IPHistoryInit = function () {
    var responseHandler = function responseHandler(response) {
        if (response.error && response.error.message) {
            return IPHistoryUI.displayError(response.error.message);
        }
        var parsed = response.login_history.map(IPHistoryData.parse);
        return IPHistoryUI.update(parsed);
    };

    var init = function init() {
        IPHistoryUI.init();
        var req = {
            login_history: '1',
            limit: 50
        };
        BinarySocket.send(req).then(function (response) {
            responseHandler(response);
        });
    };

    var clean = function clean() {
        IPHistoryUI.clean();
    };

    return {
        init: init,
        clean: clean
    };
}();

module.exports = IPHistoryInit;

/***/ }),
/* 305 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var IPHistoryInit = __webpack_require__(304);
var BinaryPjax = __webpack_require__(12);
var isJPClient = __webpack_require__(3).isJPClient;

var IPHistory = function () {
    var onLoad = function onLoad() {
        if (isJPClient()) {
            BinaryPjax.loadPreviousUrl();
            return;
        }
        IPHistoryInit.init();
    };

    var onUnload = function onUnload() {
        IPHistoryInit.clean();
    };

    return {
        onLoad: onLoad,
        onUnload: onUnload
    };
}();

module.exports = IPHistory;

/***/ }),
/* 306 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var moment = __webpack_require__(9);
var showLocalTimeOnHover = __webpack_require__(26).showLocalTimeOnHover;
var FlexTableUI = __webpack_require__(120);
var localize = __webpack_require__(2).localize;

var IPHistoryUI = function () {
    var container_selector = '#login-history-container';
    var no_messages_error = 'Your account has no Login/Logout activity.';

    var init = function init() {
        var $title = $('#login_history-title').children().first();
        $title.text(localize($title.text()));
    };

    var formatRow = function formatRow(data) {
        var timestamp = moment.unix(data.time).utc().format('YYYY-MM-DD HH:mm:ss').replace(' ', '\n') + ' GMT';
        var status = localize(data.success ? 'Successful' : 'Failed');
        var action = localize(data.action);
        var browser = data.browser;
        var browser_string = browser ? browser.name + ' v' + browser.version : 'Unknown';
        var patt = /^(opera|chrome|safari|firefox|IE|Edge|SeaMonkey|Chromium) v[0-9.]+$/i;
        if (!patt.test(browser_string) && browser_string !== 'Unknown') {
            browser_string = 'Error';
        }
        return [timestamp, action, browser_string, data.ip_addr, status];
    };

    var update = function update(history) {
        var headers = ['Date and Time', 'Action', 'Browser', 'IP Address', 'Status'];
        var columns = ['timestamp', 'action', 'browser', 'ip', 'status'];
        FlexTableUI.init({
            id: 'login-history-table',
            container: container_selector,
            header: headers.map(function (s) {
                return localize(s);
            }),
            cols: columns,
            data: history,
            formatter: formatRow,
            style: function style($row) {
                $row.children('.timestamp').addClass('pre');
            }
        });
        if (!history.length) {
            return FlexTableUI.displayError(localize(no_messages_error), 6);
        }
        return showLocalTimeOnHover('td.timestamp');
    };

    var clean = function clean() {
        $(container_selector).find('.error-msg').text('');
        FlexTableUI.clear();
    };

    var displayError = function displayError(error) {
        $('#err').text(error);
    };

    return {
        init: init,
        clean: clean,
        update: update,
        displayError: displayError
    };
}();

module.exports = IPHistoryUI;

/***/ }),
/* 307 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var LimitsUI = __webpack_require__(309);
var Client = __webpack_require__(3);
var formatMoney = __webpack_require__(7).formatMoney;
var elementInnerHtml = __webpack_require__(4).elementInnerHtml;
var elementTextContent = __webpack_require__(4).elementTextContent;
var getElementById = __webpack_require__(4).getElementById;
var localize = __webpack_require__(2).localize;
var getPropertyValue = __webpack_require__(1).getPropertyValue;

var LimitsInit = function () {
    var limitsHandler = function limitsHandler(response, response_get_account_status) {
        var limits = response.get_limits;
        LimitsUI.fillLimitsTable(limits);

        if (Client.isJPClient()) {
            return;
        }

        var el_withdraw_limit = getElementById('withdrawal-limit');
        var el_withdrawn = getElementById('already-withdraw');
        var el_withdraw_limit_agg = getElementById('withdrawal-limit-aggregate');

        if (/authenticated/.test(getPropertyValue(response_get_account_status, ['get_account_status', 'status']))) {
            elementTextContent(el_withdraw_limit, localize('Your account is fully authenticated and your withdrawal limits have been lifted.'));
        } else {
            var txt_withdraw_lim = 'Your withdrawal limit is [_1] [_2] (or equivalent in other currency).';
            var txt_withdraw_amt = 'You have already withdrawn the equivalent of [_1] [_2].';
            var txt_current_max_withdrawal = 'Therefore your current immediate maximum withdrawal (subject to your account having sufficient funds) is [_1] [_2] (or equivalent in other currency).';
            var currency = Client.get('currency') || Client.currentLandingCompany().legal_default_currency;
            var days_limit = formatMoney(currency, limits.num_of_days_limit, 1);
            var remainder = formatMoney(currency, limits.remainder, 1);

            if (/^(iom)$/i.test(Client.get('landing_company_shortcode'))) {
                // MX
                txt_withdraw_lim = 'Your [_1] day withdrawal limit is currently [_2] [_3] (or equivalent in other currency).';
                txt_withdraw_amt = 'You have already withdrawn the equivalent of [_1] [_2] in aggregate over the last [_3] days.';
                elementInnerHtml(el_withdraw_limit, localize(txt_withdraw_lim, [limits.num_of_days, currency, days_limit]));
                elementTextContent(el_withdrawn, localize(txt_withdraw_amt, [currency, limits.withdrawal_for_x_days_monetary, limits.num_of_days]));
            } else {
                if (/^(costarica|japan)$/i.test(Client.get('landing_company_shortcode'))) {
                    // CR , JP
                    txt_withdraw_lim = 'Your withdrawal limit is [_1] [_2].';
                    txt_withdraw_amt = 'You have already withdrawn [_1] [_2].';
                    txt_current_max_withdrawal = 'Therefore your current immediate maximum withdrawal (subject to your account having sufficient funds) is [_1] [_2].';
                }
                elementInnerHtml(el_withdraw_limit, localize(txt_withdraw_lim, [currency, days_limit]));
                elementTextContent(el_withdrawn, localize(txt_withdraw_amt, [currency, limits.withdrawal_since_inception_monetary]));
            }
            elementInnerHtml(el_withdraw_limit_agg, localize(txt_current_max_withdrawal, [currency, remainder]));
        }
    };

    var limitsError = function limitsError(error) {
        getElementById('withdrawal-title').setVisibility(0);
        getElementById('limits-title').setVisibility(0);
        $('#limits_error').append($('<p/>', { class: 'center-text notice-msg', text: error && error.message ? error.message : localize('Sorry, an error occurred while processing your request.') }));
    };

    var initTable = function initTable() {
        LimitsUI.clearTableContent();
    };

    return {
        limitsHandler: limitsHandler,
        limitsError: limitsError,

        clean: initTable
    };
}();

module.exports = LimitsInit;

/***/ }),
/* 308 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var LimitsInit = __webpack_require__(307);
var BinarySocket = __webpack_require__(5);

var Limits = function () {
    var onLoad = function onLoad() {
        BinarySocket.wait('get_account_status').then(function (response_get_account_status) {
            BinarySocket.send({ get_limits: 1 }).then(function (response) {
                if (response.error) {
                    LimitsInit.limitsError(response.error);
                } else {
                    LimitsInit.limitsHandler(response, response_get_account_status);
                }
            });
        });
    };

    var onUnload = function onUnload() {
        LimitsInit.clean();
    };

    return {
        onLoad: onLoad,
        onUnload: onUnload
    };
}();

module.exports = Limits;

/***/ }),
/* 309 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Client = __webpack_require__(3);
var Table = __webpack_require__(76);
var formatMoney = __webpack_require__(7).formatMoney;
var elementInnerHtml = __webpack_require__(4).elementInnerHtml;
var getElementById = __webpack_require__(4).getElementById;
var localize = __webpack_require__(2).localize;
var findParent = __webpack_require__(1).findParent;

var LimitsUI = function () {
    var $client_limits = void 0;

    // if we have value for td, set the value
    // if we don't, make the tr invisible
    var setText = function setText(el, text) {
        if (text) {
            elementInnerHtml(el, text);
        } else {
            var tr = findParent(el, 'tr');
            if (tr) {
                tr.setVisibility(0);
            }
        }
    };

    var appendRowTable = function appendRowTable(name, turnover_limit, padding, font_weight) {
        var $new_row = $('<tr/>', { class: 'flex-tr' }).append($('<td/>', { class: 'flex-tr-child', style: 'padding-left: ' + padding + '; font-weight: ' + font_weight + ';', text: localize(name) })).append($('<td/>', { html: turnover_limit }));
        $client_limits.append($new_row);
    };

    var fillLimitsTable = function fillLimitsTable(limits) {
        var currency = Client.get('currency');

        if (currency) {
            $('.limit').append(' (' + currency + ')');
        }

        var open_position = getElementById('open-positions');
        var account_balance = getElementById('account-balance');
        var payout = getElementById('payout');

        $client_limits = $('#client-limits');

        setText(open_position, 'open_positions' in limits ? limits.open_positions : '');
        setText(account_balance, 'account_balance' in limits ? formatMoney(currency, limits.account_balance, 1) : '');
        setText(payout, 'payout' in limits ? formatMoney(currency, limits.payout, 1) : '');

        if (limits.market_specific) {
            Object.keys(limits.market_specific).forEach(function (key) {
                var object = limits.market_specific[key];
                if (object.length && object.length > 0) {
                    appendRowTable(localize(key.charAt(0).toUpperCase() + key.slice(1)), '', 'auto', 'bold');
                    Object.keys(object).forEach(function (c) {
                        if (Client.get('residence') !== 'jp' || /Major Pairs/.test(object[c].name)) {
                            appendRowTable(object[c].name, object[c].turnover_limit !== 'null' ? formatMoney(currency, object[c].turnover_limit, 1) : 0, '25px', 'normal');
                        }
                    });
                } else {
                    appendRowTable(object.name, object.turnover_limit !== 'null' ? formatMoney(currency, object.turnover_limit, 1) : 0, 'auto', 'bold');
                }
            });
        } else {
            var tr = findParent(getElementById('market_specific'), 'tr');
            if (tr) {
                tr.setVisibility(0);
            }
        }

        var login_id = Client.get('loginid');
        if (login_id) {
            $('#trading-limits').prepend(login_id + ' - ');
            $('#withdrawal-title').prepend(login_id + ' - ');
        }
        $('#limits-title').setVisibility(1);
        if (!Client.isJPClient()) {
            $('#withdrawal-limits').setVisibility(1);
        }
    };

    var clearTableContent = function clearTableContent() {
        Table.clearTableBody('client-limits');
    };

    return {
        clearTableContent: clearTableContent,
        fillLimitsTable: fillLimitsTable
    };
}();

module.exports = LimitsUI;

/***/ }),
/* 310 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var moment = __webpack_require__(9);
var BinaryPjax = __webpack_require__(12);
var Client = __webpack_require__(3);
var Header = __webpack_require__(27);
var BinarySocket = __webpack_require__(5);
var Dialog = __webpack_require__(75);
var Currency = __webpack_require__(7);
var FormManager = __webpack_require__(18);
var DatePicker = __webpack_require__(87);
var TimePicker = __webpack_require__(171);
var dateValueChanged = __webpack_require__(4).dateValueChanged;
var localize = __webpack_require__(2).localize;
var scrollToHashSection = __webpack_require__(94).scrollToHashSection;

var SelfExclusion = function () {
    var $form = void 0,
        fields = void 0,
        self_exclusion_data = void 0,
        set_30day_turnover = void 0,
        currency = void 0,
        is_gamstop_client = void 0,
        has_exclude_until = void 0;

    var form_id = '#frm_self_exclusion';
    var timeout_date_id = '#timeout_until_date';
    var timeout_time_id = '#timeout_until_time';
    var exclude_until_id = '#exclude_until';
    var max_30day_turnover_id = '#max_30day_turnover';
    var error_class = 'errorfield';
    var TURNOVER_LIMIT = 999999999999999; // 15 digits

    var onLoad = function onLoad() {
        $form = $(form_id);

        fields = {};
        $form.find('input').each(function () {
            fields[this.name] = '';
        });

        currency = Client.get('currency');

        $('.prepend_currency').parent().prepend(Currency.formatCurrency(currency));

        // gamstop is only applicable for UK residence & for MX, MLT clients
        is_gamstop_client = /gb/.test(Client.get('residence')) && /iom|malta/.test(Client.get('landing_company_shortcode'));

        initDatePicker();
        getData(true);
    };

    var getData = function getData(scroll) {
        BinarySocket.send({ get_self_exclusion: 1 }).then(function (response) {
            if (response.get_self_exclusion.exclude_until) {
                has_exclude_until = true;
            }
            if (response.error) {
                if (response.error.code === 'ClientSelfExclusion') {
                    Client.sendLogoutRequest();
                }
                if (response.error.message) {
                    $('#msg_error').html(response.error.message).setVisibility(1);
                    $form.setVisibility(0);
                }
                return;
            }
            BinarySocket.send({ get_account_status: 1 }).then(function (data) {
                var has_to_set_30day_turnover = !has_exclude_until && /ukrts_max_turnover_limit_not_set/.test(data.get_account_status.status);
                if (typeof set_30day_turnover === 'undefined') {
                    set_30day_turnover = has_to_set_30day_turnover;
                }
                $('#frm_self_exclusion').find('fieldset > div.form-row:not(.max_30day_turnover)').setVisibility(!has_to_set_30day_turnover);
                $('#description_max_30day_turnover').setVisibility(has_to_set_30day_turnover);
                $('#description').setVisibility(!has_to_set_30day_turnover);
                $('#gamstop_info_top').setVisibility(is_gamstop_client);
                $('#loading').setVisibility(0);
                $form.setVisibility(1);
                self_exclusion_data = response.get_self_exclusion;
                $.each(self_exclusion_data, function (key, value) {
                    fields[key] = value.toString();
                    if (key === 'timeout_until') {
                        var timeout = moment.unix(value);
                        var date_value = timeout.format('YYYY-MM-DD');
                        var time_value = timeout.format('HH:mm');
                        setDateTimePicker(timeout_date_id, date_value);
                        setDateTimePicker(timeout_time_id, time_value, true);
                        $form.find('label[for="timeout_until_date"]').text('Timed out until');
                        return;
                    }
                    if (key === 'exclude_until') {
                        setDateTimePicker(exclude_until_id, value);
                        $form.find('label[for="exclude_until"]').text('Excluded from the website until');
                        $('#ukgc_gamstop').setVisibility(is_gamstop_client);
                        $('#ukgc_requirement_notice').setVisibility(1);
                        return;
                    }
                    if (key === 'max_30day_turnover') {
                        var should_be_checked = parseInt(value) === TURNOVER_LIMIT;
                        $('#chk_no_limit').prop('checked', should_be_checked);
                        setMax30DayTurnoverLimit(should_be_checked);
                    }
                    $form.find('#' + key).attr('disabled', has_exclude_until).val(value);
                });
                $form.find('#btn_submit').setVisibility(!has_exclude_until);

                $('#chk_no_limit').on('change', function () {
                    setMax30DayTurnoverLimit($(this).is(':checked'));
                });

                bindValidation();
                if (scroll) scrollToHashSection();
            });
        });
    };

    var setDateTimePicker = function setDateTimePicker(id, data_value) {
        var is_timepicker = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

        $form.find(id).attr('disabled', has_exclude_until).attr('data-value', data_value).val(is_timepicker ? data_value : moment(data_value).format('DD MMM, YYYY')); // display format
    };

    var setMax30DayTurnoverLimit = function setMax30DayTurnoverLimit(is_checked) {
        $(max_30day_turnover_id)[is_checked ? 'addClass' : 'removeClass']('hide');
        $(max_30day_turnover_id).attr('disabled', is_checked).val(is_checked ? TURNOVER_LIMIT : '');
    };

    var bindValidation = function bindValidation() {
        var validations = [{ request_field: 'set_self_exclusion', value: 1 }];
        var decimal_places = Currency.getDecimalPlaces(currency);

        $form.find('input[type="text"]').each(function () {
            var id = $(this).attr('id');

            if (/timeout_until|exclude_until/.test(id)) return;

            var checks = [];
            var options = { min: 0 };
            if (id in self_exclusion_data) {
                checks.push('req');
                options.max = self_exclusion_data[id];
            } else {
                options.allow_empty = true;
            }
            if (!/session_duration_limit|max_open_bets/.test(id)) {
                options.type = 'float';
                options.decimals = decimal_places;
            }
            checks.push(['number', options]);

            if (id === 'session_duration_limit') {
                checks.push(['custom', { func: validSessionDuration, message: 'Session duration limit cannot be more than 6 weeks.' }]);
            }

            validations.push({
                selector: '#' + id,
                validations: checks,
                exclude_if_empty: 1
            });
        });

        validations.push({
            selector: timeout_date_id,
            request_field: 'timeout_until',
            re_check_field: timeout_time_id,
            exclude_if_empty: 1,
            value: getTimeout,
            validations: [['custom', { func: function func() {
                    return $(timeout_time_id).val() ? $(timeout_date_id).val().length : true;
                }, message: 'This field is required.' }], ['custom', { func: function func(value) {
                    return !value.length || getMoment(timeout_date_id).isAfter(moment().subtract(1, 'days'), 'day');
                }, message: 'Time out must be after today.' }], ['custom', { func: function func(value) {
                    return !value.length || getMoment(timeout_date_id).isBefore(moment().add(6, 'weeks'));
                }, message: 'Time out cannot be more than 6 weeks.' }]]
        }, {
            selector: timeout_time_id,
            exclude_request: 1,
            re_check_field: timeout_date_id,
            validations: [['custom', { func: function func() {
                    return $(timeout_date_id).val() && getMoment(timeout_date_id).isSame(moment(), 'day') ? $(timeout_time_id).val().length : true;
                }, message: 'This field is required.' }], ['custom', { func: function func(value) {
                    return !value.length || !$(timeout_date_id).attr('data-value') || getTimeout() > moment().valueOf() / 1000;
                }, message: 'Time out cannot be in the past.' }], ['custom', { func: validTime, message: 'Please select a valid time.' }]]
        }, {
            selector: exclude_until_id,
            exclude_if_empty: 1,
            value: function value() {
                return getDate(exclude_until_id);
            },
            validations: [['custom', { func: function func(value) {
                    return !value.length || getMoment(exclude_until_id).isAfter(moment().add(6, 'months'));
                }, message: 'Exclude time cannot be less than 6 months.' }], ['custom', { func: function func(value) {
                    return !value.length || getMoment(exclude_until_id).isBefore(moment().add(5, 'years'));
                }, message: 'Exclude time cannot be for more than 5 years.' }]]
        });

        FormManager.init(form_id, validations);
        FormManager.handleSubmit({
            form_selector: form_id,
            fnc_response_handler: setExclusionResponse,
            fnc_additional_check: additionalCheck,
            enable_button: true
        });
    };

    var validSessionDuration = function validSessionDuration(value) {
        return +value <= moment.duration(6, 'weeks').as('minutes');
    };
    var validTime = function validTime(value) {
        return !value.length || moment(value, 'HH:mm', true).isValid();
    };

    var getDate = function getDate(elm_id) {
        var $elm = $(elm_id);
        return $elm.attr('data-value') || (!isNaN(new Date($elm.val()).getTime()) ? $elm.val() : '');
    };
    var getMoment = function getMoment(elm_id) {
        return moment(new Date(getDate(elm_id)));
    };
    var getTimeout = function getTimeout() {
        return getDate(timeout_date_id) ? (moment(new Date(getDate(timeout_date_id) + 'T' + $(timeout_time_id).val())).valueOf() / 1000).toFixed(0) : '';
    };

    var initDatePicker = function initDatePicker() {
        var timeout_time_options = {
            selector: timeout_time_id
        };

        // timeout_until
        TimePicker.init(timeout_time_options);
        DatePicker.init({
            selector: timeout_date_id,
            minDate: 0,
            maxDate: 6 * 7 // 6 weeks
        });

        // exclude_until
        DatePicker.init({
            selector: exclude_until_id,
            minDate: moment().add(6, 'months').add(1, 'day').toDate(),
            maxDate: 5 * 365 // 5 years
        });

        $(timeout_date_id + ', ' + exclude_until_id).change(function () {
            dateValueChanged(this, 'date');
            var date = this.getAttribute('data-value');

            if (timeout_date_id.indexOf(this.id) > 0) {
                var disabled_time_options = {
                    minTime: 'now',
                    useLocalTime: true
                };

                // reinitialize timepicker on timeout date change
                TimePicker.init(_extends({}, timeout_time_options, moment().isBefore(moment(date)) ? undefined : disabled_time_options, {
                    datepickerDate: date
                }));
            }

            $('#gamstop_info_bottom').setVisibility(is_gamstop_client && date);
        });
    };

    var additionalCheck = function additionalCheck(data) {
        return new Promise(function (resolve) {
            var is_changed = Object.keys(data).some(function (key) {
                return (// using != in next line since response types is inconsistent
                    key !== 'set_self_exclusion' && (!(key in self_exclusion_data) || self_exclusion_data[key] != data[key]) // eslint-disable-line eqeqeq

                );
            });
            if (!is_changed) {
                showFormMessage('You did not change anything.', false);
                resolve(false);
            }

            if ('timeout_until' in data || 'exclude_until' in data) {
                Dialog.confirm({
                    id: 'timeout_until_dialog',
                    message: 'When you click "OK" you will be excluded from trading on the site until the selected date.'
                }).then(function (response) {
                    return resolve(response);
                });
            } else {
                resolve(true);
            }
        });
    };

    var setExclusionResponse = function setExclusionResponse(response) {
        if (response.error) {
            var error_msg = response.error.message;
            var error_fld = response.error.field;
            if (error_fld) {
                error_fld = /^timeout_until$/.test(error_fld) ? 'timeout_until_date' : error_fld;
                var $error_fld = $('#' + error_fld);
                $error_fld.siblings('.error-msg').setVisibility(1).html(error_msg);
                $.scrollTo($error_fld, 500, { offset: -10 });
            } else {
                showFormMessage(localize(error_msg), false);
            }
            return;
        }
        showFormMessage('Your changes have been updated.', true);
        if ($('#exclude_until').attr('data-value')) {
            $('#gamstop_info_bottom').setVisibility(0);
            $('#ukgc_gamstop').setVisibility(is_gamstop_client);
            $('#ukgc_requirement_notice').setVisibility(1);
        }
        Client.set('session_start', moment().unix()); // used to handle session duration limit
        var _response$echo_req = response.echo_req,
            exclude_until = _response$echo_req.exclude_until,
            timeout_until = _response$echo_req.timeout_until;

        if (exclude_until || timeout_until) {
            Client.set('excluded_until', exclude_until ? moment(exclude_until).unix() : timeout_until);
        }
        BinarySocket.send({ get_account_status: 1 }).then(function () {
            Header.displayAccountStatus();
            if (set_30day_turnover) {
                BinaryPjax.loadPreviousUrl();
            } else {
                getData();
                if (Client.isJPClient()) {
                    // need to update daily_loss_limit value inside jp_settings object
                    BinarySocket.send({ get_settings: 1 }, { forced: true });
                }
            }
        });
    };

    var showFormMessage = function showFormMessage(msg, is_success) {
        $('#msg_form').attr('class', is_success ? 'success-msg' : error_class).html(is_success ? $('<ul/>', { class: 'checked' }).append($('<li/>', { text: localize(msg) })) : localize(msg)).css('display', 'block').delay(5000).fadeOut(1000);
    };

    return {
        onLoad: onLoad
    };
}();

module.exports = SelfExclusion;

/***/ }),
/* 311 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var QRCode = __webpack_require__(546);
var Client = __webpack_require__(3);
var BinarySocket = __webpack_require__(5);
var FormManager = __webpack_require__(18);
var localize = __webpack_require__(2).localize;
var getPropertyValue = __webpack_require__(1).getPropertyValue;

var TwoFactorAuthentication = function () {
    var form_id = '#frm_two_factor_auth';
    var state = ['disabled', 'enabled'];
    var default_res_error_msg = 'Sorry, an error occurred while processing your request.';

    var $btn_submit = void 0,
        $form = void 0,
        $two_factor_loading = void 0,
        $qrcode_loading = void 0,
        $qrcode_key = void 0,
        current_state = void 0,
        next_state = void 0;

    var onLoad = function onLoad() {
        $btn_submit = $('#btn_submit');
        $form = $('' + form_id);
        $two_factor_loading = $('#two_factor_loading');
        $qrcode_loading = $('#qrcode_loading');
        $qrcode_key = $('#qrcode_key');

        init();
    };

    var init = function init() {
        BinarySocket.send({ account_security: 1, totp_action: 'status' }).then(function (res) {
            $two_factor_loading.setVisibility(0);

            if (res.error) {
                handleError('status', res.error.message);
                return;
            }

            current_state = state[res.account_security.totp.is_enabled];
            next_state = state[+!res.account_security.totp.is_enabled].slice(0, -1);

            $('#' + current_state).setVisibility(1);
            $btn_submit.text(localize(next_state));
            $form.setVisibility(1);

            FormManager.init(form_id, [{ selector: '#otp', validations: ['req', 'number', ['length', { min: 6, max: 6 }]], request_field: 'otp', no_scroll: true, clear_form_error_on_input: true }, { request_field: 'account_security', value: 1 }, { request_field: 'totp_action', value: next_state }]);
            FormManager.handleSubmit({
                form_selector: form_id,
                fnc_response_handler: handleSubmitResponse,
                enable_button: true
            });

            if (current_state === 'disabled') {
                $form.addClass('padding-left-medium');
                initQRCode();
            }
        });
    };

    var resetComponent = function resetComponent() {
        $('#' + current_state).setVisibility(0);
        $form.setVisibility(0).removeClass('padding-left-medium');
        $qrcode_key.text('');

        $two_factor_loading.setVisibility(1);
        $qrcode_loading.setVisibility(1);

        init();
    };

    var initQRCode = function initQRCode() {
        BinarySocket.send({ account_security: 1, totp_action: 'generate' }).then(function (res) {
            $qrcode_loading.setVisibility(0);

            if (res.error) {
                handleError('generate', res.error.message);
                return;
            }
            var secret_key = res.account_security.totp.secret_key;
            $qrcode_key.text(secret_key);

            makeQrCode(secret_key);
        });
    };

    var makeQrCode = function makeQrCode(secret_key) {
        $('#qrcode').html('');
        var text = 'otpauth://totp/' + Client.get('email') + '?secret=' + secret_key + '&issuer=Binary.com';
        var qrcode = new QRCode(document.getElementById('qrcode'), { // eslint-disable-line no-unused-vars
            text: text,
            width: 160,
            height: 160,
            correctLevel: QRCode.CorrectLevel.H
        });
    };

    var handleSubmitResponse = function handleSubmitResponse(res) {
        if ('error' in res) {
            showFormMessage(getPropertyValue(res, ['error', 'message']) || default_res_error_msg);
        } else {
            $('#otp').val('');
            showFormMessage('You have successfully ' + next_state + 'd two-factor authentication for your account.', true);
        }
    };

    var handleError = function handleError(id, err_msg) {
        $('#' + id + '_error').text(localize(err_msg || default_res_error_msg)).setVisibility(1);
    };

    var showFormMessage = function showFormMessage(msg, is_success) {
        if (is_success) {
            $(form_id + '_success').html($('<ul/>', { class: 'checked' }).append($('<li/>', { text: localize(msg) }))).css('display', 'block').delay(3000).fadeOut(1000, resetComponent);
        } else {
            $(form_id + '_error').text(localize(msg));
        }
    };

    return {
        onLoad: onLoad
    };
}();

module.exports = TwoFactorAuthentication;

/***/ }),
/* 312 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var StatementUI = __webpack_require__(314);
var ViewPopup = __webpack_require__(90);
var Client = __webpack_require__(3);
var showLocalTimeOnHover = __webpack_require__(26).showLocalTimeOnHover;
var BinarySocket = __webpack_require__(5);
var DateTo = __webpack_require__(167);
var addTooltip = __webpack_require__(57).addTooltip;
var buildOauthApps = __webpack_require__(57).buildOauthApps;
var getLanguage = __webpack_require__(16).get;
var localize = __webpack_require__(2).localize;

var StatementInit = function () {
    // Batch refer to number of data get from ws service per request
    // chunk refer to number of data populate to ui for each append
    // receive means receive from ws service
    // consume means consume by UI and displayed to page

    var batch_size = void 0,
        chunk_size = void 0,
        no_more_data = void 0,
        pending = void 0,
        current_batch = void 0,
        transactions_received = void 0,
        transactions_consumed = void 0;

    var tableExist = function tableExist() {
        return document.getElementById('statement-table');
    };

    var finishedConsumed = function finishedConsumed() {
        return transactions_consumed === transactions_received;
    };

    var getStatement = function getStatement(opts) {
        var req = { statement: 1, description: 1 };

        if (opts) $.extend(true, req, opts);

        var obj_date_to_from = DateTo.getDateToFrom();
        if (obj_date_to_from) $.extend(true, req, obj_date_to_from);

        BinarySocket.send(req).then(function (response) {
            statementHandler(response);
            $('.barspinner').setVisibility(0);
        });
    };

    var getNextBatchStatement = function getNextBatchStatement() {
        getStatement({ offset: transactions_received, limit: batch_size });
        pending = true;
    };

    var getNextChunkStatement = function getNextChunkStatement() {
        var chunk = current_batch.splice(0, chunk_size);
        transactions_consumed += chunk.length;
        $('#rows_count').text(transactions_consumed);
        return chunk;
    };

    var statementHandler = function statementHandler(response) {
        if (response.error) {
            StatementUI.errorMessage(response.error.message);
            return;
        }

        pending = false;

        var statement = response.statement;
        current_batch = statement.transactions;
        transactions_received += current_batch.length;

        if (current_batch.length < batch_size) {
            no_more_data = true;
        }

        if (!tableExist()) {
            StatementUI.createEmptyStatementTable().appendTo('#statement-container');
            $('.act, .credit').addClass('nowrap');
            StatementUI.updateStatementTable(getNextChunkStatement());

            // Show a message when the table is empty
            if (transactions_received === 0 && current_batch.length === 0) {
                $('#statement-table').find('tbody').append($('<tr/>', { class: 'flex-tr' }).append($('<td/>', { colspan: 7 }).append($('<p/>', { class: 'notice-msg center-text', text: localize('Your account has no trading activity.') }))));
            } else {
                $('#util_row').setVisibility(1);
                if (getLanguage() === 'JA' && Client.get('residence') === 'jp') {
                    $('#download_csv').setVisibility(1).find('a').unbind('click').click(function () {
                        StatementUI.exportCSV();
                    });
                }
            }
        }
        showLocalTimeOnHover('td.date');
    };

    var loadStatementChunkWhenScroll = function loadStatementChunkWhenScroll() {
        $(document).scroll(function () {
            var hidableHeight = function hidableHeight(percentage) {
                var total_hideable = $(document).height() - $(window).height();
                return Math.floor(total_hideable * percentage / 100);
            };

            var p_from_top = $(document).scrollTop();

            if (!tableExist() || p_from_top < hidableHeight(70)) return;

            if (finishedConsumed() && !no_more_data && !pending) {
                getNextBatchStatement();
                return;
            }

            if (!finishedConsumed()) StatementUI.updateStatementTable(getNextChunkStatement());
        });
    };

    var onUnload = function onUnload() {
        pending = false;
        no_more_data = false;

        current_batch = [];

        transactions_received = 0;
        transactions_consumed = 0;

        StatementUI.errorMessage(null);
        StatementUI.clearTableContent();
    };

    var initPage = function initPage() {
        batch_size = 200;
        chunk_size = batch_size / 2;
        no_more_data = false;
        pending = false; // serve as a lock to prevent ws request is sequential
        current_batch = [];
        transactions_received = 0;
        transactions_consumed = 0;

        BinarySocket.send({ oauth_apps: 1 }).then(function (response) {
            addTooltip(StatementUI.setOauthApps(buildOauthApps(response)));
        });
        getNextBatchStatement();
        loadStatementChunkWhenScroll();
    };

    var onLoad = function onLoad() {
        initPage();
        DateTo.attachDateToPicker(function () {
            StatementUI.clearTableContent();
            $('.barspinner').setVisibility(1);
            initPage();
        });
        ViewPopup.viewButtonOnClick('#statement-container');
    };

    return {
        onLoad: onLoad,
        onUnload: onUnload
    };
}();

module.exports = StatementInit;

/***/ }),
/* 313 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var moment = __webpack_require__(9);
var Client = __webpack_require__(3);
var toJapanTimeIfNeeded = __webpack_require__(26).toJapanTimeIfNeeded;
var formatCurrency = __webpack_require__(7).formatCurrency;
var formatMoney = __webpack_require__(7).formatMoney;
var localize = __webpack_require__(2).localize;
var toTitleCase = __webpack_require__(17).toTitleCase;

var Statement = function () {
    var getStatementData = function getStatementData(statement, currency, jp_client) {
        var date_obj = new Date(statement.transaction_time * 1000);
        var moment_obj = moment.utc(date_obj);
        var date_str = moment_obj.format('YYYY-MM-DD');
        var time_str = moment_obj.format('HH:mm:ss') + ' GMT';
        var payout = parseFloat(statement.payout);
        var amount = parseFloat(statement.amount);
        var balance = parseFloat(statement.balance_after);
        var is_ico_bid = /binaryico/i.test(statement.shortcode); // TODO: remove ico exception when all ico contracts are removed

        var action = toTitleCase(statement.action_type);
        if (is_ico_bid) {
            action = /buy/i.test(statement.action_type) ? localize('Bid') : localize('Closed Bid');
        }

        return {
            action: action,
            date: jp_client ? toJapanTimeIfNeeded(+statement.transaction_time) : date_str + '\n' + time_str,
            ref: statement.transaction_id,
            payout: isNaN(payout) || is_ico_bid || !+payout ? '-' : formatMoney(currency, payout, !jp_client),
            amount: isNaN(amount) ? '-' : formatMoney(currency, amount, !jp_client),
            balance: isNaN(balance) ? '-' : formatMoney(currency, balance, !jp_client),
            desc: statement.longcode.replace(/\n/g, '<br />'),
            id: statement.contract_id,
            app_id: statement.app_id
        };
    };

    var generateCSV = function generateCSV(all_data, jp_client) {
        var columns = ['date', 'ref', 'payout', 'action', 'desc', 'amount', 'balance'];
        var header = ['Date', 'Reference ID', 'Potential Payout', 'Action', 'Description', 'Credit/Debit'].map(function (str) {
            return localize(str);
        });
        var currency = Client.get('currency');
        header.push(localize('Balance') + (jp_client || !currency ? '' : ' (' + currency + ')'));
        var sep = ',';
        var csv = [header.join(sep)];
        if (all_data && all_data.length > 0) {
            // eslint-disable-next-line no-control-regex
            csv = csv.concat(all_data.map(function (data) {
                return columns.map(function (key) {
                    return data[key] ? data[key].replace(formatCurrency(currency), '¥').replace(new RegExp(sep, 'g'), '').replace(new RegExp('\n|<br />', 'g'), ' ') : '';
                }).join(sep);
            }));
        }
        return csv.join('\r\n');
    };

    return {
        getStatementData: getStatementData,
        generateCSV: generateCSV
    };
}();

module.exports = Statement;

/***/ }),
/* 314 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Statement = __webpack_require__(313);
var Client = __webpack_require__(3);
var toJapanTimeIfNeeded = __webpack_require__(26).toJapanTimeIfNeeded;
var Table = __webpack_require__(76);
var showTooltip = __webpack_require__(57).showTooltip;
var localize = __webpack_require__(2).localize;
var downloadCSV = __webpack_require__(1).downloadCSV;

var StatementUI = function () {
    var all_data = [];
    var oauth_apps = {};

    var table_id = 'statement-table';
    var columns = ['date', 'ref', 'payout', 'act', 'desc', 'credit', 'bal', 'details'];

    var createEmptyStatementTable = function createEmptyStatementTable() {
        var header = [localize('Date'), localize('Ref.'), localize('Potential Payout'), localize('Action'), localize('Description'), localize('Credit/Debit'), localize('Balance'), localize('Details')];

        var currency = Client.get('currency');

        header[6] += Client.isJPClient() || !currency ? '' : ' (' + currency + ')';

        var metadata = {
            id: table_id,
            cols: columns
        };
        var data = [];
        return Table.createFlexTable(data, metadata, header);
    };

    var clearTableContent = function clearTableContent() {
        Table.clearTableBody(table_id);
        all_data = [];
        $('#' + table_id + ' > tfoot').hide();
    };

    var createStatementRow = function createStatementRow(transaction) {
        var statement_data = Statement.getStatementData(transaction, Client.get('currency'), Client.isJPClient());
        all_data.push($.extend({}, statement_data, {
            action: localize(statement_data.action),
            desc: localize(statement_data.desc)
        }));
        var credit_debit_type = parseFloat(transaction.amount) >= 0 ? 'profit' : 'loss';

        var $statement_row = Table.createFlexTableRow([statement_data.date, '<span ' + showTooltip(statement_data.app_id, oauth_apps[statement_data.app_id]) + '>' + statement_data.ref + '</span>', statement_data.payout, localize(statement_data.action), '', statement_data.amount, statement_data.balance, ''], columns, 'data');

        $statement_row.children('.credit').addClass(credit_debit_type);
        $statement_row.children('.date').addClass('pre');
        $statement_row.children('.desc').html(localize(statement_data.desc) + '<br>');

        // create view button and append
        if (statement_data.action === 'Sell' || statement_data.action === 'Buy') {
            var $view_button = $('<button/>', { class: 'button open_contract_details', text: localize('View'), contract_id: statement_data.id });
            $statement_row.children('.desc,.details').append($view_button);
        }

        return $statement_row[0]; // return DOM instead of jquery object
    };

    var updateStatementTable = function updateStatementTable(transactions) {
        Table.appendTableBody(table_id, transactions, createStatementRow);
    };

    var errorMessage = function errorMessage(msg) {
        var $err = $('#statement-container').find('#error-msg');
        if (msg) {
            $err.setVisibility(1).text(msg);
        } else {
            $err.setVisibility(0).text('');
        }
    };

    var exportCSV = function exportCSV() {
        downloadCSV(Statement.generateCSV(all_data, Client.isJPClient()), 'Statement_' + Client.get('loginid') + '_latest' + $('#rows_count').text() + '_' + toJapanTimeIfNeeded(window.time).replace(/\s/g, '_').replace(/:/g, '') + '.csv');
    };

    return {
        clearTableContent: clearTableContent,
        createEmptyStatementTable: createEmptyStatementTable,
        updateStatementTable: updateStatementTable,
        errorMessage: errorMessage,
        exportCSV: exportCSV,

        setOauthApps: function setOauthApps(values) {
            return oauth_apps = values;
        }
    };
}();

module.exports = StatementUI;

/***/ }),
/* 315 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Client = __webpack_require__(3);
var BinarySocket = __webpack_require__(5);
var formatMoney = __webpack_require__(7).formatMoney;
var localize = __webpack_require__(2).localize;

var TopUpVirtual = function () {
    var $views = void 0;

    var view_ids = {
        error: '#viewError',
        success: '#viewSuccess'
    };

    var onLoad = function onLoad() {
        $views = $('#topup_virtual .viewItem');
        $views.setVisibility(0);

        BinarySocket.send({ topup_virtual: '1' }).then(function (response) {
            if (response.error) {
                showMessage(localize(response.error.message), false);
            } else {
                showMessage(localize('[_1] [_2] has been credited into your virtual account: [_3].', [response.topup_virtual.currency, formatMoney(response.topup_virtual.currency, response.topup_virtual.amount), Client.get('loginid')]), true);
            }
            $('.barspinner').setVisibility(0);
        });
    };

    var showMessage = function showMessage(message, is_success) {
        var view_id = is_success ? view_ids.success : view_ids.error;
        setActiveView(view_id);
        $(view_id + ' > p').html(message);
    };

    var setActiveView = function setActiveView(view_id) {
        $views.setVisibility(0);
        $(view_id).setVisibility(1);
    };

    return {
        onLoad: onLoad
    };
}();

module.exports = TopUpVirtual;

/***/ }),
/* 316 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var moment = __webpack_require__(9);
var setIsForNewAccount = __webpack_require__(180).setIsForNewAccount;
var getCurrencies = __webpack_require__(317).getCurrencies;
var BinaryPjax = __webpack_require__(12);
var Client = __webpack_require__(3);
var BinarySocket = __webpack_require__(5);
var getCurrencyList = __webpack_require__(7).getCurrencyList;
var FormManager = __webpack_require__(18);
var getElementById = __webpack_require__(4).getElementById;
var localize = __webpack_require__(2).localize;
var State = __webpack_require__(6).State;
var toTitleCase = __webpack_require__(17).toTitleCase;
var urlFor = __webpack_require__(8).urlFor;

var Accounts = function () {
    var landing_company = void 0;
    var form_id = '#new_accounts';

    var onLoad = function onLoad() {
        if (!Client.get('residence')) {
            // ask client to set residence first since cannot wait landing_company otherwise
            BinaryPjax.load(urlFor('user/settings/detailsws'));
        }
        BinarySocket.wait('landing_company', 'get_settings').then(function () {
            landing_company = State.getResponse('landing_company');

            populateExistingAccounts();

            var element_to_show = '#no_new_accounts_wrapper';
            var upgrade_info = Client.getUpgradeInfo();
            if (upgrade_info.can_upgrade) {
                populateNewAccounts(upgrade_info);
                element_to_show = '#new_accounts_wrapper';
            }

            if (upgrade_info.can_open_multi) {
                populateMultiAccount();
            } else {
                doneLoading(element_to_show);
            }
        });
    };

    var doneLoading = function doneLoading(element_to_show) {
        $(element_to_show).setVisibility(1);
        $('#accounts_loading').remove();
        $('#accounts_wrapper').setVisibility(1);
    };

    var getCompanyName = function getCompanyName(account) {
        return Client.getLandingCompanyValue(account, landing_company, 'name');
    };

    var populateNewAccounts = function populateNewAccounts(upgrade_info) {
        var new_account = upgrade_info;
        var account = {
            real: new_account.type === 'real',
            financial: new_account.type === 'financial'
        };

        $(form_id).find('tbody').append($('<tr/>').append($('<td/>').html($('<span/>', { text: localize(toTitleCase(new_account.type) + ' Account'), 'data-balloon': localize('Counterparty') + ': ' + getCompanyName(account) }))).append($('<td/>', { text: getAvailableMarkets(account) })).append($('<td/>', { text: Client.getLandingCompanyValue(account, landing_company, 'legal_allowed_currencies').join(', ') })).append($('<td/>').html($('<a/>', { class: 'button', href: urlFor(new_account.upgrade_link) }).html($('<span/>', { text: localize('Create') })))));
    };

    var populateExistingAccounts = function populateExistingAccounts() {
        var all_login_ids = Client.getAllLoginids();
        // Populate active loginids first.
        all_login_ids.filter(function (loginid) {
            return !Client.get('is_disabled', loginid) && !Client.get('excluded_until', loginid);
        }).sort(function (a, b) {
            return a > b;
        }).forEach(function (loginid) {
            appendExistingAccounts(loginid);
        });

        // Populate disabled or self excluded loginids.
        all_login_ids.filter(function (loginid) {
            return Client.get('is_disabled', loginid) || Client.get('excluded_until', loginid);
        }).sort(function (a, b) {
            return a > b;
        }).forEach(function (loginid) {
            appendExistingAccounts(loginid);
        });
    };

    var appendExistingAccounts = function appendExistingAccounts(loginid) {
        var account_currency = Client.get('currency', loginid);
        var account_type_prop = { text: localize(Client.getAccountTitle(loginid)) };

        if (!Client.isAccountOfType('virtual', loginid)) {
            var company_name = getCompanyName(loginid);
            account_type_prop['data-balloon'] = localize('Counterparty') + ': ' + company_name;
        }

        var is_disabled = Client.get('is_disabled', loginid);
        var excluded_until = Client.get('excluded_until', loginid);
        var txt_markets = '';
        if (is_disabled) {
            txt_markets = localize('This account is disabled');
        } else if (excluded_until) {
            txt_markets = localize('This account is excluded until [_1]', [moment(+excluded_until * 1000).format('YYYY-MM-DD HH:mm:ss Z')]);
        } else {
            txt_markets = getAvailableMarkets(loginid);
        }

        $('#existing_accounts').find('tbody').append($('<tr/>', { id: loginid, class: is_disabled || excluded_until ? 'color-dark-white' : '' }).append($('<td/>', { text: loginid })).append($('<td/>').html($('<span/>', account_type_prop))).append($('<td/>', { text: txt_markets })).append($('<td/>').html(!account_currency && loginid === Client.get('loginid') ? $('<a/>', { class: 'button', href: urlFor('user/set-currency') }).html($('<span/>', { text: localize('Set Currency') })) : account_currency || '-')));

        if (is_disabled || excluded_until) {
            $('#note_support').setVisibility(1);
        }
    };

    var getAvailableMarkets = function getAvailableMarkets(loginid) {
        var legal_allowed_markets = Client.getLandingCompanyValue(loginid, landing_company, 'legal_allowed_markets') || '';
        if (Array.isArray(legal_allowed_markets) && legal_allowed_markets.length) {
            legal_allowed_markets = legal_allowed_markets.map(function (market) {
                return getMarketName(market);
            }).filter(function (value, index, self) {
                return value && self.indexOf(value) === index;
            }).join(', ');
        }
        return legal_allowed_markets;
    };

    var markets = {
        commodities: 'Commodities',
        forex: 'Forex',
        indices: 'Indices',
        stocks: 'Stocks',
        volidx: 'Volatility Indices'
    };

    var getMarketName = function getMarketName(market) {
        return localize(markets[market] || '');
    };

    var populateMultiAccount = function populateMultiAccount() {
        var currencies = getCurrencies(landing_company);
        $(form_id).find('tbody').append($('<tr/>', { id: 'new_account_opening' }).append($('<td/>').html($('<span/>', { text: localize('Real Account'), 'data-balloon': localize('Counterparty') + ': ' + getCompanyName({ real: 1 }) }))).append($('<td/>', { text: getAvailableMarkets({ real: 1 }) })).append($('<td/>', { class: 'account-currency' })).append($('<td/>').html($('<button/>', { text: localize('Create'), type: 'submit' }))));

        $('#note').setVisibility(1);

        var $new_account_opening = $('#new_account_opening');
        if (currencies.length > 1) {
            var $currencies = $('<div/>');
            $currencies.append(getCurrencyList(currencies).html());
            $new_account_opening.find('.account-currency').html($('<select/>', { id: 'new_account_currency' }).html($currencies.html()));
        } else {
            $new_account_opening.find('.account-currency').html($('<label/>', { id: 'new_account_currency', 'data-value': currencies, text: currencies }));
        }

        // need to make it visible before adding the form manager event on it
        doneLoading('#new_accounts_wrapper');

        var el_select_currency = /select/i.test(getElementById('new_account_currency').nodeName);
        FormManager.init(form_id, [{ selector: '#new_account_currency', request_field: 'currency', validations: [el_select_currency ? 'req' : ''], hide_asterisk: true }].concat(populateReq()));

        FormManager.handleSubmit({
            form_selector: form_id,
            fnc_response_handler: newAccountResponse
        });
    };

    var newAccountResponse = function newAccountResponse(response) {
        if (response.error) {
            if (/InsufficientAccountDetails|InputValidationFailed/.test(response.error.code)) {
                setIsForNewAccount(true);
                // ask client to set any missing information
                BinaryPjax.load(urlFor('user/settings/detailsws'));
            } else {
                showError(response.error.message);
            }
        } else {
            var new_account = response.new_account_real;
            localStorage.setItem('is_new_account', 1);
            Client.processNewAccount({
                email: Client.get('email'),
                loginid: new_account.client_id,
                token: new_account.oauth_token,
                redirect_url: urlFor('user/set-currency')
            });
        }
    };

    var showError = function showError(message) {
        $('#new_account_error').remove();
        $('#new_account_opening').find('button').parent().append($('<p/>', { class: 'error-msg', id: 'new_account_error', text: localize(message) }));
    };

    var populateReq = function populateReq() {
        var get_settings = State.getResponse('get_settings');
        var dob = moment.utc(+get_settings.date_of_birth * 1000).format('YYYY-MM-DD');
        var req = [{ request_field: 'new_account_real', value: 1 }, { request_field: 'date_of_birth', value: dob }, { request_field: 'salutation', value: get_settings.salutation }, { request_field: 'first_name', value: get_settings.first_name }, { request_field: 'last_name', value: get_settings.last_name }, { request_field: 'address_line_1', value: get_settings.address_line_1 }, { request_field: 'address_line_2', value: get_settings.address_line_2 }, { request_field: 'address_city', value: get_settings.address_city }, { request_field: 'address_state', value: get_settings.address_state }, { request_field: 'address_postcode', value: get_settings.address_postcode }, { request_field: 'phone', value: get_settings.phone }, { request_field: 'account_opening_reason', value: get_settings.account_opening_reason }, { request_field: 'place_of_birth', value: get_settings.place_of_birth }, { request_field: 'residence', value: Client.get('residence') }];
        if (get_settings.tax_identification_number) {
            req.push({ request_field: 'tax_identification_number', value: get_settings.tax_identification_number });
        }
        if (get_settings.tax_residence) {
            req.push({ request_field: 'tax_residence', value: get_settings.tax_residence });
        }
        return req;
    };

    return {
        onLoad: onLoad
    };
}();

module.exports = Accounts;

/***/ }),
/* 317 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Client = __webpack_require__(3);
var Currency = __webpack_require__(7);

var GetCurrency = function () {
    var getCurrenciesOfOtherAccounts = function getCurrenciesOfOtherAccounts() {
        var all_loginids = Client.getAllLoginids();
        var other_currencies = [];
        all_loginids.forEach(function (loginid) {
            // if it's not current client or virtual client, consider the currency
            if (Client.get('loginid') !== loginid && Client.getAccountType(loginid) !== 'virtual') {
                var currency = Client.get('currency', loginid);
                if (currency) {
                    other_currencies.push(currency);
                }
            }
        });
        return other_currencies;
    };

    var getCurrencyValues = function getCurrencyValues() {
        var currencies = Currency.getCurrencies();
        var fiat_currencies = [];
        var cryptocurrencies = [];
        Object.keys(currencies).forEach(function (currency) {
            if (currencies[currency].type === 'fiat') {
                fiat_currencies.push(currency);
            } else {
                cryptocurrencies.push(currency);
            }
        });
        var other_currencies = getCurrenciesOfOtherAccounts();

        return {
            cryptocurrencies: cryptocurrencies,
            other_currencies: other_currencies,

            has_fiat: other_currencies.some(function (currency) {
                return fiat_currencies.indexOf(currency) > -1;
            })
        };
    };

    var getCurrencies = function getCurrencies(landing_company) {
        var client_currency = Client.get('currency');
        var is_crypto = Currency.isCryptocurrency(client_currency);
        var currency_values = getCurrencyValues();

        var available_crypto = currency_values.cryptocurrencies.filter(function (c) {
            return currency_values.other_currencies.concat(is_crypto ? client_currency : []).indexOf(c) < 0;
        });
        var can_open_crypto = available_crypto.length;

        var currencies_to_show = [];
        // only allow client to open more sub accounts if the last currency is not to be reserved for master account
        if (client_currency && (can_open_crypto || !currency_values.has_fiat) || !client_currency && (available_crypto.length > 1 || can_open_crypto && !currency_values.has_fiat)) {
            // if have sub account with fiat currency, or master account is fiat currency, only show cryptocurrencies
            // else show all
            currencies_to_show = currency_values.has_fiat || !is_crypto && client_currency ? currency_values.cryptocurrencies : Client.getLandingCompanyValue({ real: 1 }, landing_company, 'legal_allowed_currencies');
            // remove client's currency and sub account currencies from list of currencies to show
            currencies_to_show = currencies_to_show.filter(function (c) {
                return currency_values.other_currencies.concat(client_currency).indexOf(c) < 0;
            });
        }

        return currencies_to_show;
    };

    return {
        getCurrencies: getCurrencies
    };
}();

module.exports = GetCurrency;

/***/ }),
/* 318 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var FormManager = __webpack_require__(18);
var localize = __webpack_require__(2).localize;

var LostPassword = function () {
    var form_id = '#frm_lost_password';

    var responseHandler = function responseHandler(response) {
        if (response.verify_email) {
            $('#password_reset_description').setVisibility(0);
            $('#check_spam').setVisibility(1);
            $(form_id).html($('<div/>', { class: 'notice-msg', text: localize('Please check your email for the password reset link.') }));
        } else if (response.error) {
            var $form_error = $('#form_error');
            $form_error.text(localize(response.error.message)).setVisibility(1);
            $('#email').one('input', function () {
                return $form_error.setVisibility(0);
            }); // remove error message on input
        }
    };

    var onLoad = function onLoad() {
        FormManager.init(form_id, [{ selector: '#email', validations: ['req', 'email'], request_field: 'verify_email' }, { request_field: 'type', value: 'reset_password' }]);
        FormManager.handleSubmit({
            form_selector: form_id,
            fnc_response_handler: responseHandler
        });
    };

    return {
        onLoad: onLoad
    };
}();

module.exports = LostPassword;

/***/ }),
/* 319 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var MetaTraderConfig = __webpack_require__(182);
var Client = __webpack_require__(3);
var formatMoney = __webpack_require__(7).formatMoney;
var Validation = __webpack_require__(56);
var localize = __webpack_require__(2).localize;
var State = __webpack_require__(6).State;
var urlForStatic = __webpack_require__(8).urlForStatic;
var getHashValue = __webpack_require__(8).getHashValue;
var getPropertyValue = __webpack_require__(1).getPropertyValue;
var showLoadingImage = __webpack_require__(1).showLoadingImage;

var MetaTraderUI = function () {
    var $container = void 0,
        $list_cont = void 0,
        $mt5_account = void 0,
        $list = void 0,
        $detail = void 0,
        $action = void 0,
        $templates = void 0,
        _$form = void 0,
        $main_msg = void 0,
        validations = void 0,
        submit = void 0,
        token = void 0;

    var accounts_info = MetaTraderConfig.accounts_info;
    var actions_info = MetaTraderConfig.actions_info;

    var init = function init(submit_func) {
        token = getHashValue('token');
        submit = submit_func;
        $container = $('#mt_account_management');
        $mt5_account = $container.find('#mt5_account');
        $list_cont = $container.find('#accounts_list');
        $list = $list_cont.find('> div.list');
        $detail = $container.find('#account_details');
        $action = $container.find('#fst_action');
        $templates = $container.find('#templates').remove();
        $main_msg = $container.find('#main_msg');
        $container.find('[class*="act_"]').click(populateForm);

        MetaTraderConfig.setMessages($templates.find('#messages'));

        validations = MetaTraderConfig.validations();

        populateAccountTypes();
        populateAccountList();
    };

    var populateAccountList = function populateAccountList() {
        var $acc_name = $templates.find('> .acc-name');
        var acc_group_demo_set = false;
        var acc_group_real_set = false;
        var acc_group_mam_set = false;
        Object.keys(accounts_info).sort(function (a, b) {
            return accounts_info[a].account_type > accounts_info[b].account_type ? 1 : -1;
        }).sort(function (a, b) {
            return (/mam/.test(a) && !/mam/.test(b) ? 1 : -1
            );
        }) // Show MAM last
        .forEach(function (acc_type) {
            if ($list.find('[value="' + acc_type + '"]').length === 0) {
                if (/^demo/.test(acc_type)) {
                    if (!acc_group_demo_set) {
                        $list.append($('<div/>', { class: 'acc-group invisible', id: 'acc_group_demo', text: localize('Demo Accounts') }));
                        acc_group_demo_set = true;
                    }
                } else if (/mam/.test(acc_type)) {
                    if (!acc_group_mam_set) {
                        $list.append($('<div/>', { class: 'acc-group invisible', id: 'acc_group_mam', text: localize('MAM Accounts') }));
                        acc_group_mam_set = true;
                    }
                } else if (!acc_group_real_set) {
                    $list.append($('<div/>', { class: 'acc-group invisible', id: 'acc_group_real', text: localize('Real-Money Accounts') }));
                    acc_group_real_set = true;
                }
                var $acc_item = $acc_name.clone();
                $acc_item.attr('value', acc_type);
                $list.append($acc_item);
            }
        });

        var hideList = function hideList() {
            $list_cont.slideUp('fast', function () {
                $mt5_account.removeClass('open');
            });
        };

        // account switch events
        $mt5_account.off('click').on('click', function (e) {
            e.stopPropagation();
            if ($list_cont.is(':hidden')) {
                $mt5_account.addClass('open');
                $list_cont.slideDown('fast');
            } else {
                hideList();
            }
        });
        $list.off('click').on('click', '.acc-name', function () {
            if (!$(this).hasClass('disabled')) {
                setAccountType($(this).attr('value'), true);
            }
        });
        $(document).off('click.mt5_account_list').on('click.mt5_account_list', function () {
            hideList();
        });
    };

    var setAccountType = function setAccountType(acc_type, should_set_account) {
        if ($mt5_account.attr('value') !== acc_type) {
            Client.set('mt5_account', acc_type);
            $mt5_account.attr('value', acc_type).removeClass('empty');
            setMTAccountText();
            $list.find('.acc-name').removeClass('selected');
            $list.find('[value="' + acc_type + '"]').addClass('selected');
            $action.setVisibility(0);
            if (should_set_account) {
                setCurrentAccount(acc_type);
                $.scrollTo($('h1'), 300, { offset: -10 });
            }
        }
    };

    var updateAccount = function updateAccount(acc_type) {
        updateListItem(acc_type);
        setCurrentAccount(acc_type);
    };

    var setMTAccountText = function setMTAccountText() {
        var acc_type = $mt5_account.attr('value');
        if (acc_type) {
            var login = getPropertyValue(accounts_info[acc_type], ['info', 'login']);
            var title = '' + accounts_info[acc_type].title + (login ? ' (' + login + ')' : '');
            if (!new RegExp(title).test($mt5_account.text())) {
                $mt5_account.html(title);
            }
        }
    };

    var updateListItem = function updateListItem(acc_type) {
        var $acc_item = $list.find('[value="' + acc_type + '"]');
        $acc_item.find('.mt-type').text(accounts_info[acc_type].title.replace(/(demo|real(\smam)*)\s/i, ''));
        if (accounts_info[acc_type].info) {
            setMTAccountText();
            $acc_item.find('.mt-login').text('(' + accounts_info[acc_type].info.login + ')');
            $acc_item.setVisibility(1);
            if (/demo/.test(accounts_info[acc_type].account_type)) {
                $list.find('#acc_group_demo').setVisibility(1);
            } else if (/mam/.test(acc_type)) {
                $list.find('#acc_group_mam').setVisibility(1);
            } else {
                $list.find('#acc_group_real').setVisibility(1);
            }
            if (acc_type === Client.get('mt5_account')) {
                var mt_balance = formatMoney(MetaTraderConfig.getCurrency(acc_type), +accounts_info[acc_type].info.balance);
                $acc_item.find('.mt-balance').html(mt_balance);
                $action.find('.mt5-balance').html(mt_balance);
            }
            if (Object.keys(accounts_info).every(function (type) {
                return accounts_info[type].info;
            })) {
                $container.find('.act_new_account').remove();
            }
        } else {
            $acc_item.setVisibility(0);
        }
    };

    var displayAccountDescription = function displayAccountDescription(acc_type) {
        $container.find('#account_desc').html($templates.find('.account-desc .' + acc_type).clone());
    };

    var setCurrentAccount = function setCurrentAccount(acc_type) {
        if (Client.get('mt5_account') && Client.get('mt5_account') !== acc_type) return;

        displayAccountDescription(acc_type);

        if (accounts_info[acc_type].info) {
            // Update account info
            $detail.find('.acc-info div[data]').map(function () {
                var key = $(this).attr('data');
                var info = accounts_info[acc_type].info[key];
                var mapping = {
                    balance: function balance() {
                        return isNaN(info) ? '' : formatMoney(MetaTraderConfig.getCurrency(acc_type), +info);
                    },
                    leverage: function leverage() {
                        return '1:' + info;
                    },
                    login: function login() {
                        return info + ' (' + localize(/demo/.test(accounts_info[acc_type].account_type) ? 'Demo Account' : 'Real-Money Account') + ')';
                    }
                };
                $(this).html(typeof mapping[key] === 'function' ? mapping[key]() : info);
            });
            // $container.find('.act_cashier').setVisibility(!types_info[acc_type].is_demo);
            $container.find('.has-account').setVisibility(1);
        } else {
            $detail.find('.acc-info, .acc-actions').setVisibility(0);
        }
        $('#mt_loading').remove();
        $container.setVisibility(1);

        setAccountType(acc_type);

        if ($action.hasClass('invisible')) {
            loadAction(defaultAction(acc_type));
        }
    };

    var defaultAction = function defaultAction(acc_type) {
        var type = 'new_account';
        if (accounts_info[acc_type].info) {
            type = accounts_info[acc_type].is_demo || Client.get('is_virtual') || getHashValue('token') ? 'manage_password' : 'cashier';
            removeUrlHash(); // only load manage_password section on first page load if token in url, after that remove it from url
        }
        return type;
    };

    var loadAction = function loadAction(action, acc_type) {
        $container.find('[class~=act_' + (action || defaultAction(acc_type)) + ']').click();
    };

    var populateForm = function populateForm(e) {
        var $target = $(e.target);
        if ($target.prop('tagName').toLowerCase() !== 'a') {
            $target = $target.parents('a');
        }
        $main_msg.setVisibility(0);

        var acc_type = Client.get('mt5_account');
        var action = $target.attr('class').split(' ').find(function (c) {
            return (/^act_/.test(c)
            );
        }).replace('act_', '');

        var cloneForm = function cloneForm() {
            _$form = $templates.find('#frm_' + action).clone();
            _$form.find('.' + (/demo/.test(acc_type) ? 'demo' : 'real') + '-only').setVisibility(1);
            var formValues = (actions_info[action] || {}).formValues;
            if (formValues) formValues(_$form, acc_type, action);

            // append form
            $action.find('#frm_action').html(_$form).setVisibility(1).end().setVisibility(1);

            if (action === 'manage_password') {
                _$form.find('button[type="submit"]').append(accounts_info[acc_type].info.login ? ' ' + localize('for account [_1]', [accounts_info[acc_type].info.login]) : '');
                if (!token) {
                    _$form.find('#frm_verify_password_reset').setVisibility(1);
                } else if (!Validation.validEmailToken(token)) {
                    _$form.find('#frm_verify_password_reset').find('#token_error').setVisibility(1).end().setVisibility(1);
                } else {
                    _$form.find('#frm_password_reset').setVisibility(1);
                }
            }

            if (action === 'revoke_mam') {
                _$form.find('#mam_id').text(accounts_info[acc_type].info.manager_id);
            }

            _$form.find('button[type="submit"]').each(function () {
                // cashier has two different actions
                var this_action = $(this).attr('action');
                actions_info[this_action].$form = $(this).parents('form');
                $(this).attr({ acc_type: acc_type }).on('click dblclick', submit);
                Validation.init('#frm_' + this_action, validations[this_action]);
            });

            handleNewAccountUI(action, acc_type, $target);
        };

        if (/manage_password|new_account/.test(action)) {
            cloneForm();
            return;
        }

        if (action === 'cashier') {
            // Manage Fund
            var client_currency = Client.get('currency');
            var mt_currency = MetaTraderConfig.getCurrency(acc_type);
            cloneForm();
            _$form.find('.binary-account').text('' + localize('[_1] Account [_2]', ['Binary', Client.get('loginid')]));
            _$form.find('.binary-balance').html('' + formatMoney(client_currency, Client.get('balance')));
            _$form.find('.mt5-account').text('' + localize('[_1] Account [_2]', [accounts_info[acc_type].title, accounts_info[acc_type].info.login]));
            _$form.find('.mt5-balance').html('' + formatMoney(mt_currency, accounts_info[acc_type].info.balance));
            _$form.find('label[for="txt_amount_deposit"]').append(' ' + client_currency);
            _$form.find('label[for="txt_amount_withdrawal"]').append(' ' + mt_currency);

            _$form.find('#txt_amount_deposit, #txt_amount_withdrawal').siblings('.hint').setVisibility(client_currency !== mt_currency);

            ['deposit', 'withdrawal'].forEach(function (act) {
                actions_info[act].prerequisites(acc_type).then(function (error_msg) {
                    if (error_msg) {
                        $container.find('#frm_' + act + ' .form').replaceWith($('<p/>', { class: 'unavailable' }));
                        displayMessage('#frm_' + act + ' .unavailable', error_msg, true);
                    }
                });
            });

            if (!accounts_info[acc_type].is_demo) {
                var msg = '';
                if (Client.get('is_virtual')) {
                    msg = MetaTraderConfig.needsRealMessage();
                } else if (!Client.get('currency')) {
                    // client should set currency before accessing fund management section
                    msg = $templates.find('#msg_set_currency').html();
                }
                if (msg) {
                    displayMainMessage(msg, false);
                    $action.find('#frm_cashier').setVisibility(0);
                }
            }
            return;
        }

        actions_info[action].prerequisites(acc_type).then(function (error_msg) {
            if (error_msg) {
                // does not meet one of prerequisites
                displayMainMessage(error_msg);
                $action.find('#frm_action').empty().end().setVisibility(1);
                $container.find('[class*="act_"]').removeClass('selected');
                $container.find('[class~=act_' + action + ']').addClass('selected');
                return;
            }

            if (!$action.find('#frm_' + action).length) {
                $main_msg.setVisibility(0);
            }

            cloneForm();
        });
    };

    // -----------------------
    // ----- New Account -----
    // -----------------------
    var handleNewAccountUI = function handleNewAccountUI(action, acc_type, $target) {
        var is_new_account = /new_account/.test(action);
        var $acc_actions = $container.find('.acc-actions');
        $acc_actions.find('.new-account').setVisibility(is_new_account);
        $acc_actions.find('.has-account').setVisibility(!is_new_account);
        $acc_actions.find('.has-mam').setVisibility(is_new_account ? 0 : getPropertyValue(accounts_info, [Client.get('mt5_account'), 'info', 'manager_id']));
        $detail.setVisibility(!is_new_account);

        $container.find('[class*="act_"]').removeClass('selected');
        // set active tab
        if (is_new_account) {
            $container.find('[class~=act_' + action + ']').addClass('selected');
        } else {
            $detail.setVisibility(1);
            $target.addClass('selected');
            return;
        }

        if (action === 'new_account_mam') {
            // there is no demo/real to choose from so set existed accounts right away
            if (Client.get('is_virtual')) {
                displayMainMessage(MetaTraderConfig.needsRealMessage());
                $action.find('#frm_action').empty();
                return;
            }
            updateAccountTypesUI('real');
        }

        // is_new_account
        displayAccountDescription(action);
        _$form = actions_info[action].$form;
        if (Object.keys(accounts_info).every(function (a_type) {
            return !accounts_info[a_type].info;
        })) {
            _$form.find('#view_1 #btn_cancel').addClass('invisible');
        }

        // Navigation buttons: cancel, next, back
        _$form.find('#btn_cancel').click(function () {
            loadAction(null, acc_type);
            displayAccountDescription(accounts_info[acc_type].info ? acc_type : 'new_account');
            $.scrollTo($('h1'), 300, { offset: -10 });
        });
        var displayStep = function displayStep(step) {
            _$form.find('#mv_new_account div[id^="view_"]').setVisibility(0);
            _$form.find('#view_' + step).setVisibility(1);
            _$form.find('#view_2').find('.error-msg, .days_to_crack').setVisibility(0);
            _$form.find('input').val('');
            _$form.find('.' + (/demo/.test(newAccountGetType()) ? 'real' : 'demo') + '-only').setVisibility(0);
        };
        _$form.find('#btn_next').click(function () {
            if (!$(this).hasClass('button-disabled')) {
                _$form.find('#view_2 button[type="submit"]').attr('acc_type', newAccountGetType());
                displayStep(2);
                var get_settings = State.getResponse('get_settings');
                if (get_settings.first_name && get_settings.last_name) {
                    _$form.find('#txt_name').val(get_settings.first_name + ' ' + get_settings.last_name);
                }
                $.scrollTo($container.find('.acc-actions'), 300, { offset: -10 });
            }
        });
        _$form.find('#btn_back').click(function () {
            displayStep(1);
        });

        // Account type selection
        _$form.find('.mt5_type_box').click(selectAccountTypeUI);
    };

    var newAccountGetType = function newAccountGetType() {
        return (_$form.find('.step-1 .selected').attr('data-acc-type') || 'real') + '_' + _$form.find('.step-2 .selected').attr('data-acc-type');
    };

    var selectAccountTypeUI = function selectAccountTypeUI(e) {
        var box_class = 'mt5_type_box';
        var $item = $(e.target);
        if (!$item.hasClass(box_class)) {
            $item = $item.parents('.' + box_class);
        }
        if (/\b(disabled|selected|existed)\b/.test($item.attr('class'))) return;
        $item.parents('.type-group').find('.' + box_class + '.selected').removeClass('selected');
        $item.addClass('selected');
        var selected_acc_type = $item.attr('data-acc-type');
        var action = 'new_account' + (/mamm/.test(selected_acc_type) ? '_mam' : '');
        if (/(demo|real)/.test(selected_acc_type)) {
            displayAccountDescription(action);
            updateAccountTypesUI(selected_acc_type);
            _$form.find('#view_1 #btn_next').addClass('button-disabled');
            _$form.find('#view_1 .step-2').setVisibility(1);
            displayMessage('#new_account_msg', selected_acc_type === 'real' && Client.get('is_virtual') ? MetaTraderConfig.needsRealMessage() : '', true);
        } else {
            var new_acc_type = newAccountGetType();
            displayAccountDescription(new_acc_type);
            actions_info[action].prerequisites(new_acc_type).then(function (error_msg) {
                displayMessage('#new_account_msg', error_msg || '');
                _$form.find('#view_1 #btn_next')[error_msg ? 'addClass' : 'removeClass']('button-disabled');
                _$form.find('#view_1 #btn_cancel').removeClass('invisible');
            });
        }
    };

    var updateAccountTypesUI = function updateAccountTypesUI(type) {
        Object.keys(accounts_info).filter(function (acc_type) {
            return acc_type.indexOf(type) === 0;
        }).forEach(function (acc_type) {
            var class_name = type === 'real' && Client.get('is_virtual') ? 'disabled' : '';
            if (accounts_info[acc_type].info) {
                class_name = 'existed';
            }
            _$form.find('.step-2 #' + acc_type.replace(type, 'rbtn')).removeClass('existed disabled selected').addClass(class_name);
        });
    };

    var populateAccountTypes = function populateAccountTypes() {
        var $acc_template = $($templates.find('#rbtn_template').parent().remove()[0]);
        var $acc_template_mt = $templates.find('#frm_new_account #view_1 .step-2 .type-group');
        var $acc_template_mam = $templates.find('#frm_new_account_mam #view_1 .step-2 .type-group');
        if (!$acc_template.length || !$acc_template_mt.length || !$acc_template_mam.length) return;

        var count = 0;
        Object.keys(accounts_info).filter(function (acc_type) {
            return !accounts_info[acc_type].is_demo;
        }).forEach(function (acc_type) {
            count++;
            var $acc = $acc_template.clone();
            var type = acc_type.split('_').slice(1).join('_');
            var title = accounts_info[acc_type].short_title;
            $acc.find('.mt5_type_box').attr({ id: 'rbtn_' + type, 'data-acc-type': type }).find('img').attr('src', urlForStatic('/images/pages/metatrader/icons/acc_' + title.toLowerCase().replace(/\s/g, '_').replace('mam_', '') + '.svg'));
            $acc.find('p').text(localize(title));
            (/mam/.test(acc_type) ? $acc_template_mam : $acc_template_mt).append($acc);
        });
        $templates.find('.hl-types-of-accounts').setVisibility(count > 1);
    };

    // -------------------
    // ----- General -----
    // -------------------
    var postValidate = function postValidate(acc_type, action) {
        var validate = actions_info[action].pre_submit;
        return validate ? validate(actions_info[action].$form, acc_type, displayFormMessage) : new Promise(function (resolve) {
            return resolve(true);
        });
    };

    var removeUrlHash = function removeUrlHash() {
        var url = location.href.split('#')[0];
        window.history.replaceState({ url: url }, document.title, url);
    };

    var hideFormMessage = function hideFormMessage(action) {
        actions_info[action].$form.find('#msg_form').html('').setVisibility(0);
    };

    var displayFormMessage = function displayFormMessage(message, action) {
        actions_info[action].$form.find('#msg_form').html(message).setVisibility(1);
    };

    var displayMainMessage = function displayMainMessage(message) {
        var should_scroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

        $main_msg.html(message).setVisibility(1);
        if (should_scroll) {
            $.scrollTo($action, 500, { offset: -80 });
        }
    };

    var displayMessage = function displayMessage(selector, message, is_centered) {
        $container.find(selector).html(message).attr('class', 'notice-msg hint ' + (is_centered ? 'center-text' : 'align-start')).setVisibility(message.length);
    };

    var displayPageError = function displayPageError(message) {
        $('#page_msg').html(message).setVisibility(1);
        $('#mt_loading').remove();
    };

    var disableButton = function disableButton(action) {
        var $btn = actions_info[action].$form.find('button');
        if ($btn.length && !$btn.find('.barspinner').length) {
            $btn.attr('disabled', 'disabled');
            var $btn_text = $('<span/>', { text: $btn.text(), class: 'invisible' });
            showLoadingImage($btn[0], 'white');
            $btn.append($btn_text);
        }
    };

    var enableButton = function enableButton(action) {
        var response = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        var $btn = actions_info[action].$form.find('button');
        if ($btn.length && $btn.find('.barspinner').length) {
            $btn.removeAttr('disabled').html($btn.find('span').text());
        }
        if (/password_reset/.test(action)) {
            // after submit is done, reset token value
            resetManagePasswordTab(action, response);
        }
    };

    var resetManagePasswordTab = function resetManagePasswordTab(action, response) {
        var has_invalid_token = getPropertyValue(response, ['error', 'code']) === 'InvalidToken';
        if (!response.error || has_invalid_token) {
            token = '';
            if (action === 'password_reset') {
                // go back to verify reset password form
                loadAction('manage_password');
                if (!response.error) {
                    displayMainMessage(localize('The [_1] password of account number [_2] has been changed.', [response.echo_req.password_type, response.echo_req.login]));
                } else if (has_invalid_token) {
                    _$form.find('#frm_verify_password_reset #token_error').setVisibility(1);
                }
            }
        }
    };

    var showHideMAM = function showHideMAM(acc_type) {
        var has_manager = getPropertyValue(accounts_info, [acc_type, 'info', 'manager_id']);
        $container.find('.has-mam').setVisibility(has_manager);
        if (!has_manager && $container.find('.acc-actions .has-mam').hasClass('selected')) {
            loadAction(defaultAction(acc_type));
        }
    };

    return {
        init: init,
        setAccountType: setAccountType,
        loadAction: loadAction,
        updateAccount: updateAccount,
        postValidate: postValidate,
        hideFormMessage: hideFormMessage,
        displayFormMessage: displayFormMessage,
        displayMainMessage: displayMainMessage,
        displayMessage: displayMessage,
        displayPageError: displayPageError,
        disableButton: disableButton,
        enableButton: enableButton,
        showHideMAM: showHideMAM,

        $form: function $form() {
            return _$form;
        },
        getToken: function getToken() {
            return token;
        }
    };
}();

module.exports = MetaTraderUI;

/***/ }),
/* 320 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var moment = __webpack_require__(9);
var BinaryPjax = __webpack_require__(12);
var Client = __webpack_require__(3);
var BinarySocket = __webpack_require__(5);
var AccountOpening = __webpack_require__(96);
var FormManager = __webpack_require__(18);
var localize = __webpack_require__(2).localize;
var isEmptyObject = __webpack_require__(1).isEmptyObject;
var State = __webpack_require__(6).State;
var toISOFormat = __webpack_require__(17).toISOFormat;

var FinancialAccOpening = function () {
    var form_id = '#financial-form';

    var onLoad = function onLoad() {
        if (Client.hasAccountType('financial') || !Client.get('residence')) {
            BinaryPjax.loadPreviousUrl();
            return;
        } else if (Client.hasAccountType('gaming')) {
            $('.security').hide();
        }

        if (AccountOpening.redirectAccount()) return;

        BinarySocket.send({ get_financial_assessment: 1 }).then(function (response) {
            if (!isEmptyObject(response.get_financial_assessment)) {
                var keys = Object.keys(response.get_financial_assessment);
                keys.forEach(function (key) {
                    var val = response.get_financial_assessment[key];
                    $('#' + key).val(val);
                });
            }
        });

        BinarySocket.wait('get_settings').then(function (response) {
            AccountOpening.populateForm(form_id, getValidations, true);
            var get_settings = response.get_settings;
            var $element = void 0,
                value = void 0;

            Object.keys(get_settings).forEach(function (key) {
                $element = $('#' + key);
                value = get_settings[key];
                if (key === 'date_of_birth') {
                    var moment_val = moment.utc(value * 1000);
                    value = moment_val.format('DD MMM, YYYY');
                    $element.attr({
                        'data-value': toISOFormat(moment_val),
                        'type': 'text'
                    });
                    $('.input-disabled').attr('disabled', 'disabled');
                }
                if (value) $element.val(value);
            });
        });

        FormManager.handleSubmit({
            form_selector: form_id,
            obj_request: { new_account_maltainvest: 1, accept_risk: 0 },
            fnc_response_handler: handleResponse
        });

        $('#tax_information_note_toggle').off('click').on('click', function (e) {
            e.stopPropagation();
            $('#tax_information_note_toggle').toggleClass('open');
            $('#tax_information_note').slideToggle();
        });

        AccountOpening.showHidePulser(0);
    };

    var getValidations = function getValidations() {
        var validations = AccountOpening.commonValidations().concat(AccountOpening.selectCheckboxValidation(form_id), [{ selector: '#tax_identification_number', validations: ['req', 'tax_id', ['length', { min: 1, max: 20 }]] }, { selector: '#chk_tax_id', validations: [['req', { hide_asterisk: true, message: localize('Please confirm that all the information above is true and complete.') }]], exclude_request: 1 }]);
        var place_of_birth = State.getResponse('get_settings.place_of_birth');
        if (place_of_birth) {
            validations = validations.concat([{ request_field: 'place_of_birth', value: place_of_birth }]);
        }
        return validations;
    };

    var handleResponse = function handleResponse(response) {
        if ('error' in response && response.error.code === 'show risk disclaimer') {
            $('#financial-form').setVisibility(0);
            var $financial_risk = $('#financial-risk');
            $financial_risk.setVisibility(1);
            $.scrollTo($financial_risk, 500, { offset: -10 });

            var risk_form_id = '#financial-risk';
            FormManager.init(risk_form_id, []);

            var echo_req = $.extend({}, response.echo_req);
            echo_req.accept_risk = 1;
            FormManager.handleSubmit({
                form_selector: risk_form_id,
                obj_request: echo_req,
                fnc_response_handler: handleResponse
            });
        } else {
            AccountOpening.handleNewAccount(response, response.msg_type);
        }
    };

    var onUnload = function onUnload() {
        AccountOpening.showHidePulser(1);
    };

    return {
        onLoad: onLoad,
        onUnload: onUnload
    };
}();

module.exports = FinancialAccOpening;

/***/ }),
/* 321 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BinaryPjax = __webpack_require__(12);
var Client = __webpack_require__(3);
var AccountOpening = __webpack_require__(96);
var FormManager = __webpack_require__(18);
var detectHedging = __webpack_require__(4).detectHedging;

var JapanAccOpening = function () {
    var onLoad = function onLoad() {
        if (AccountOpening.redirectAccount()) return;
        AccountOpening.populateForm();
        var form_id = '#japan-form';

        FormManager.init(form_id, [{ selector: '#first_name', validations: ['req', 'letter_symbol'] }, { selector: '#last_name', validations: ['req', 'letter_symbol'] }, { selector: '#date_of_birth', validations: ['req'] }, { selector: '#address_line_1', validations: ['req', 'address'] }, { selector: '#address_line_2', validations: ['address'] }, { selector: '#address_city', validations: ['req', 'letter_symbol'] }, { selector: '#address_state', validations: ['req'] }, { selector: '#address_postcode', validations: ['req', ['regular', { regex: /^\d{3}-\d{4}$/, message: 'Please follow the pattern 3 numbers, a dash, followed by 4 numbers.' }]] }, { selector: '#phone', validations: ['req', ['regular', { regex: /^\+?[0-9\s-]+$/, message: 'Only numbers, space, and hyphen are allowed.' }], ['min', { min: 6, max: 35 }]] }, { selector: '#secret_answer', validations: ['req', ['min', { min: 1, max: 50 }]] }, { selector: '#daily_loss_limit', validations: ['req', 'number'] }, { selector: '#hedge_asset_amount', validations: ['req', 'number'] }, { selector: '#motivation_circumstances', validations: ['req'] }, { request_field: 'residence', value: Client.get('residence') }, { request_field: 'new_account_japan', value: 1 }].concat(AccountOpening.selectCheckboxValidation(form_id)));

        detectHedging($('#trading_purpose'), $('.hedging-assets'));

        FormManager.handleSubmit({
            form_selector: form_id,
            fnc_response_handler: handleResponse
        });

        AccountOpening.showHidePulser(0);
    };

    var handleResponse = function handleResponse(response) {
        if ('error' in response) {
            AccountOpening.handleNewAccount(response, response.msg_type);
        } else {
            BinaryPjax.load('new_account/knowledge_testws');
        }
    };

    var onUnload = function onUnload() {
        AccountOpening.showHidePulser(1);;
    };

    return {
        onLoad: onLoad,
        onUnload: onUnload
    };
}();

module.exports = JapanAccOpening;

/***/ }),
/* 322 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BinaryPjax = __webpack_require__(12);
var Client = __webpack_require__(3);
var BinarySocket = __webpack_require__(5);
var AccountOpening = __webpack_require__(96);
var FormManager = __webpack_require__(18);
var State = __webpack_require__(6).State;

var RealAccOpening = function () {
    var form_id = '#frm_real';

    var onLoad = function onLoad() {
        if (Client.get('residence')) {
            if (AccountOpening.redirectAccount()) return;

            BinarySocket.wait('landing_company').then(function () {
                AccountOpening.populateForm(form_id, getValidations, false);

                FormManager.handleSubmit({
                    form_selector: form_id,
                    obj_request: { new_account_real: 1 },
                    fnc_response_handler: handleResponse
                });
            });
        } else {
            BinaryPjax.loadPreviousUrl();
        }
        AccountOpening.showHidePulser(0);
    };

    var getValidations = function getValidations() {
        var validations = AccountOpening.commonValidations().concat(AccountOpening.selectCheckboxValidation(form_id));
        var place_of_birth = State.getResponse('get_settings.place_of_birth');
        if (place_of_birth) {
            validations = validations.concat([{ request_field: 'place_of_birth', value: place_of_birth }]);
        }
        return validations;
    };

    var handleResponse = function handleResponse(response) {
        return AccountOpening.handleNewAccount(response, response.msg_type);
    };

    var onUnload = function onUnload() {
        AccountOpening.showHidePulser(1);
    };

    return {
        onLoad: onLoad,
        onUnload: onUnload
    };
}();

module.exports = RealAccOpening;

/***/ }),
/* 323 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var SelectMatcher = __webpack_require__(25).select2Matcher;
var Cookies = __webpack_require__(50);
var Client = __webpack_require__(3);
var BinarySocket = __webpack_require__(5);
var FormManager = __webpack_require__(18);
var TrafficSource = __webpack_require__(170);
var makeOption = __webpack_require__(4).makeOption;
var localize = __webpack_require__(2).localize;
var LocalStore = __webpack_require__(6).LocalStore;
var State = __webpack_require__(6).State;
var urlFor = __webpack_require__(8).urlFor;
var getPropertyValue = __webpack_require__(1).getPropertyValue;
var isEmptyObject = __webpack_require__(1).isEmptyObject;

var VirtualAccOpening = function () {
    var form = '#virtual-form';

    var onLoad = function onLoad() {
        if (Client.isJPClient()) {
            return;
        }

        BinarySocket.send({ residence_list: 1 }).then(function (response) {
            return handleResidenceList(response.residence_list);
        });

        bindValidation();
        FormManager.handleSubmit({
            form_selector: form,
            fnc_response_handler: handleNewAccount
        });
    };

    var handleResidenceList = function handleResidenceList(residence_list) {
        var $residence = $('#residence');
        if (residence_list.length > 0) {
            var $options_with_disabled = $('<div/>');
            residence_list.forEach(function (res) {
                $options_with_disabled.append(makeOption({
                    text: res.text,
                    value: res.value,
                    is_disabled: res.disabled
                }));
            });
            $residence.html($options_with_disabled.html());

            BinarySocket.wait('website_status').then(function (response) {
                return handleWebsiteStatus(response.website_status, $residence);
            });
        } else {
            $residence.setVisibility(1);
        }
    };

    var handleWebsiteStatus = function handleWebsiteStatus() {
        var website_status = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var $residence = arguments[1];

        if (!website_status || isEmptyObject(website_status)) return;
        var clients_country = website_status.clients_country;

        // set residence value to client's country, detected by IP address from API
        var $clients_country = $residence.find('option[value="' + clients_country + '"]');
        if (!$clients_country.attr('disabled')) {
            $clients_country.prop('selected', true);
        }
        $residence.select2({
            matcher: function matcher(params, data) {
                return SelectMatcher(params, data);
            }
        }).setVisibility(1);
    };

    var bindValidation = function bindValidation() {
        // Add TrafficSource parameters
        var utm_data = TrafficSource.getData();

        var req = [{ selector: '#client_password', validations: ['req', 'password'], re_check_field: '#repeat_password' }, { selector: '#repeat_password', validations: ['req', ['compare', { to: '#client_password' }]], exclude_request: 1 }, { selector: '#residence' }, { selector: '#email_consent' }, { request_field: 'utm_source', value: TrafficSource.getSource(utm_data) }, { request_field: 'new_account_virtual', value: 1 }];

        if (utm_data.utm_medium) req.push({ request_field: 'utm_medium', value: utm_data.utm_medium });
        if (utm_data.utm_campaign) req.push({ request_field: 'utm_campaign', value: utm_data.utm_campaign });

        var gclid = LocalStore.get('gclid');
        if (gclid) req.push({ request_field: 'gclid_url', value: gclid });

        if (Cookies.get('affiliate_tracking')) req.push({ request_field: 'affiliate_token', value: Cookies.getJSON('affiliate_tracking').t });

        FormManager.init(form, req, true);
    };

    var handleNewAccount = function handleNewAccount(response) {
        if (!response) return false;
        var error = response.error;
        if (!error) {
            var new_account = response.new_account_virtual;
            var residence = response.echo_req.residence;
            Client.set('residence', residence, new_account.client_id);
            LocalStore.remove('gclid');
            State.set('skip_response', 'authorize');
            BinarySocket.send({ authorize: new_account.oauth_token }, { forced: true }).then(function (response_auth) {
                if (!response_auth.error) {
                    Client.processNewAccount({
                        email: new_account.email,
                        loginid: new_account.client_id,
                        token: new_account.oauth_token,
                        is_virtual: true,
                        redirect_url: urlFor('new_account/welcome')
                    });
                }
            });
            return true;
        }

        var showInvalidTokenMessage = function showInvalidTokenMessage() {
            var message = 'Your token has expired or is invalid. Please click <a href="[_1]">here</a> to restart the verification process.';
            return showFormError(message, '');
        };

        switch (error.code) {
            case 'InputValidationFailed':
                {
                    return getPropertyValue(response, ['error', 'details', 'verification_code']) ? showInvalidTokenMessage() : showError(error.message);
                }
            case 'InvalidToken':
                {
                    return showInvalidTokenMessage();
                }
            case 'duplicate email':
                {
                    var message = 'The email address provided is already in use. If you forgot your password, please try our <a href="[_1]">password recovery tool</a> or contact our customer service.';
                    return showFormError(message, 'user/lost_passwordws');
                }
            case 'PasswordError':
                {
                    return showError('Password is not strong enough.');
                }
            default:
                {
                    return showError(error.message);
                }
        }
    };

    var showFormError = function showFormError(message, url) {
        $('#virtual-form').html($('<p/>', { html: localize(message, [urlFor(url)]) }));
    };

    var showError = function showError(message) {
        $('#error-account-opening').setVisibility(1).text(localize(message));
    };

    return {
        onLoad: onLoad
    };
}();

module.exports = VirtualAccOpening;

/***/ }),
/* 324 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BinarySocket = __webpack_require__(5);
var Client = __webpack_require__(3);
var localize = __webpack_require__(2).localize;
var State = __webpack_require__(6).State;
var createElement = __webpack_require__(1).createElement;
var getElementById = __webpack_require__(4).getElementById;
var toTitleCase = __webpack_require__(17).toTitleCase;
var Url = __webpack_require__(8);

var WelcomePage = function () {
    var onLoad = function onLoad() {

        BinarySocket.wait('authorize', 'landing_company', 'get_settings').then(function () {
            if (Client.hasAccountType('real')) {
                Url.defaultRedirectUrl();
            }

            var landing_company = State.getResponse('landing_company');
            var jp_account_status = State.getResponse('get_settings.jp_account_status.status');
            var upgrade_btn = getElementById('upgrade_btn');
            var upgrade_info = Client.getUpgradeInfo(landing_company, jp_account_status);
            var show_welcome_msg = upgrade_info.can_upgrade;

            var setButtonLink = function setButtonLink(url, msg) {
                if (upgrade_btn) {
                    upgrade_btn.html(createElement('span', { text: localize(msg) })).setAttribute('href', Url.urlFor(url));
                    upgrade_btn.classList.remove('button-disabled');
                }
            };

            var welcome_msg = getElementById('welcome_container');

            if (welcome_msg) {
                var upgrade_title_el = getElementById('upgrade_title');
                upgrade_title_el.html(localize(toTitleCase(upgrade_info.type) + ' Account'));
                welcome_msg.setVisibility(1);
            }

            if (show_welcome_msg) {
                setButtonLink(upgrade_info.upgrade_link, 'Upgrade now');
            }
        });
    };

    return {
        onLoad: onLoad
    };
}();

module.exports = WelcomePage;

/***/ }),
/* 325 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var RealityCheckData = __webpack_require__(130);
var RealityCheckUI = __webpack_require__(326);
var Client = __webpack_require__(3);
var BinarySocket = __webpack_require__(5);

var RealityCheck = function () {
    var storageHandler = function storageHandler(ev) {
        var key = ev.key;
        var new_value = ev.newValue;
        if (key === 'reality_check.ack' && +new_value === 1 || key === 'reality_check.keep_open' && +new_value === 0) {
            RealityCheckUI.closePopUp();
        }
    };

    var onLoad = function onLoad() {
        if (RealityCheckUI.shouldShowPopup()) {
            BinarySocket.wait('landing_company').then(function () {
                if ((Client.currentLandingCompany() || {}).has_reality_check) {
                    window.addEventListener('storage', storageHandler, false);

                    RealityCheckData.resetInvalid();

                    if (!RealityCheckData.get('ack')) {
                        RealityCheckUI.renderFrequencyPopUp();
                    } else if (RealityCheckData.get('keep_open')) {
                        RealityCheckUI.getSummaryAsync();
                    } else {
                        RealityCheckUI.startSummaryTimer();
                    }
                } else {
                    clearTimeout(RealityCheckUI.getRealityTimeout());
                }
            });
        }
    };

    return {
        onLoad: onLoad
    };
}();

module.exports = RealityCheck;

/***/ }),
/* 326 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var RealityCheckData = __webpack_require__(130);
var showLocalTimeOnHover = __webpack_require__(26).showLocalTimeOnHover;
var BinarySocket = __webpack_require__(5);
var FormManager = __webpack_require__(18);
var urlFor = __webpack_require__(8).urlFor;
__webpack_require__(163);
__webpack_require__(164);

var RealityCheckUI = function () {
    var summary_url = urlFor('user/reality_check_summary');
    var frequency_url = urlFor('user/reality_check_frequency');
    var form = {
        selector: '#frm_reality_check',
        num_reality_duration: '#num_reality_duration'
    };

    var reality_timeout = void 0;

    var getAjax = function getAjax(summary) {
        $.ajax({
            url: summary ? summary_url : frequency_url,
            dataType: 'html',
            method: 'GET',
            success: function success(reality_check_text) {
                ajaxSuccess(reality_check_text, summary);
            }
        });
    };

    var ajaxSuccess = function ajaxSuccess(reality_check_text, summary) {
        var content = 'reality_check_content';
        if (reality_check_text.includes(content) && $('#reality_check').length === 0) {
            $('body').append($('<div/>', { id: 'reality_check', class: 'lightbox' }).append($(reality_check_text).find('#' + content)));
            $(form.num_reality_duration).val(Math.floor(+RealityCheckData.get('interval') / 60 / 1000));
            $('#statement').off('click').on('click dblclick', onStatementClick);
            $('#logout').off('click').on('click dblclick', onLogoutClick);
            if (summary) {
                updateSummary(summary);
            }
            bindValidation();
        }
    };

    var updateSummary = function updateSummary(summary) {
        $('#start_time').text(summary.start_time_string);
        $('#login_time').text(summary.login_time);
        $('#current_time').text(summary.current_time);
        $('#session_duration').text(summary.session_duration);

        $('#loginid').text(summary.loginid);
        $('#rc_currency').text(summary.currency);
        $('#turnover').html(summary.turnover);
        $('#profit_loss').html(summary.profit_loss);
        $('#bought').text(summary.contracts_bought);
        $('#sold').text(summary.contracts_sold);
        $('#open').text(summary.open_contracts);
        $('#potential').html(summary.potential_profit);

        showLocalTimeOnHover('#start_time, #login_time, #current_time');
    };

    var handleKeypress = function handleKeypress(ev) {
        var char = String.fromCharCode(ev.which);
        if (!/[0-9]/.test(char) && [8, 37, 39].indexOf(ev.keyCode) < 0 || /['%]/.test(char)) {
            // similarity to arrows key code in some browsers
            ev.preventDefault();
        }
    };

    var bindValidation = function bindValidation() {
        $(form.num_reality_duration).off('keypress').on('keypress', handleKeypress);
        FormManager.init(form.selector, [{ selector: form.num_reality_duration, validations: ['req', ['number', { min: 10, max: 60 }]], exclude_request: 1, no_scroll: 1 }]);
        FormManager.handleSubmit({
            form_selector: form.selector,
            fnc_response_handler: responseHandler
        });
    };

    var responseHandler = function responseHandler() {
        var interval_minute = +$(form.num_reality_duration).val();
        RealityCheckData.set('interval', interval_minute * 60 * 1000);
        RealityCheckData.set('keep_open', 0);
        RealityCheckData.set('ack', 1);
        closePopUp();
    };

    var onStatementClick = function onStatementClick() {
        var win = window.open(urlFor('user/statementws') + '#no-reality-check', '_blank');
        if (win) {
            win.focus();
        }
    };

    var onLogoutClick = function onLogoutClick() {
        BinarySocket.send({ logout: '1' });
    };

    var closePopUp = function closePopUp() {
        $('#reality_check').remove();
        startSummaryTimer();
    };

    var startSummaryTimer = function startSummaryTimer() {
        var interval = +RealityCheckData.get('interval');

        clearTimeout(reality_timeout);
        reality_timeout = setTimeout(function () {
            RealityCheckData.set('keep_open', 1);
            getSummaryAsync();
        }, interval);
    };

    var shouldShowPopup = function shouldShowPopup() {
        var location = window.location;
        return !(/no-reality-check/.test(location.hash) && /statementws/.test(location.pathname));
    };

    var getSummaryAsync = function getSummaryAsync() {
        if (RealityCheckUI.shouldShowPopup()) {
            BinarySocket.send({ reality_check: 1 }).then(function (response) {
                getAjax(RealityCheckData.summaryData(response.reality_check));
            });
        }
    };

    return {
        closePopUp: closePopUp,
        startSummaryTimer: startSummaryTimer,
        getSummaryAsync: getSummaryAsync,
        shouldShowPopup: shouldShowPopup,

        renderFrequencyPopUp: function renderFrequencyPopUp() {
            getAjax();
        },
        getRealityTimeout: function getRealityTimeout() {
            return reality_timeout;
        }
    };
}();

module.exports = RealityCheckUI;

/***/ }),
/* 327 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var generateBirthDate = __webpack_require__(166);
var FormManager = __webpack_require__(18);
var Login = __webpack_require__(55);
var localize = __webpack_require__(2).localize;

var ResetPassword = function () {
    var responseHandler = function responseHandler(response) {
        $('#container_reset_password').setVisibility(0);
        if (response.error) {
            var $form_error = $('#form_error');
            var reset_error_template = '[_1] Please click the link below to restart the password recovery process.';
            var error_code = response.error.code;

            $('#msg_reset_password').setVisibility(0);

            var err_msg = void 0;
            if (error_code === 'SocialBased') {
                err_msg = localize(response.error.message);
                $form_error.find('a').setVisibility(0);
            } else {
                // special handling as backend return inconsistent format
                err_msg = localize(reset_error_template, [error_code === 'InputValidationFailed' ? localize('There was some invalid character in an input field.') : localize(response.error.message)]);
            }

            $('#form_error_msg').text(err_msg);
            $form_error.setVisibility(1);
        } else {
            $('#msg_reset_password').text(localize('Your password has been successfully reset. Please log into your account using your new password.')).setVisibility(1);
            setTimeout(function () {
                Login.redirectToLogin();
            }, 5000);
        }
    };

    var onLoad = function onLoad() {
        generateBirthDate();

        $('#have_real_account').off('click').on('click', function () {
            if ($(this).is(':checked')) {
                $('#dob_field').setVisibility(1);
            } else {
                $('#dob_field').setVisibility(0);
            }
        });

        var form_id = '#frm_reset_password';
        FormManager.init(form_id, [{ selector: '#new_password', validations: ['req', 'password'], re_check_field: '#repeat_password' }, { selector: '#repeat_password', validations: ['req', ['compare', { to: '#new_password' }]], exclude_request: 1 }, { selector: '#date_of_birth', validations: ['req'] }, { request_field: 'reset_password', value: 1 }], true);

        FormManager.handleSubmit({
            form_selector: form_id,
            fnc_response_handler: responseHandler
        });
    };

    return {
        onLoad: onLoad
    };
}();

module.exports = ResetPassword;

/***/ }),
/* 328 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BinaryPjax = __webpack_require__(12);
var Client = __webpack_require__(3);
var Header = __webpack_require__(27);
var BinarySocket = __webpack_require__(5);
var getCurrencyName = __webpack_require__(7).getCurrencyName;
var isCryptocurrency = __webpack_require__(7).isCryptocurrency;
var localize = __webpack_require__(2).localize;
var State = __webpack_require__(6).State;
var Url = __webpack_require__(8);

var SetCurrency = function () {
    var is_new_account = void 0;

    var onLoad = function onLoad() {
        is_new_account = localStorage.getItem('is_new_account');
        var el = is_new_account ? 'show' : 'hide';
        $('#' + el + '_new_account').setVisibility(1);

        var _Client$getUpgradeInf = Client.getUpgradeInfo(),
            can_upgrade = _Client$getUpgradeInf.can_upgrade,
            type = _Client$getUpgradeInf.type;

        $('#upgrade_to_mf').setVisibility(can_upgrade && type === 'financial');

        if (Client.get('currency')) {
            if (is_new_account) {
                $('#set_currency_loading').remove();
                $('.has_currency, #set_currency').setVisibility(1);
            } else {
                BinaryPjax.loadPreviousUrl();
            }
            return;
        }

        BinarySocket.wait('payout_currencies').then(function (response) {
            var payout_currencies = response.payout_currencies;
            var $fiat_currencies = $('<div/>');
            var $cryptocurrencies = $('<div/>');
            payout_currencies.forEach(function (c) {
                (isCryptocurrency(c) ? $cryptocurrencies : $fiat_currencies).append($('<div/>', { class: 'gr-2 gr-3-m currency_wrapper', id: c }).append($('<div/>').append($('<img/>', { src: Url.urlForStatic('images/pages/set_currency/' + c.toLowerCase() + '.svg') }))).append($('<div/>', { class: 'currency-name', html: isCryptocurrency(c) ? getCurrencyName(c) + '<br />(' + c + ')' : c })));
            });
            var fiat_currencies = $fiat_currencies.html();
            if (fiat_currencies) {
                $('#fiat_currencies').setVisibility(1);
                $('#fiat_currency_list').html(fiat_currencies);
            }
            var crytpo_currencies = $cryptocurrencies.html();
            if (crytpo_currencies) {
                $('#crypto_currencies').setVisibility(1);
                $('#crypto_currency_list').html(crytpo_currencies);
            }

            $('#set_currency_loading').remove();
            $('#set_currency, .select_currency').setVisibility(1);

            var $currency_list = $('.currency_list');
            $('.currency_wrapper').on('click', function () {
                $currency_list.find('> div').removeClass('selected');
                $(this).addClass('selected');
            });

            var $form = $('#frm_set_currency');
            var $error = $form.find('.error-msg');
            $form.on('submit', function (evt) {
                evt.preventDefault();
                $error.setVisibility(0);
                var $selected_currency = $currency_list.find('.selected');
                if ($selected_currency.length) {
                    BinarySocket.send({ set_account_currency: $selected_currency.attr('id') }).then(function (response_c) {
                        if (response_c.error) {
                            $error.text(response_c.error.message).setVisibility(1);
                        } else {
                            localStorage.removeItem('is_new_account');
                            Client.set('currency', response_c.echo_req.set_account_currency);
                            BinarySocket.send({ balance: 1 });
                            BinarySocket.send({ payout_currencies: 1 }, { forced: true });
                            Header.displayAccountStatus();

                            var redirect_url = void 0;
                            if (is_new_account) {
                                if (Client.isAccountOfType('financial')) {
                                    var get_account_status = State.getResponse('get_account_status');
                                    if (!/authenticated/.test(get_account_status.status)) {
                                        redirect_url = Url.urlFor('user/authenticate');
                                    }
                                }
                                // Do not redirect MX clients to cashier, because they need to set max limit before making deposit
                                if (!redirect_url && !/^(iom)$/i.test(Client.get('landing_company_shortcode'))) {
                                    redirect_url = Url.urlFor('cashier');
                                }
                            } else {
                                redirect_url = BinaryPjax.getPreviousUrl();
                            }

                            if (redirect_url) {
                                window.location.href = redirect_url; // load without pjax
                            } else {
                                Header.populateAccountsList(); // update account title
                                $('.select_currency').setVisibility(0);
                                $('.has_currency').setVisibility(1);
                            }
                        }
                    });
                } else {
                    $error.text(localize('Please choose a currency')).setVisibility(1);
                }
            });
        });
    };

    return {
        onLoad: onLoad
    };
}();

module.exports = SetCurrency;

/***/ }),
/* 329 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var FormManager = __webpack_require__(18);

var TelegramBot = function () {
    var form = '#frm_telegram_bot';

    var onLoad = function onLoad() {
        var bot_name = 'binary_test_bot';

        FormManager.init(form, [{ selector: '#token', validations: ['req'], exclude_request: 1 }]);

        FormManager.handleSubmit({
            form_selector: form,
            fnc_response_handler: function fnc_response_handler() {
                var token = $('#token').val();
                var url = 'https://t.me/' + bot_name + '/?start=' + token;
                window.location.assign(url);
            }
        });
    };

    var onUnload = function onUnload() {
        $(form).off('submit');
    };

    return {
        onLoad: onLoad,
        onUnload: onUnload
    };
}();

module.exports = TelegramBot;

/***/ }),
/* 330 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var PortfolioInit = __webpack_require__(128);
var updateContractBalance = __webpack_require__(127).updateContractBalance;
var Client = __webpack_require__(3);
var BinarySocket = __webpack_require__(5);
var formatMoney = __webpack_require__(7).formatMoney;
var getPropertyValue = __webpack_require__(1).getPropertyValue;

var updateBalance = function updateBalance(response) {
    if (getPropertyValue(response, 'error')) {
        return;
    }
    BinarySocket.wait('website_status').then(function () {
        var balance = response.balance.balance;
        Client.set('balance', balance);
        PortfolioInit.updateBalance();
        var currency = response.balance.currency;
        if (!currency) {
            return;
        }
        var view = formatMoney(currency, balance);
        updateContractBalance(balance);
        $('.topMenuBalance, .binary-balance').html(view).css('visibility', 'visible');
    });
};

module.exports = updateBalance;

/***/ }),
/* 331 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BinaryPjax = __webpack_require__(12);
var Client = __webpack_require__(3);
var BinarySocket = __webpack_require__(5);
var localize = __webpack_require__(2).localize;

var VideoFacility = function () {
    var onLoad = function onLoad() {
        if (!Client.isAccountOfType('financial')) {
            $('#loading').replaceWith($('<p/>', { class: 'notice-msg center-text', text: localize('Sorry, this feature is not available in your jurisdiction.') }));
            return;
        }

        BinarySocket.send({ get_account_status: 1 }).then(function (response) {
            if (response.error) {
                $('#error_message').setVisibility(1).text(response.error.message);
            } else {
                var should_authenticate = +response.get_account_status.prompt_client_to_authenticate;
                if (should_authenticate) {
                    $('#loading').remove();
                    if (!Client.isAccountOfType('financial')) {
                        $('#not_authenticated').setVisibility(1);
                    }
                    $('.msg_authenticate').setVisibility(1);
                    $('#generated_token').text(Client.get('token').slice(-4)).parent().setVisibility(1);
                } else {
                    BinaryPjax.loadPreviousUrl();
                }
            }
        });
    };

    return {
        onLoad: onLoad
    };
}();

module.exports = VideoFacility;

/***/ }),
/* 332 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


window.$ = window.jQuery = __webpack_require__(72);

__webpack_require__(236);
__webpack_require__(239);
__webpack_require__(234);

__webpack_require__(25);
__webpack_require__(230);

// used by gtm to update page after a new release
window.check_new_release = __webpack_require__(231).checkNewRelease;

__webpack_require__(237);
__webpack_require__(232);
__webpack_require__(233);
__webpack_require__(238);

var BinaryLoader = __webpack_require__(235);

document.addEventListener('DOMContentLoaded', BinaryLoader.init);
$(window).on('pageshow', function (e) {
    // Safari doesn't fire load event when using back button
    if (e.originalEvent.persisted) {
        BinaryLoader.init();
    }
});

/***/ }),
/* 333 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Client = __webpack_require__(3);

var GetStartedJP = function () {
    var $contents = void 0,
        $sidebar_li = void 0,
        $index = void 0;

    var showSelectedTab = function showSelectedTab() {
        var updated_tab = window.location.hash;
        $contents.find('div').hide();
        $sidebar_li.removeClass('selected');
        if (updated_tab) {
            $index.hide();
            $contents.find('div[id=content-' + updated_tab.slice(1, updated_tab.length) + ']').show().find('div').show();
            $sidebar_li.filter('.' + updated_tab.slice(1, updated_tab.length)).addClass('selected');
            $contents.show();
        } else {
            $contents.hide();
            $index.show();
        }
    };

    var onLoad = function onLoad() {
        Client.activateByClientType();
        $contents = $('.contents');
        $sidebar_li = $('.sidebar ul li');
        $index = $('#index');

        var tab = window.location.hash;
        if (tab && tab !== '') {
            $index.hide();
            $('.sidebar ul li.' + tab.slice(1, tab.length)).addClass('selected');
            showSelectedTab();
        }

        $(window).on('hashchange', function () {
            showSelectedTab();
        });

        $sidebar_li.click(function () {
            $('.sidebar ul li').removeClass('selected');
            $(this).addClass('selected');
        });
    };

    var onUnload = function onUnload() {
        $(window).off('hashchange');
    };

    return {
        onLoad: onLoad,
        onUnload: onUnload
    };
}();

module.exports = GetStartedJP;

/***/ }),
/* 334 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Home = __webpack_require__(185);

var HomeJP = function () {
    var visible_product = 'product_visible';
    var product_prefix = 'product_';

    var margin = void 0,
        $go_right = void 0,
        $go_left = void 0,
        number_of_products = void 0,
        $first_product = void 0,
        slide_timeout = void 0;

    var onLoad = function onLoad() {
        Home.onLoad();

        margin = 0;
        $go_right = $('.go-right');
        $go_left = $('.go-left');
        number_of_products = $('.product').length;
        $first_product = $('.product:eq(0)');

        $go_right.on('click', function () {
            slide(this, 'right');
        });
        $go_left.on('click', function () {
            slide(this, 'left');
        });

        $('#product_wrapper').on('mouseenter', function () {
            clearTimeout(slide_timeout);
        }).on('mouseleave', function () {
            setTimeoutOnSlide();
        });

        setTimeoutOnSlide();
    };

    var setTimeoutOnSlide = function setTimeoutOnSlide() {
        clearTimeout(slide_timeout);
        slide_timeout = setTimeout(function () {
            slide(undefined, 'right');
            setTimeoutOnSlide();
        }, 10000);
    };

    var slide = function slide(element, direction) {
        if ($(element).hasClass('disabled')) {
            return;
        }
        var window_width = $(window).width();
        var width = 800;
        if (window_width <= 959) {
            width = window_width <= 480 ? 203 : 603;
        }

        // get current visible element
        var id_no_current = Number($('.product_visible').attr('id').split(product_prefix)[1]);
        var id_no_to_show = direction === 'right' ? id_no_current + 1 : id_no_current - 1;

        if (id_no_to_show > number_of_products) {
            id_no_to_show = 1;
            margin = 0;
        } else {
            margin += width * (direction === 'right' ? -1 : 1);
        }

        changeProductVisibility(id_no_current, id_no_to_show);
        hideShowIcons(id_no_to_show);
        $first_product.animate({ 'margin-left': margin + 'px' }, 500);
    };

    var changeProductVisibility = function changeProductVisibility(element, element_to_show) {
        $('#' + product_prefix + element).removeClass(visible_product);
        $('#' + product_prefix + element_to_show).addClass(visible_product);
    };

    var hideShowIcons = function hideShowIcons(id_no_to_show) {
        changeIconVisibility($go_left, id_no_to_show === 1);
        changeIconVisibility($go_right, id_no_to_show === number_of_products);
    };

    var changeIconVisibility = function changeIconVisibility($element, should_disable) {
        var src = $element.attr('src');
        var replacement = ['enabled', 'disabled'];
        $element[(should_disable ? 'add' : 'remove') + 'Class']('disabled').attr('src', src.replace(replacement[+!should_disable], replacement[+should_disable]));
    };

    var onUnload = function onUnload() {
        clearTimeout(slide_timeout);
    };

    return {
        onLoad: onLoad,
        onUnload: onUnload
    };
}();

module.exports = HomeJP;

/***/ }),
/* 335 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Charity = function () {
    var interval = null;

    var onLoad = function onLoad() {
        var $gallery = $('.gallery');

        var images = void 0;
        var switchPicture = function switchPicture() {
            images = $gallery.find('img');
            if (images.length > 1) {
                images.eq(images.length - 1).prependTo($gallery);
            }
        };

        interval = setInterval(switchPicture, 5000);
    };

    var onUnload = function onUnload() {
        if (interval) {
            clearInterval(interval);
            interval = null;
        }
    };

    return {
        onLoad: onLoad,
        onUnload: onUnload
    };
}();

module.exports = Charity;

/***/ }),
/* 336 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var moment = __webpack_require__(9);
var Dropdown = __webpack_require__(25).selectDropdown;
var BinarySocket = __webpack_require__(86);

var Contact = function () {
    var $chat_button = void 0,
        $chat_unavailable = void 0,
        livechat_timeout = void 0;

    var onLoad = function onLoad() {
        $chat_button = $('#chat_button');
        $chat_unavailable = $('#live_chat_unavailable');
        showHideLiveChat();

        Dropdown('#cs_telephone_number');
        $('#cs_telephone_number').on('change.cs', function () {
            var val = $(this).val().split(',');
            $('#display_cs_telephone').html(val[0] + (val.length > 1 ? '<br />' + val[1] : ''));
        });
    };

    var isWeekday = function isWeekday(moment_obj) {
        return !/^(0|6)$/.test(moment_obj.day());
    }; // 0 for sunday and 6 for saturday

    var availability = [[8, 17], // weekends (sat-sun): 08-17 MYT
    [6, 21]];

    var showHideLiveChat = function showHideLiveChat() {
        BinarySocket.wait('time').then(function () {
            var moment_now = moment.utc(window.time || undefined).utcOffset(8); // MYT
            var hour = moment_now.hour();
            var config = availability[+isWeekday(moment_now)];
            var is_available = hour >= config[0] && hour < config[1];
            var moment_next = moment_now.clone();

            var next_hour = void 0;
            if (is_available) {
                $chat_button.attr({ href: 'https://binary.desk.com/customer/widget/chats/new', target: '_blank' }).removeClass('button-disabled');
                $chat_unavailable.setVisibility(0);
                next_hour = config[1];
            } else {
                $chat_button.attr({ href: '', target: '' }).addClass('button-disabled');
                $chat_unavailable.setVisibility(1);
                if (hour < config[0]) {
                    next_hour = config[0];
                } else {
                    moment_next.add(1, 'days');
                    next_hour = availability[+isWeekday(moment_next)][0];
                }
            }
            moment_next.hour(next_hour).minute(0).second(0);

            livechat_timeout = setTimeout(showHideLiveChat, moment_next.diff(moment_now));
        });
    };

    var onUnload = function onUnload() {
        clearTimeout(livechat_timeout);
    };

    return {
        onLoad: onLoad,
        onUnload: onUnload
    };
}();

module.exports = Contact;

/***/ }),
/* 337 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var MenuSelector = __webpack_require__(165);

module.exports = {
    BinaryOptions: {
        onLoad: function onLoad() {
            MenuSelector.init(['what-are-binary-options', 'how-to-trade-binary', 'types-of-trades', 'range-of-markets', 'glossary']);
        },
        onUnload: function onUnload() {
            MenuSelector.clean();
        }
    },
    CFDs: {
        onLoad: function onLoad() {
            MenuSelector.init(['what-cfds-trading', 'how-trade-cfds', 'margin-policy', 'contract-specification']);
        },
        onUnload: function onUnload() {
            MenuSelector.clean();
        }
    },
    Cryptocurrencies: {
        onLoad: function onLoad() {
            MenuSelector.init(['what-crypto-trading', 'how-trade-crypto', 'margin-policy', 'contract-specification']);
        },
        onUnload: function onUnload() {
            MenuSelector.clean();
        }
    },
    Metals: {
        onLoad: function onLoad() {
            MenuSelector.init(['what-metals-trading', 'how-trade-metals', 'margin-policy', 'contract-specification']);
        },
        onUnload: function onUnload() {
            MenuSelector.clean();
        }
    },
    Forex: {
        onLoad: function onLoad() {
            MenuSelector.init(['what-forex-trading', 'how-to-trade-forex', 'margin-policy', 'contract-specification']);
        },
        onUnload: function onUnload() {
            MenuSelector.clean();
        }
    }
};

/***/ }),
/* 338 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var urlParam = __webpack_require__(8).param;
var urlFor = __webpack_require__(8).urlFor;

var JobDetails = function () {
    var dept = void 0,
        dept_class = void 0,
        $sections_div = void 0,
        $senior_perl_message = void 0,
        $sidebar = void 0,
        $sidebar_dept = void 0;

    var showSelectedDiv = function showSelectedDiv() {
        var section = window.location.hash;
        $sections_div.setVisibility(0).filter(section).setVisibility(1);
        if (dept === 'Information_Technology' && /senior_perl_developer/.test(section)) {
            $senior_perl_message.setVisibility(1);
        } else {
            $senior_perl_message.setVisibility(0);
        }
    };

    var onLoad = function onLoad() {
        dept = urlParam('dept');
        dept_class = '.' + dept;
        $sidebar = $('.sidebar');
        $sidebar_dept = $sidebar.filter(dept_class);
        $sections_div = $('.sections > div > div');
        $senior_perl_message = $('.senior_perl_message');
        // hide all first (to handle pjaxload)
        $sidebar.setVisibility(0);
        $('#title').find('h1').setVisibility(0);
        $('#image').find('img').setVisibility(0);
        // show section
        $(dept_class).setVisibility(1);
        $sidebar_dept.setVisibility(1).find('a[href="' + window.location.hash + '"]').parent('li').addClass('selected');
        showSelectedDiv();
        $('#back-button').attr('href', urlFor('open-positions') + '#' + dept);
        addEventListeners();
    };

    var addEventListeners = function addEventListeners() {
        var $sidebar_list_item = $sidebar_dept.find('#sidebar-nav li');
        $sidebar_list_item.click(function () {
            $sidebar_list_item.removeClass('selected');
            $(this).addClass('selected');
        });

        $(window).on('hashchange', function () {
            showSelectedDiv();
        });
    };

    var onUnload = function onUnload() {
        $(window).off('hashchange');
    };

    return {
        onLoad: onLoad,
        onUnload: onUnload
    };
}();

module.exports = JobDetails;

/***/ }),
/* 339 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var getElementById = __webpack_require__(4).getElementById;
var urlFor = __webpack_require__(8).urlFor;
var Client = __webpack_require__(3);
var BinarySocket = __webpack_require__(5);

var Regulation = function () {
    var onLoad = function onLoad() {
        $(function () {
            var $accordion = $('#accordion');
            var hash = window.location.hash;
            var $element = hash ? $accordion.find(hash) : undefined;

            $accordion.accordion({
                heightStyle: 'content',
                collapsible: true,
                active: $element && $element.length && $element.index('h3') !== -1 ? $element.index('h3') : 0
            });

            if ($element && $element.length) {
                $.scrollTo($element, 500);
            }

            $accordion.on('accordionactivate', function () {
                // if EU passport rights tab is active, call relocateLinks to initialize map coordinates
                if (!$accordion.accordion('option', 'active')) {
                    relocateLinks();
                }
            });
        });

        var coords = [];
        var $map_area = $('#planetmap').find('area');
        var $selector = $('img[usemap="#planetmap"]');
        $map_area.each(function () {
            coords.push($(this).attr('coords'));
        });
        var relocateLinks = function relocateLinks() {
            $map_area.each(function (index) {
                var c = '';
                var new_width = $selector[0].getBoundingClientRect().width.toFixed(2);
                coords[index].split(',').map(function (v) {
                    c += (c ? ',' : '') + (v * new_width / 900).toFixed(2);
                });

                $(this).attr('coords', c);
            });
        };
        $(document).ready(relocateLinks);
        $(window).resize(relocateLinks);

        getElementById('visit_japan').addEventListener('click', function () {
            var redirect_to = urlFor('home-jp', '', 'ja');
            if (Client.isLoggedIn()) {
                BinarySocket.send({ logout: '1', passthrough: { redirect_to: redirect_to } });
            } else {
                window.location.href = redirect_to;
            }
        });
    };

    return {
        onLoad: onLoad
    };
}();

module.exports = Regulation;

/***/ }),
/* 340 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var tabListener = __webpack_require__(25).tabListener;
var MenuSelector = __webpack_require__(165);
var Scroll = __webpack_require__(94);
var handleHash = __webpack_require__(1).handleHash;
var BinaryPjax = __webpack_require__(12);
var Client = __webpack_require__(3);
var Header = __webpack_require__(27);

module.exports = {
    OpenPositions: {
        onLoad: function onLoad() {
            Scroll.scrollToHashSection();
        }
    },
    Careers: {
        onLoad: function onLoad() {
            tabListener();handleHash();$('.has-tabs').tabs();
        }
    },
    OpenSourceProjects: {
        onLoad: function onLoad() {
            Scroll.sidebarScroll($('.open-source-projects'));
        },
        onUnload: function onUnload() {
            Scroll.offScroll();
        }
    },
    PaymentAgent: {
        onLoad: function onLoad() {
            Scroll.sidebarScroll($('.payment-agent'));
        },
        onUnload: function onUnload() {
            Scroll.offScroll();
        }
    },
    handleTab: {
        onLoad: function onLoad() {
            tabListener();handleHash();
        }
    },
    TypesOfAccounts: {
        onLoad: function onLoad() {
            Scroll.goToHashSection();return false;
        }
    },
    LandingPage: {
        onLoad: function onLoad() {
            if (Client.hasAccountType('real')) {
                BinaryPjax.loadPreviousUrl();
            } else {
                Header.upgradeMessageVisibility();
            }
        }
    },
    AffiliatesFAQ: {
        onLoad: function onLoad() {
            MenuSelector.init(['general', 'account-management-and-tracking', 'marketing-and-promotions', 'support']);
        },
        onUnload: function onUnload() {
            MenuSelector.clean();
        }
    },
    IBProgrammeFAQ: {
        onLoad: function onLoad() {
            MenuSelector.init(['general', 'account-management', 'marketing-and-promotions']);
        },
        onUnload: function onUnload() {
            MenuSelector.clean();
        }
    }
};

/***/ }),
/* 341 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var tabListener = __webpack_require__(25).tabListener;
var localize = __webpack_require__(2).localize;
var TNCApproval = __webpack_require__(183);

var TermsAndConditions = function () {
    var sidebar_width = void 0;

    var onLoad = function onLoad() {
        var container = document.getElementsByClassName('sidebar-collapsible-container')[0];
        if (container) sidebar_width = container.offsetWidth;

        handleActiveTab(); // adds active class
        TNCApproval.requiresTNCApproval($('#btn_accept'), function () {
            $('.tnc_accept').setVisibility(1);
        }, function () {
            $('#tnc_accept').html(localize('Your settings have been updated successfully.'));
        });
        tabListener();

        initSidebar();

        checkWidth();
        window.onresize = checkWidth;

        $('.currentYear').text(new Date().getFullYear());
    };

    var handleActiveTab = function handleActiveTab() {
        var params = window.location.hash.split('&');
        var hash = params[0] || '#legal';
        var menu = '.tab-menu-wrap';
        var content = '.tab-content-wrapper';

        var parent_active = 'active';
        var child_active = 'a-active';

        $(menu).find('li').removeClass(parent_active).find('span').removeClass(child_active);

        var $tab_to_show = $(hash);
        // if hash is a subtab or has subtabs
        if ($tab_to_show.find('.tm-li-2').length > 0 || /tm-li-2/.test($(hash).attr('class'))) {
            $tab_to_show = $tab_to_show.find('.tm-a-2').first().addClass(child_active).closest('.tm-li');
        }
        $tab_to_show.addClass(parent_active);

        var content_to_show = 'div' + hash + '-content';
        if ($(content_to_show).length === 0) {
            content_to_show = 'div#' + $(hash).find('.tm-li-2').first().attr('id') + '-content';
        }
        $(content).find('> div').setVisibility(0).end().find(content_to_show).setVisibility(1);
    };

    var initSidebar = function initSidebar() {
        var _window$location = window.location,
            hash = _window$location.hash,
            pathname = _window$location.pathname;


        if (!hash) {
            window.history.replaceState({}, '', pathname + '#legal-binary');
        } else if ($(hash + '-link').is('.has-submenu')) {
            window.history.replaceState({}, '', '' + pathname + hash + '-binary');
        }

        $('.sidebar-collapsible').on('click', sidebarClickHandler);
        updateSidebarDOM();
    };

    var updateSidebarDOM = function updateSidebarDOM() {
        var id = window.location.hash;
        var $li = $(id + '-link');
        var $parent_li = $li.closest('.has-submenu');

        if ($parent_li.length) {
            $parent_li.addClass('active').children('a').addClass('selected no-transition');
        }

        $li.addClass('active').find('a').addClass('selected');

        $(id + '-content').removeClass('invisible');
    };

    var sidebarClickHandler = function sidebarClickHandler(e) {
        var $target = $(e.target);
        if (!$target.is('a')) return;
        var $submenu = $target.siblings('ul');

        if ($submenu.length) {
            // parent link is clicked
            e.preventDefault();

            if ($submenu.find('.selected').length) {
                // has selected sublink
                $target.removeClass('no-transition').parent('li').toggleClass('active');
            } else {
                window.location.hash = $submenu.find('a')[0].hash;
            }
        }
    };

    var checkWidth = function checkWidth() {
        var mq = window.matchMedia('(max-width: 1023px)').matches;
        if (mq) {
            $('.sidebar-collapsible').css({ position: 'relative' });
            $(window).off('scroll', stickySidebar);
        } else {
            $(window).on('scroll', stickySidebar);
        }
        return mq;
    };

    var stickySidebar = function stickySidebar() {
        var $sidebar = $('.sidebar-collapsible');
        var $content = $('.sidebar-collapsible-content');
        var $container = $('.sidebar-collapsible-container');

        if (!$sidebar.is(':visible')) return;

        if (window.scrollY < $content.offset().top) {
            $sidebar.css({ position: 'relative' });
        } else if (window.scrollY + $sidebar[0].offsetHeight + 20 >= $container[0].offsetHeight + $container.offset().top) {
            // 20 is the padding for content from bottom, to avoid menu snapping back up
            $sidebar.css({ position: 'absolute', bottom: '20px', top: '', width: sidebar_width });
        } else {
            $sidebar.css({ position: 'fixed', top: '0px', bottom: '', width: sidebar_width });
        }
    };

    var onUnload = function onUnload() {
        $('.sidebar-collapsible').off('click');
    };

    return {
        onLoad: onLoad,
        onUnload: onUnload
    };
}();

module.exports = TermsAndConditions;

/***/ }),
/* 342 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Scroll = __webpack_require__(94);
var Client = __webpack_require__(3);

var WhyUs = function () {
    var onLoad = function onLoad() {
        Scroll.sidebarScroll($('.why-us'));
        Client.activateByClientType();
    };

    var onUnload = function onUnload() {
        Scroll.offScroll();
    };

    return {
        onLoad: onLoad,
        onUnload: onUnload
    };
}();

module.exports = WhyUs;

/***/ }),
/* 343 */,
/* 344 */,
/* 345 */,
/* 346 */,
/* 347 */,
/* 348 */,
/* 349 */,
/* 350 */,
/* 351 */,
/* 352 */,
/* 353 */,
/* 354 */,
/* 355 */,
/* 356 */,
/* 357 */,
/* 358 */,
/* 359 */,
/* 360 */,
/* 361 */,
/* 362 */,
/* 363 */,
/* 364 */,
/* 365 */,
/* 366 */,
/* 367 */,
/* 368 */,
/* 369 */,
/* 370 */,
/* 371 */,
/* 372 */,
/* 373 */,
/* 374 */,
/* 375 */,
/* 376 */,
/* 377 */,
/* 378 */,
/* 379 */,
/* 380 */,
/* 381 */,
/* 382 */,
/* 383 */,
/* 384 */,
/* 385 */,
/* 386 */,
/* 387 */,
/* 388 */,
/* 389 */,
/* 390 */,
/* 391 */,
/* 392 */,
/* 393 */,
/* 394 */,
/* 395 */,
/* 396 */,
/* 397 */,
/* 398 */,
/* 399 */,
/* 400 */,
/* 401 */,
/* 402 */,
/* 403 */,
/* 404 */,
/* 405 */,
/* 406 */,
/* 407 */,
/* 408 */,
/* 409 */,
/* 410 */,
/* 411 */,
/* 412 */,
/* 413 */,
/* 414 */,
/* 415 */,
/* 416 */,
/* 417 */,
/* 418 */,
/* 419 */,
/* 420 */,
/* 421 */,
/* 422 */,
/* 423 */,
/* 424 */,
/* 425 */,
/* 426 */,
/* 427 */,
/* 428 */,
/* 429 */,
/* 430 */,
/* 431 */,
/* 432 */,
/* 433 */,
/* 434 */,
/* 435 */,
/* 436 */,
/* 437 */,
/* 438 */,
/* 439 */,
/* 440 */,
/* 441 */,
/* 442 */,
/* 443 */,
/* 444 */,
/* 445 */,
/* 446 */,
/* 447 */,
/* 448 */,
/* 449 */,
/* 450 */,
/* 451 */,
/* 452 */,
/* 453 */,
/* 454 */,
/* 455 */,
/* 456 */,
/* 457 */,
/* 458 */,
/* 459 */,
/* 460 */,
/* 461 */,
/* 462 */,
/* 463 */,
/* 464 */,
/* 465 */,
/* 466 */,
/* 467 */,
/* 468 */,
/* 469 */,
/* 470 */,
/* 471 */,
/* 472 */,
/* 473 */,
/* 474 */,
/* 475 */,
/* 476 */,
/* 477 */,
/* 478 */,
/* 479 */,
/* 480 */,
/* 481 */,
/* 482 */,
/* 483 */,
/* 484 */,
/* 485 */,
/* 486 */,
/* 487 */,
/* 488 */,
/* 489 */,
/* 490 */,
/* 491 */,
/* 492 */,
/* 493 */,
/* 494 */,
/* 495 */,
/* 496 */,
/* 497 */,
/* 498 */,
/* 499 */,
/* 500 */,
/* 501 */,
/* 502 */,
/* 503 */,
/* 504 */,
/* 505 */,
/* 506 */,
/* 507 */,
/* 508 */,
/* 509 */,
/* 510 */,
/* 511 */,
/* 512 */,
/* 513 */,
/* 514 */,
/* 515 */,
/* 516 */,
/* 517 */,
/* 518 */,
/* 519 */,
/* 520 */,
/* 521 */,
/* 522 */,
/* 523 */,
/* 524 */,
/* 525 */,
/* 526 */,
/* 527 */,
/* 528 */,
/* 529 */,
/* 530 */,
/* 531 */,
/* 532 */,
/* 533 */,
/* 534 */,
/* 535 */,
/* 536 */,
/* 537 */,
/* 538 */,
/* 539 */,
/* 540 */,
/* 541 */,
/* 542 */,
/* 543 */,
/* 544 */,
/* 545 */,
/* 546 */,
/* 547 */,
/* 548 */,
/* 549 */,
/* 550 */,
/* 551 */,
/* 552 */,
/* 553 */,
/* 554 */,
/* 555 */,
/* 556 */,
/* 557 */,
/* 558 */,
/* 559 */,
/* 560 */,
/* 561 */,
/* 562 */,
/* 563 */,
/* 564 */,
/* 565 */,
/* 566 */,
/* 567 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 568 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ })
],[332]);
//# sourceMappingURL=binary.js.map